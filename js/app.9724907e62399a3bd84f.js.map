{"version":3,"sources":["webpack:///js/app.9724907e62399a3bd84f.js","webpack:///./src/app/app.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/angular-animate/index.js","webpack:///./~/angular-animate/angular-animate.js","webpack:///./src/app/bookmarks/index.js","webpack:///./src/app/services/index.js","webpack:///./src/app/services/CategoriesService.js","webpack:///./src/app/services/BookmarksService.js","webpack:///./src/app/bookmarks/BookmarksController.js","webpack:///./src/app/bookmarks/edit/index.js","webpack:///./src/app/bookmarks/edit/EditController.js","webpack:///./src/app/bookmarks/edit/routing.js","webpack:///./src/app/bookmarks/edit/edit.tpl.html","webpack:///./src/app/bookmarks/create/index.js","webpack:///./src/app/bookmarks/create/CreateController.js","webpack:///./src/app/bookmarks/create/routing.js","webpack:///./src/app/bookmarks/create/create.tpl.html","webpack:///./src/app/bookmarks/routing.js","webpack:///./src/app/bookmarks/bookmarks.tpl.html","webpack:///./src/app/categories/index.js","webpack:///./src/app/categories/CategoriesController.js","webpack:///./src/app/categories/routing.js","webpack:///./src/app/categories/categories.tpl.html","webpack:///./src/app/routing.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_angular","_angular2","_angularUiRouter","_angularUiRouter2","_angularAnimate","_angularAnimate2","_bookmarks","_bookmarks2","_categories","_categories2","_services","_services2","_edit","_edit2","_create","_create2","_routing","_routing2","config","root","factory","this","modules","moduleId","installedModules","id","loaded","call","m","c","p","__export","hasOwnProperty","Object","defineProperty","value","router_1","UIRouter","bindFunctions","from","to","bindTo","fnNames","keys","filter","name","forEach","bind","defaults","opts","defaultsList","_i","arguments","length","merge","apply","concat","extend","pick","dst","objs","key","ancestors","first","second","path","n","push","equalForKeys","a","b","i","k","pickOmitImpl","predicate","objCopy","restArgs","inArray","omit","hof_1","not","pluck","collection","propName","map","prop","callback","arr","predicates_1","isArray","result","accept","x","item","find","pushR","assertPredicate","errMsg","Error","isFunction","arrayTuples","arrayArgs","reduce","min","Math","Array","ignored","idx","applyPairs","memo","keyValTuple","isString","tail","undefined","_copy","src","dest","_forEach","cb","_this","_copyProps","_extend","toObj","rest","identity","_equals","o1","o2","t1","t2","tup","all","_arraysEq","isDate","getTime","isRegExp","toString","predicates","any","fn","a1","a2","t","w","window","angular","fromJson","JSON","parse","toJson","stringify","copy","equals","noop","abstractKey","inherit","parent","extra","prototype","args","slice","array","indexOf","removeFrom","curry","splice","mergeR","mapObj","values","allTrueR","elem","anyTrueR","unnestR","flattenR","unnest","flatten","pairs","object","isInjectable","val","head","toStr","tis","isUndefined","isDefined","isNull","o","isNumber","isObject","isPromise","and","pipe","curried","func_args_length","initial_args","compose","start","funcs","reverse","fn1","fn2","or","invoke","fnName","pattern","struct","propEq","split","none","is","ctor","constructor","eq","other","v","notImplemented","fnname","services","$q","$injector","location","locationConfig","template","Glob","text","glob","matches","segments","l","unshift","Number","MAX_VALUE","join","fromString","Queue","_items","_limit","enqueue","items","shift","dequeue","size","clear","current","remove","peekTail","peekHead","maxLength","max","str","substr","padString","kebobString","camelCase","replace","$1","toLowerCase","promiseToString","functionToString","fnStr","fnToString","namedFunctionMatch","match","_fn","format","seen","stringifyPattern","rejectFactory_1","common_1","transition_1","resolvable_1","isTransitionRejectionPromise","Rejection","_transitionRejection","Transition","Resolvable","beforeAfterSubstr","char","coreservices_1","strings_1","RejectType","type","message","detail","detailString","d","toPromise","reject","then","superseded","options","rejection","SUPERSEDED","redirected","invalid","INVALID","IGNORED","aborted","ABORTED","trace_1","module_1","node_1","pathFactory_1","module_2","module_3","module_4","transitionCount","stateSelf","fromPath","targetState","_transitionService","_deferred","defer","promise","treeChanges","_treeChanges","isActive","_options","valid","error","HookRegistry","mixin","$id","toPath","PathFactory","buildToPath","applyViewConfigs","$view","reloadState","bindTransitionResolve","$from","state","$to","self","compare","matchState","params","pathname","resolves","resolveContext","getResolvables","res","data","addResolves","stateName","topath","targetNode","node","addResolvables","makeResolvables","previous","entering","exiting","retained","views","redirect","newOptions","TargetState","identifier","$state","redirectTo","redirectedPath","copyResolvesFor","Node","matching","includes","includeResolve","resolve","_changedParams","_a","reload","nodeSchemas","paramSchema","_b","paramValues","toValues","fromValues","tuples","schema","toVals","fromVals","Param","changed","dynamic","changes","hookBuilder","HookBuilder","transition","run","runSynchronousHooks","TransitionHook","runSuccessHooks","getOnSuccessHooks","runErrorHooks","$error$","getOnErrorHooks","syncResult","getOnBeforeHooks","rejectReason","trace","traceTransitionIgnored","success","traceSuccess","traceError","traceTransitionStart","chain","asyncHooks","_chain","step","invokeHook","validates","parameters","fromStateOrName","toStateOrName","avoidEmptyHash","fromParams","toValid","toParams","uiViewString","viewData","creationContext","fqn","normalizedCat","input","Category","viewConfigString","viewConfig","viewDecl","$context","$uiViewName","$uiViewContextAnchor","Trace","_enabled","approximateDigests","_set","enabled","categories","isNaN","parseInt","category","enable","disable","TRANSITION","tid","digest","transitionStr","console","log","traceHookInvocation","HOOK","event","context","traceHookResult","hookResult","transitionResult","transitionOptions","hookResultStr","transitionResultStr","traceResolvePath","RESOLVE","pathStr","policyStr","resolvePolicy","traceResolvePathElement","pathElement","resolvablePromises","resolvablePromisesStr","pathElementStr","traceResolveResolvable","resolvable","resolvableStr","traceResolvableResolved","tracePathElementInvoke","deps","INVOKE","when","finalState","traceUiViewEvent","UIVIEW","traceUiViewConfigUpdated","traceUiViewScopeCreated","newScope","traceUiViewFill","html","traceViewServiceEvent","VIEWCONFIG","traceViewServiceUiViewEvent","tupleSort","reverseDepthSort","r","factor","depthDelta","hook","priority","$transitions","baseHookOptions","_buildNodeHooks","async","getOnStartHooks","getOnExitHooks","$state$","getOnRetainHooks","getOnEnterHooks","getOnFinishHooks","$treeChanges$","rejectIfSuperseded","toState","fromState","onStartHooks","onExitHooks","onRetainHooks","onEnterHooks","onFinishHooks","hookType","matchingNodesProp","sortHooksFn","getLocals","matchingHooks","_matchingHooks","makeTransitionHooks","nodes","traceData","transitionHook","sort","tuple","hookName","reg","getHooks","criterion","matchGlobs","_state","globStrings","toMatch","glob_1","matchFn","makeHookRegistrationFn","hooks","matchObject","eventHook","EventHook","matchCriteria","_matchingNodes","mc","allMatched","_transitionEvents","onBefore","onStart","onEnter","onRetain","onExit","onFinish","onSuccess","onError","source","target","defaultOptions","locals","isSuperseded","moreLocals","invokeNow","handleHookResult","invokeLater","mapHookResult","swallowExceptions","results","exception","rejections","StateProvider","stateRegistry","invalidCallbacks","decorator","func","definition","register","onInvalid","parseUrl","url","charAt","substring","StateBuilder","matcher","$urlMatcherFactoryProvider","isRoot","builders","$$state","parentName","stateDec","parsed","compile","paramMap","paramConfig","isSearch","reloadOnSearch","isMatcher","navigable","append","makeConfigParam","fromConfig","urlParams","nonUrlParams","builder","build","parentFn","lastIndexOf","unwrapShorthand","cfg","isShorthand","$$fn","getType","urlType","paramTypes_1","paramTypes","type_1","Type","DefType","CONFIG","getSquashPolicy","isOptional","squash","urlMatcherConfig_1","matcherConfig","defaultSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","hasOwn","getArrayMode","arrayDefaults","SEARCH","arrayParamNomenclature","$asArray","isDefaultValue","$$getDefaultValue","defaultValue","$replace","replacement","$normalize","normalized","encoded","encode","exec","PATH","fromSearch","param","values1","values2","MatcherConfig","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","caseInsensitive","strictMode","ArrayType","mode","arrayWrap","arrayUnwrap","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","left","right","$arrayMode","def","decode","$subPattern","sub","valToString","valFromString","ParamTypes","typeQueue","defaultTypes","hash","String","string","int","bool","Boolean","date","getFullYear","getMonth","getDate","capture","Date","valueOf","acc","json","makeType","types","definitionFn","_flushTypeQueue","StateParams","$inherit","newParams","$current","parentParams","parents","inherited","inheritList","j","targetState_1","viewHooks_1","enterExitHooks_1","resolveHooks_1","TransitionManager","$urlRouter","globals","viewHooks","ViewHooks","enterExitHooks","EnterExitHooks","resolveHooks","ResolveHooks","registerUpdateGlobalState","registerHooks","runTransition","transitionHistory","trans","transRejected","updateUrl","update","_redirectMgr","defaultErrorHandler","_identifier","_definition","_params","exists","base","relative","enteringViews","exitingViews","loadAllEnteringViews","view","load","updateViews","deactivateViewConfig","activateViewConfig","sync","registerOnEnterHooks","registerOnRetainHooks","registerOnExitHooks","interface_1","hof_2","LAZY","ResolvePolicy","EAGER","$eagerResolvePath","$transition$","resolvePath","$lazyResolveEnteringState","$resolve$","resolvePathElement","resolveResolvable","$inject","resolveFn","preResolvedData","annotate","strictDi","deferred","ancestorsByName","omitOwnLocals","depResolvables","depPromises","get","State","ref","parameter","StateMatcher","_states","isRelative","stateOrName","isStr","baseState","splitName","pathLength","relName","StateQueueManager","states","$urlRouterProvider","queue","flush","orphanIdx","orphans","previousQueueLength","attachRoute","prev","autoFlush","$match","$stateParams","transitionTo","stateMatcher_1","stateBuilder_1","stateQueueManager_1","StateRegistry","urlMatcherFactory","urlRouterProvider","stateQueue","rootStateDef","#","abstract","_root","stateDefinition","found","queue_1","transitionService_1","transitionManager_1","param_1","common_2","common_3","StateService","stateProvider","getters","boundFns","enumerable","configurable","_handleInvalidTargetState","$to$","invokeNextCallback","nextCallback","callbackQueue","invokeCallback","checkForRedirect","latestThing","latest","$from$","makeTargetState","notify","go","defautGoOpts","transOpts","defaultTransOpts","transHistory","latestSuccess","successfulTransitions","rootPath","bindTransNodesToPath","currentPath","create","tMgr","transitionPromise","include","href","defaultHrefOpts","lossy","absolute","nav","buildPath","applyRawParams","inheritParams","viewDecls","viewConfigs","createViewConfig","toKeys","nodeParamVals","makeInheritedParamsNode","_fromPath","_toKeys","toNode","toParamVals","incomingParamVals","fromParamVals","ownParamVals","ResolveContext","isolateRootTo","resolveInjector","ResolveInjector","applyToParams","retainedNode","cloned","clone","keep","staticParams","nodesMatch","node1","node2","retainedWithToParams","enteringResolvePath","toResolvePath","rootNode","subPath","_node","elementIdx","getParamVal","paramDef","pDef","paramValsEq","matchedCount","getPolicy","stateResolvePolicyConf","stateLevelPolicy","resolveLevelPolicies","policyName","defaultResolvePolicy","_path","_nodeFor","_pathTo","last","omitProps","filteredResolvables","getResolvablesForFn","resolvables","getOwnResolvables","promiseForNode","policy","policyOrdinal","matchesRequestedPolicy","matchingResolves","getResolvePromise","getPromise","promises","resolvedLocals","_resolveContext","injectedFn","hookRegistry_1","custom","TransitionService","_defaultErrorHandler","handler","quoteRegExp","surroundPattern","predicates_2","memoizeTo","UrlMatcher","_cache","_children","_segments","_compiled","strict","segment","placeholder","searchPlaceholder","patterns","checkParamErrors","nameValidator","test","matchDetails","regexp","index","RegExp","lastIndex","search","prefix","freeze","decodePathArray","reverseString","unquoteDashes","allReversed","allParams","pathParams","searchParams","nPathSegments","urlm","validParamVal","getDetails","urlMatchers","pathSegmentsAndParams","queryParams","pathString","encodeDashes","raw","encodeURIComponent","queryString","charCodeAt","toUpperCase","staticSegments","getDefaultConfig","UrlMatcherFactory","$get","regExpPrefix","re","interpolate","what","handleIfMatch","appendBasePath","isHtml5","baseHref","rules","otherwiseFn","evt","check","rule","handled","$location","defaultPrevented","UrlRouterProvider","$urlMatcherFactory","interceptDeferred","otherwise","handlerIsString","strategies","_what","_handler","regex","global","sticky","deferIntercept","UrlRouter","listen","listener","onChange","read","urlMatcher","html5Mode","hashPrefix","slash","port","protocol","host","ViewService","uiViews","_viewConfigFactories","uiViewDepth","uiView","viewConfigDepth","count","uiViewsByFqn","uiv","$type","vc","vcSegments","uivSegments","negOffset","fqnToFirstSegment","uiViewContext","depthCompare","depthFn","posNeg","matchingConfigPair","matchingConfigs","configureUiView","configUpdated","rootContext","_rootContext","viewConfigFactory","viewType","decl","cfgFactory","cfgs","registerUiView","fqnMatches","available","active","normalizeUiViewTarget","rawViewName","viewAtContext","uiViewName","uiViewContextAnchor","relativeViewNameSugar","relativeMatch","anchor","stateParams_1","UIRouterGlobals","transitionService","beforeNewTransition","updateGlobalState","clearCurrentTransition","urlMatcherFactory_1","urlRouter_1","state_1","urlRouter_2","view_1","stateRegistry_1","stateService_1","globals_1","viewService","urlRouter","stateService","annotateController","controllerExpression","$controller","oldInstantiate","instantiate","deps_1","constructorFunction","$scope","runBlock","ng1UIRouter","$locationProvider","$browser","$sniffer","$rootScope","$http","$templateCache","$on","urlListeners","history","cache","headers","Accept","router","viewsBuilder_1","ng1ViewsBuilder","resolvesBuilder_1","ng1ResolveBuilder","ng1ViewConfigFactory","getUrlRouterProvider","getStateProvider","getTransitionsProvider","loadAllControllerLocals","loadLocals","$loadControllerLocals","resolveCtx","controllerDeps","controller","dep","loadAllLocals","watchDigests","$watch","templateFactory_1","app","resolveFactory","invocables","parentNode","resolveData","parentLocals","rewrap","_locals","local","provider","TemplateFactory","service","tplKeys","ctrlKeys","compKeys","nonCompKeys","allKeys","viewsObject","$default","component","templateProvider","resolveFor","bindings","version","minor","attributeTpl","attrName","resolveName","attrs","getComponentInputs","kebobName","resolveAs","$name","cmpDefs","getBindings","Ng1ViewConfig","scopeBindings","bindingsObj","bindToController","scope","hasTemplate","injector","getTemplate","getController","templateUrl","$factory","controllerProvider","injectFn","fromUrl","fromProvider","parseStateRef","preparsed","paramExpr","stateContext","el","$uiView","inheritedData","getTypeInfo","isSvg","isForm","nodeName","attr","isAnchor","clickable","clickHook","$timeout","e","button","which","ctrlKey","metaKey","shiftKey","preventDefault","ignorePreventDefaultCount","cancel","defaultOpts","uiSrefNg1","restrict","require","link","element","uiSrefActive","uiSref","unlinkInfoFn","uiSrefOpts","$eval","$$addStateInfo","$set","uiStateNg1","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","uiSrefActiveNg1","$interpolate","$element","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","stateInfo","activeClasses","anyMatch","addClass","removeClass","exactMatch","activeEqClass","className","uiSrefActiveEq","newState","deregister","updateAfterTransition","deregisterFn","directive","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","$ViewDirectiveFill","$compile","getControllerAs","getResolveAs","getResolveContext","tElement","initial","$cfg","contents","controllerAs","controllerInstance","children","registerControllerCallbacks","cmp_1","kebobName_1","getComponentController","directiveEl","tagName","deregisterWatch_1","ctrlInstance","$onInit","hasComponentImpl","hookOptions","uiOnParamsChanged","paramsUpdated_1","ctx","viewCreationTrans","toSchema","fromSchema","changedToParams","changedKeys_1","onDynamic","uiCanExit","criteria","uiViewNg1","$animate","$uiViewScroll","getRenderer","enter","leave","configsEqual","config1","config2","rootData","terminal","transclude","tAttrs","$transclude","configUpdatedCallback","activeUIView","updateView","cleanupLastView","previousEl","currentScope","$destroy","currentEl","_viewData_1","renderer","$$animLeave","$new","animEnter","animLeave","$uiViewData","$animEnter","$animLeave","$emit","autoScrollExp","onloadExp","unregister","onload","autoscroll","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","assertArg","arg","reason","ngMinErr","mergeClasses","packageStyles","styles","pendClasses","classes","fix","isPrefix","klass","removeFromArray","stripCommentsFromElement","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","$$removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationDetails","oldAnimation","newAnimation","toAdd","toRemove","resolveElementClasses","preparationClasses","concatWithSpace","realDomOperation","existing","splitClassesToLookup","ADD_CLASS","REMOVE_CLASS","flags","allow","getDomNode","applyGeneratedPreparationClasses","EVENT_CLASS_PREFIX","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","clearGeneratedClasses","blockTransitions","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","delay","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","$window","properties","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","parseMaxTime","maxValue","parseFloat","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","entry","total","put","registerRestorableStyles","backup","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isElement","ACTIVE_CLASS_SUFFIX","PREPARE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$minErr","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","nextTick","cancelFn","waitUntilQuiet","$$AnimateChildrenDirective","setData","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","$$AnimateRunner","$$forceReflow","$$rAFScheduler","$$animateQueue","gcsHashFn","extraClasses","KEY","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","rafWaitQueue","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","initialOptions","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","restoreStyles","setProperty","removeProperty","onDone","events","off","onAnimationProgress","animationTimerData","timer","removeData","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","$$willAnimate","stopPropagation","ev","originalEvent","timeStamp","$manualTimeStamp","now","elapsedTime","toFixed","startTime","maxDelayTime","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDurationTime","easing","easeProp","easeVal","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","onAnimationExpired","on","cleanupStyles","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","animations","transitions","method","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","$document","filterCssClasses","getUniqueValues","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","getClassVal","prepareInAnimation","endingClasses","startingClasses","cloneNode","rootBodyElement","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","status","animationDetails","body","contains","$$AnimateJsProvider","lookupAnimations","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","classesToAdd","classesToRemove","groupEventedAnimations","operations","ani","endProgressCb","resolved","onAnimationComplete","cancelled","packageAnimations","runners","animateFn","before","after","afterFn","beforeFn","onComplete","endAnimations","closeActiveAnimations","setHost","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","makeTruthyCssClassMap","classString","ONE_SPACE","hasMatchingClasses","newClassString","currentClassString","currentClassMap","some","isAllowed","ruleType","previousAnimation","hasAnimationClasses","PRE_DIGEST_STATE","RUNNING_STATE","skip","nA","nR","cA","cR","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationDetails","findCallbacks","targetParentNode","entries","callbackRegistry","filterFromRegistry","list","matchContainer","matchCallback","containerNode","isMatch","cleanupEventListeners","phase","queueAnimation","notifyProgress","runInNextPostDigestOrNow","callbacks","progress","isAnimatableClassName","documentHidden","hidden","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","querySelectorAll","child","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","rootElementDetected","parentAnimationDetected","elementDisabled","parentHost","details","parentElementDisabled","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","totalPendingRequests","isEmpty","classNameFilter","compareDocumentPosition","container","eventType","pin","argCount","hasElement","recordExists","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","lookupKey","beforeStart","cssClassesIntersection","out","in","aa","invokeFirstDriver","driverName","driver","tempClasses","prepareClassName","updateAnimationRunners","newRunner","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","ngAnimateSwapDirective","ctrl","previousElement","previousScope","$watchCollection","ngAnimateSwap","_BookmarksController","_BookmarksController2","_CategoriesService","_CategoriesService2","_BookmarksService","_BookmarksService2","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","CategoriesSrv","urlFetch","currentCategory","cacheCategories","extract","_","bookmarkId","hasId","bookmark","findBookmark","bookmarks","bookmarkFound","getBookmarks","categoryName","hasName","findCategory","categoryFound","getCategories","BookmarksSrv","cacheBookmarks","findIndex","BookmarksCtrl","bookmarksSrv","categoriesSrv","setCurrentCategory","getCategoryByName","getCurrentCategory","getCurrentCategoryName","isSelectedBookmark","deleteBookmark","_EditController","_EditController2","EditCtrl","returnToBookmarks","setEditState","isEditing","editedBookmark","updateBookmark","cancelEditing","getBookmarkById","toggleEditing","routing","$stateProvider","@eggly.categories.bookmarks","_editTpl2","_editTpl","_CreateController","_CreateController2","_createTpl2","_createTpl","bookmarks@","_bookmarksTpl2","_bookmarksTpl","_CategoriesController","_CategoriesController2","CategoriesCtrl","isCurrentCategory","categories@","categoriesCtrl","_categoriesTpl2","bookmarksCtrl","_categoriesTpl"],"mappings":"AAAAA,cAAc,IAER,SAASC,EAAQC,EAASC,GCFhC,YA0CA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAzCvFF,EAAA,GACAA,EAAA,EAGA,IAAAK,GAAAL,EAAA,GAGIM,EAAYL,EAAuBI,GAFvCE,EAAAP,EAAA,GAMIQ,EAAoBP,EAAuBM,GAL/CE,EAAAT,EAAA,GASIU,EAAmBT,EAAuBQ,GAP9CE,EAAAX,EAAA,GAWIY,EAAcX,EAAuBU,GAVzCE,EAAAb,EAAA,IAcIc,EAAeb,EAAuBY,GAb1CE,EAAAf,EAAA,GAiBIgB,EAAaf,EAAuBc,GAfxCE,EAAAjB,EAAA,IAmBIkB,EAASjB,EAAuBgB,GAlBpCE,EAAAnB,EAAA,IAsBIoB,EAAWnB,EAAuBkB,GApBtCE,EAAArB,EAAA,IAwBIsB,EAAYrB,EAAuBoB,EAtBvCf,cAAQR,OAAO,SAASY,aAAAF,aAAAQ,aAAAF,aAAAF,aAAAM,aAAAE,eASrBG,OATHD,eDqCM,SAASxB,EAAQC,KAMvB,EACO,CACA,CAED,SAASD,EAAQC,EAASC;;;;;;CE3DhC,SAAAwB,EAAAC,GAEA3B,EAAAC,QAAA0B,KAOCC,KAAA,WACD,gBAAAC,GAKA,QAAA3B,GAAA4B,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAA7B,OAGA,IAAAD,GAAA+B,EAAAD,IACA7B,WACA+B,GAAAF,EACAG,QAAA,EAUA,OANAJ,GAAAC,GAAAI,KAAAlC,EAAAC,QAAAD,IAAAC,QAAAC,GAGAF,EAAAiC,QAAA,EAGAjC,EAAAC,QAvBA,GAAA8B,KAqCA,OATA7B,GAAAiC,EAAAN,EAGA3B,EAAAkC,EAAAL,EAGA7B,EAAAmC,EAAA,GAGAnC,EAAA,KAKA,SAAAF,EAAAC,EAAAC,GAOA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAEAC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAsC,OAAAC,eAAAxC,EAAA,cAA+CyC,OAAA,IAC/CzC,aAAA,aAKA,SAAAD,EAAAC,EAAAC,GAGA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAEAC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,IACA,IAAAyC,GAAAzC,EAAA,GACAD,GAAA2C,SAAAD,EAAAC,UAKA,SAAA5C,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,IACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAOA,YAqEA,SAAA2C,GAAAC,EAAAC,EAAAC,EAAAC,GAEA,MADA,UAAAA,IAA8BA,EAAAT,OAAAU,KAAAJ,IAC9BG,EAAAE,OAAA,SAAAC,GAA4C,wBAAAN,GAAAM,KAC5CC,QAAA,SAAAD,GAAmC,MAAAL,GAAAK,GAAAN,EAAAM,GAAAE,KAAAN,KAmDnC,QAAAO,GAAAC,GACA,SAAAA,IAA2BA,KAE3B,QADAC,MACAC,EAAA,EAAqBA,EAAAC,UAAAC,OAAuBF,IAC5CD,EAAAC,EAAA,GAAAC,UAAAD,EAEA,IAAAH,GAAAM,EAAAC,MAAA,UAAyCC,OAAAN,GACzC,OAAAxD,GAAA+D,UAA6BT,EAAAU,EAAAT,MAA2BhB,OAAAU,KAAAK,KAOxD,QAAAM,GAAAK,GAEA,OADAC,MACAT,EAAA,EAAqBA,EAAAC,UAAAC,OAAuBF,IAC5CS,EAAAT,EAAA,GAAAC,UAAAD,EAQA,OANAzD,GAAAoD,QAAAc,EAAA,SAAA/D,GACAH,EAAAoD,QAAAjD,EAAA,SAAAsC,EAAA0B,GACAF,EAAA3B,eAAA6B,KACAF,EAAAE,GAAA1B,OAGAwB,EAYA,QAAAG,GAAAC,EAAAC,GACA,GAAAC,KACA,QAAAC,KAAAH,GAAAE,KAAA,CACA,GAAAF,EAAAE,KAAAC,KAAAF,EAAAC,KAAAC,GACA,KACAD,GAAAE,KAAAJ,EAAAE,KAAAC,IAEA,MAAAD,GAYA,QAAAG,GAAAC,EAAAC,EAAA3B,GACA,SAAAA,IAA2BA,EAAAV,OAAAU,KAAA0B,GAC3B,QAAAE,GAAA,EAAoBA,EAAA5B,EAAAU,OAAiBkB,IAAA,CACrC,GAAAC,GAAA7B,EAAA4B,EACA,IAAAF,EAAAG,IAAAF,EAAAE,GACA,SAEA,SAGA,QAAAC,GAAAC,EAAA7E,GACA,GAAA8E,MAAqBhC,EAAAiC,EAAAxB,UAAA,EACrB,QAAAS,KAAAhE,GACA6E,EAAA/B,EAAAkB,KACAc,EAAAd,GAAAhE,EAAAgE,GAEA,OAAAc,GAGA,QAAAjB,GAAA7D,GAAqB,MAAA4E,GAAAlB,MAAA,MAAAsB,GAAArB,OAAAoB,EAAAxB,aAGrB,QAAA0B,GAAAjF,GAAqB,MAAA4E,GAAAlB,MAAA,MAAAwB,EAAAC,IAAAH,IAAArB,OAAAoB,EAAAxB,aAKrB,QAAA6B,GAAAC,EAAAC,GACA,MAAAC,GAAAF,EAAAH,EAAAM,KAAAF,IAIA,QAAAvC,GAAAsC,EAAAI,GACA,GAAAC,GAAAC,EAAAC,QAAAP,GAAAQ,EAAAH,QACAI,EAAAJ,EAAA,SAAAK,GAAsC,MAAAF,GAAAvB,KAAAyB,IAAyB,SAAAA,EAAA/B,GAAsB,MAAA6B,GAAA7B,GAAA+B,EAKrF,OAJAlG,GAAAoD,QAAAoC,EAAA,SAAAW,EAAAtB,GACAe,EAAAO,EAAAtB,IACAoB,EAAAE,EAAAtB,KAEAmB,EAIA,QAAAI,GAAAZ,EAAAI,GACA,GAAAI,EAOA,OANAhG,GAAAoD,QAAAoC,EAAA,SAAAW,EAAAtB,GACAmB,GAEAJ,EAAAO,EAAAtB,KACAmB,EAAAG,KAEAH,EAMA,QAAAN,GAAAF,EAAAI,GACA,GAAAI,GAAAF,EAAAC,QAAAP,QAEA,OADAxF,GAAAoD,QAAAoC,EAAA,SAAAW,EAAAtB,GAAqD,MAAAmB,GAAAnB,GAAAe,EAAAO,EAAAtB,KACrDmB,EAgEA,QAAAK,GAAAR,EAAA1F,GAA0C,MAAf0F,GAAApB,KAAAtE,GAAe0F,EAoC1C,QAAAS,GAAAtB,EAAAuB,GAEA,MADA,UAAAA,IAA6BA,EAAA,kBAC7B,SAAApG,GACA,IAAA6E,EAAA7E,GACA,SAAAqG,OAAAV,EAAAW,WAAAF,KAAApG,GAAAoG,EAEA,WA4BA,QAAAG,KAEA,OADAC,MACAlD,EAAA,EAAqBA,EAAAC,UAAAC,OAAuBF,IAC5CkD,EAAAlD,EAAA,GAAAC,UAAAD,EAEA,QAAAkD,EAAAhD,OACA,QACA,IAAAA,GAAAgD,EAAAC,OAAA,SAAAC,EAAAhB,GAAwD,MAAAiB,MAAAD,IAAAhB,EAAAlC,OAAAkD,IAAoC,iBAC5F,OAAAE,OAAAlD,MAAA,KAAAkD,MAAApD,IAAA+B,IAAA,SAAAsB,EAAAC,GAA0E,MAAAN,GAAAjB,IAAA,SAAAG,GAAsC,MAAAA,GAAAoB,OAuBhH,QAAAC,GAAAC,EAAAC,GACA,GAAAjD,GAAA1B,CAGA,IAFAqD,EAAAC,QAAAqB,KACAjD,EAAAiD,EAAA,GAAA3E,EAAA2E,EAAA,KACAtB,EAAAuB,SAAAlD,GACA,SAAAqC,OAAA,mCAEA,OADAW,GAAAhD,GAAA1B,EACA0E,EAIA,QAAAG,GAAAzB,GACA,MAAAA,GAAAlC,QAAAkC,IAAAlC,OAAA,IAAA4D,OASA,QAAAC,GAAAC,EAAAC,GAKA,MAJAA,IACAnF,OAAAU,KAAAyE,GAAAtE,QAAA,SAAAe,GAAmD,aAAAuD,GAAAvD,KACnDuD,IACAA,MACA1H,EAAA+D,OAAA2D,EAAAD,GAEA,QAAAE,GAAAxH,EAAAyH,EAAAC,GACA,MAAA/B,GAAAC,QAAA5F,GACAA,EAAAiD,QAAAwE,EAAAC,OACAtF,QAAAU,KAAA9C,GAAAiD,QAAA,SAAAe,GAA8C,MAAAyD,GAAAzH,EAAAgE,QAE9C,QAAA2D,GAAAhF,EAAAD,GAA2G,MAA3EN,QAAAU,KAAAJ,GAAAO,QAAA,SAAAe,GAA2C,MAAArB,GAAAqB,GAAAtB,EAAAsB,KAAgCrB,EAC3G,QAAAiF,GAAAC,EAAAC,GACA,MAAA/C,GAAAxB,UAAA,GAAAR,OAAAlD,EAAAkI,UAAAtB,OAAAkB,EAAAE,GAEA,QAAAG,GAAAC,EAAAC,GACA,GAAAD,IAAAC,EACA,QACA,WAAAD,GAAA,OAAAC,EACA,QACA,IAAAD,OAAAC,MACA,QACA,IAAAC,SAAAF,GAAAG,QAAAF,EACA,IAAAC,IAAAC,GAAA,WAAAD,EACA,QACA,IAAAE,IAAAJ,EAAAC,EACA,IAAAhD,EAAAoD,IAAA3C,EAAAC,SAAAyC,GACA,MAAAE,GAAAN,EAAAC,EACA,IAAAhD,EAAAoD,IAAA3C,EAAA6C,QAAAH,GACA,MAAAJ,GAAAQ,YAAAP,EAAAO,SACA,IAAAvD,EAAAoD,IAAA3C,EAAA+C,UAAAL,GACA,MAAAJ,GAAAU,aAAAT,EAAAS,UACA,IAAAzD,EAAAoD,IAAA3C,EAAAW,YAAA+B,GACA,QACA,IAAAO,IAAAjD,EAAAW,WAAAX,EAAAC,QAAAD,EAAA6C,OAAA7C,EAAA+C,SACA,IAAAE,EAAArD,IAAAL,EAAA2D,KAAApC,OAAA,SAAAhC,EAAAqE,GAA4D,MAAArE,MAAAqE,EAAAT,KAAyB,GACrF,QACA,IAAArE,GAAAlB,IACA,KAAAkB,IAAAiE,GAAA,CACA,IAAAD,EAAAC,EAAAjE,GAAAkE,EAAAlE,IACA,QACAlB,GAAAkB,IAAA,EAEA,IAAAA,IAAAkE,GACA,IAAApF,EAAAkB,GACA,QAEA,UAEA,QAAAuE,GAAAQ,EAAAC,GACA,MAAAD,GAAAvF,SAAAwF,EAAAxF,QAEA+C,EAAAwC,EAAAC,GAAAvC,OAAA,SAAAhC,EAAAwE,GAAwD,MAAAxE,IAAAuD,EAAAiB,EAAA,GAAAA,EAAA,MAAmC,GA7d3F,GAAAtD,GAAA7F,EAAA,GACAoF,EAAApF,EAAA,GACAoJ,EAAA,mBAAAC,WAA2CA,OAC3CC,EAAAF,EAAAE,WACAvJ,GAAAwJ,SAAAD,EAAAC,UAAAC,KAAAC,MAAArG,KAAAoG,MACAzJ,EAAA2J,OAAAJ,EAAAI,QAAAF,KAAAG,UAAAvG,KAAAoG,MACAzJ,EAAA6J,KAAAN,EAAAM,MAAArC,EACAxH,EAAAoD,QAAAmG,EAAAnG,SAAAuE,EACA3H,EAAA+D,OAAAwF,EAAAxF,QAAAgE,EACA/H,EAAA8J,OAAAP,EAAAO,QAAA3B,EACAnI,EAAAkI,SAAA,SAAAhC,GAAkC,MAAAA,IAClClG,EAAA+J,KAAA,aACA/J,EAAAgK,YAAA,WA6DAhK,EAAA4C,gBAKA5C,EAAAiK,QAAA,SAAAC,EAAAC,GACA,MAAAnK,GAAA+D,OAAA,IAAA/D,EAAA+D,OAAA,cAAiEqG,UAAAF,KAAoBC,GAyBrF,IAAAjF,GAAA,SAAAmF,EAAApD,GAEA,MADA,UAAAA,IAA0BA,EAAA,GAC1BF,MAAAqD,UAAAtG,OAAAD,MAAAkD,MAAAqD,UAAArD,MAAAqD,UAAAE,MAAArI,KAAAoI,EAAApD,KAGA9B,EAAA,SAAAoF,EAAApK,GAAsC,MAAAoK,GAAAC,QAAArK,QAEtCH,GAAAyK,WAAApF,EAAAqF,MAAA,SAAAH,EAAApK,GACA,GAAA8G,GAAAsD,EAAAC,QAAArK,EAGA,OAFA8G,IAAA,GACAsD,EAAAI,OAAA1D,EAAA,GACAsD,IAgBAvK,EAAAsD,WAkBAtD,EAAA4D,QAEA5D,EAAA4K,OAAA,SAAAzD,EAAAhB,GAAyC,MAAAnG,GAAA+D,OAAAoD,EAAAhB,IAiBzCnG,EAAAoE,YAmBApE,EAAA0E,eAWA1E,EAAAgE,OAGAhE,EAAAoF,OAOApF,EAAAuF,QAWAvF,EAAAkD,SAYAlD,EAAAoG,OAEApG,EAAA6K,OAAAnF,EAOA1F,EAAA0F,MAWA1F,EAAA8K,OAAA,SAAA3K,GAAkC,MAAAoC,QAAAU,KAAA9C,GAAAuF,IAAA,SAAAvB,GAA6C,MAAAhE,GAAAgE,MAc/EnE,EAAA+K,SAAA,SAAA5D,EAAA6D,GAA2C,MAAA7D,IAAA6D,GAc3ChL,EAAAiL,SAAA,SAAA9D,EAAA6D,GAA2C,MAAA7D,IAAA6D,GAU3ChL,EAAAkL,QAAA,SAAA/D,EAAA6D,GAA0C,MAAA7D,GAAArD,OAAAkH,IAW1ChL,EAAAmL,SAAA,SAAAhE,EAAA6D,GAA2C,MAAAlF,GAAAC,QAAAiF,GAAA7D,EAAArD,OAAAkH,EAAApE,OAAA5G,EAAAmL,cAAA9E,EAAAc,EAAA6D,IAa3ChL,EAAAoL,OAAA,SAAAvF,GAAkC,MAAAA,GAAAe,OAAA5G,EAAAkL,aAWlClL,EAAAqL,QAAA,SAAAxF,GAAmC,MAAAA,GAAAe,OAAA5G,EAAAmL,cAuBnCnL,EAAAsG,kBAUAtG,EAAAsL,MAAA,SAAAC,GAAoC,MAAAhJ,QAAAU,KAAAsI,GAAA7F,IAAA,SAAAvB,GAAgD,OAAAA,EAAAoH,EAAApH,OAyBpFnE,EAAA0G,cA8BA1G,EAAAkH,aAKAlH,EAAAsH,QAwEA,SAAAvH,EAAAC,EAAAC,GAEA,YAqBA,SAAAuL,GAAAC,GACA,GAAAzL,EAAA+F,QAAA0F,MAAA9H,OAAA,CACA,GAAA+H,GAAAD,EAAAnB,MAAA,MAAAhD,EAAAmE,EAAAnB,SACA,SAAAoB,EAAAxI,OAAAmC,EAAAC,IAAAtF,EAAAqH,WAAA1D,QAAA2D,EAAApE,OAAAmC,EAAAC,IAAAtF,EAAAyG,aAAA9C,QAEA,MAAA3D,GAAAyG,WAAAgF,GAxBA,GAAApG,GAAApF,EAAA,GACA0L,EAAApJ,OAAA6H,UAAAtB,SACA8C,EAAA,SAAAxC,GAAyB,gBAAAlD,GAAsB,kBAAAkD,GAC/CpJ,GAAA6L,YAAAD,EAAA,aACA5L,EAAA8L,UAAAzG,EAAAC,IAAAtF,EAAA6L,aACA7L,EAAA+L,OAAA,SAAAC,GAAgC,cAAAA,GAChChM,EAAAyG,WAAAmF,EAAA,YACA5L,EAAAiM,SAAAL,EAAA,UACA5L,EAAAqH,SAAAuE,EAAA,UACA5L,EAAAkM,SAAA,SAAAhG,GAAkC,cAAAA,GAAA,gBAAAA,IAClClG,EAAA+F,QAAAgB,MAAAhB,QACA/F,EAAA2I,OAAA,SAAAzC,GAAgC,wBAAAyF,EAAA1J,KAAAiE,IAChClG,EAAA6I,SAAA,SAAA3C,GAAkC,0BAAAyF,EAAA1J,KAAAiE,IAclClG,EAAAwL,eAMAxL,EAAAmM,UAAA9G,EAAA+G,IAAApM,EAAAkM,SAAA7G,EAAAgH,KAAAhH,EAAAM,KAAA,QAAA3F,EAAAyG,cAKA,SAAA1G,EAAAC,GAOA,YA4CA,SAAA0K,GAAAzB,GAGA,QAAAqD,GAAAjC,GACA,MAAAA,GAAA1G,QAAA4I,EACAtD,EAAApF,MAAA,KAAAwG,GACA,WACA,MAAAiC,GAAAjC,EAAAvG,UAAAwG,MAAAzG,MAAAH,cANA,GAAA8I,MAAAlC,MAAAzG,MAAAH,WAAA,IACA6I,EAAAtD,EAAAtF,MAQA,OAAA2I,GAAAE,GASA,QAAAC,KACA,GAAApC,GAAA3G,UACAgJ,EAAArC,EAAA1G,OAAA,CACA,mBAEA,IADA,GAAAkB,GAAA6H,EAAA1G,EAAAqE,EAAAqC,GAAA7I,MAAAlC,KAAA+B,WACAmB,KACAmB,EAAAqE,EAAAxF,GAAA5C,KAAAN,KAAAqE,EACA,OAAAA,IAUA,QAAAqG,KAEA,OADAM,MACAlJ,EAAA,EAAqBA,EAAAC,UAAAC,OAAuBF,IAC5CkJ,EAAAlJ,EAAA,GAAAC,UAAAD,EAEA,OAAAgJ,GAAA5I,MAAA,QAAAyG,MAAArI,KAAAyB,WAAAkJ,WA0CA,QAAAR,GAAAS,EAAAC,GACA,kBAEA,OADAzC,MACA5G,EAAA,EAAyBA,EAAAC,UAAAC,OAAuBF,IAChD4G,EAAA5G,EAAA,GAAAC,UAAAD,EAEA,OAAAoJ,GAAAhJ,MAAA,KAAAwG,IAAAyC,EAAAjJ,MAAA,KAAAwG,IAQA,QAAA0C,GAAAF,EAAAC,GACA,kBAEA,OADAzC,MACA5G,EAAA,EAAyBA,EAAAC,UAAAC,OAAuBF,IAChD4G,EAAA5G,EAAA,GAAAC,UAAAD,EAEA,OAAAoJ,GAAAhJ,MAAA,KAAAwG,IAAAyC,EAAAjJ,MAAA,KAAAwG,IAmBA,QAAA2C,GAAAC,EAAA5C,GACA,gBAAAlK,GAA4B,MAAAA,GAAA8M,GAAApJ,MAAA1D,EAAAkK,IA2C5B,QAAA6C,GAAAC,GACA,gBAAAjH,GACA,OAAArB,GAAA,EAAwBA,EAAAsI,EAAAxJ,OAAmBkB,IAC3C,GAAAsI,EAAAtI,GAAA,GAAAqB,GACA,MAAAiH,GAAAtI,GAAA,GAAAqB,IA9JAlG,EAAA0K,QAiBA1K,EAAAyM,UAcAzM,EAAAqM,OAOArM,EAAA2F,KAAA,SAAAxC,GAAiC,gBAAAhD,GAAwB,MAAAA,MAAAgD,KAQzDnD,EAAAoN,OAAA1C,EAAA,SAAAvH,EAAAsI,EAAAtL,GAAmD,MAAAA,MAAAgD,KAAAsI,IASnDzL,EAAA0J,MAAA,SAAAvG,GAAkC,MAAAkJ,GAAAxI,MAAA,KAAAV,EAAAkK,MAAA,KAAA3H,IAAA1F,EAAA2F,QAKlC3F,EAAAsF,IAAA,SAAA2D,GAA8B,kBAE9B,OADAoB,MACA5G,EAAA,EAAqBA,EAAAC,UAAAC,OAAuBF,IAC5C4G,EAAA5G,EAAA,GAAAC,UAAAD,EAEA,QAAAwF,EAAApF,MAAA,KAAAwG,KAeArK,EAAAoM,MAcApM,EAAA+M,KAOA/M,EAAAyI,IAAA,SAAAoE,GAA+B,gBAAAhH,GAAwB,MAAAA,GAAAe,OAAA,SAAAhC,EAAAsB,GAAoC,MAAAtB,MAAAiI,EAAA3G,KAAwB,KACnHlG,EAAAgJ,IAAA,SAAA6D,GAA+B,gBAAAhH,GAAwB,MAAAA,GAAAe,OAAA,SAAAhC,EAAAsB,GAAoC,MAAAtB,MAAAiI,EAAA3G,KAAwB,KACnHlG,EAAAsN,KAAAtN,EAAAsF,IAAAtF,EAAAgJ,KAEAhJ,EAAAuN,GAAA,SAAAC,GAA+B,gBAAArN,GAAwB,aAAAA,KAAAsN,cAAAD,GAAArN,YAAAqN,KAEvDxN,EAAA0N,GAAA,SAAAjC,GAA8B,gBAAAkC,GAA0B,MAAAlC,KAAAkC,IAExD3N,EAAAyL,IAAA,SAAAmC,GAA6B,kBAAqB,MAAAA,KAIlD5N,EAAAgN,SAiDAhN,EAAAkN,WAKA,SAAAnN,EAAAC,GAQA,YAIA,IAAA6N,GAAA,SAAAC,GAAyC,kBACzC,SAAAtH,OAAAsH,EAAA,4GAEAC,GACAC,GAAAzG,OACA0G,UAAA1G,OACA2G,YACAC,kBACAC,YAEApO,GAAA+N,YACA,mDACA3K,QAAA,SAAAe,GAA8B,MAAA4J,GAAAG,SAAA/J,GAAA0J,EAAA1J,MAC9B,8DACAf,QAAA,SAAAe,GAA8B,MAAA4J,GAAAI,eAAAhK,GAAA0J,EAAA1J,MAK9B,SAAApE,EAAAC,GAEA,YAEA,IAAAqO,GAAA,WACA,QAAAA,GAAAC,GACA3M,KAAA2M,OACA3M,KAAA4M,KAAAD,EAAAjB,MAAA,KA+BA,MA7BAgB,GAAAjE,UAAAoE,QAAA,SAAArL,GAGA,OAFAsL,GAAAtL,EAAAkK,MAAA,KAEAxI,EAAA,EAAA6J,EAAA/M,KAAA4M,KAAA5K,OAA8CkB,EAAA6J,EAAO7J,IACrD,MAAAlD,KAAA4M,KAAA1J,KACA4J,EAAA5J,GAAA,IAYA,OATA,OAAAlD,KAAA4M,KAAA,KACAE,IAAAnE,MAAAmE,EAAAjE,QAAA7I,KAAA4M,KAAA,KACAE,EAAAE,QAAA,OAGA,OAAAhN,KAAA4M,KAAA5M,KAAA4M,KAAA5K,OAAA,KACA8K,EAAA9D,OAAA8D,EAAAjE,QAAA7I,KAAA4M,KAAA5M,KAAA4M,KAAA5K,OAAA,MAAAiL,OAAAC,WACAJ,EAAAhK,KAAA,OAEA9C,KAAA4M,KAAA5K,QAAA8K,EAAA9K,QAEA8K,EAAAK,KAAA,MAAAnN,KAAA4M,KAAAO,KAAA,KAEAT,EAAAd,GAAA,SAAAe,GACA,MAAAA,GAAA9D,QAAA,SAEA6D,EAAAU,WAAA,SAAAT,GACA,MAAA3M,MAAA4L,GAAAe,GAEA,GAAAD,GAAAC,GADA,MAGAD,IAEArO,GAAAqO,QAKA,SAAAtO,EAAAC,GAGA,YACA,IAAAgP,GAAA,WACA,QAAAA,GAAAC,EAAAC,GACA,SAAAD,IAAiCA,MACjC,SAAAC,IAAiCA,EAAA,MACjCvN,KAAAsN,SACAtN,KAAAuN,SAgCA,MA9BAF,GAAA5E,UAAA+E,QAAA,SAAAhJ,GACA,GAAAiJ,GAAAzN,KAAAsN,MAIA,OAHAG,GAAA3K,KAAA0B,GACAxE,KAAAuN,QAAAE,EAAAzL,OAAAhC,KAAAuN,QACAE,EAAAC,QACAlJ,GAEA6I,EAAA5E,UAAAkF,QAAA,WACA,GAAA3N,KAAA4N,OACA,MAAA5N,MAAAsN,OAAAtE,OAAA,SAEAqE,EAAA5E,UAAAoF,MAAA,WACA,GAAAC,GAAA9N,KAAAsN,MAEA,OADAtN,MAAAsN,UACAQ,GAEAT,EAAA5E,UAAAmF,KAAA,WACA,MAAA5N,MAAAsN,OAAAtL,QAEAqL,EAAA5E,UAAAsF,OAAA,SAAAvJ,GACA,GAAAc,GAAAtF,KAAAsN,OAAAzE,QAAArE,EACA,OAAAc,OAAAtF,KAAAsN,OAAAtE,OAAA1D,EAAA,OAEA+H,EAAA5E,UAAAuF,SAAA,WACA,MAAAhO,MAAAsN,OAAAtN,KAAAsN,OAAAtL,OAAA,IAEAqL,EAAA5E,UAAAwF,SAAA,WACA,GAAAjO,KAAA4N,OACA,MAAA5N,MAAAsN,OAAA,IAEAD,IAEAhP,GAAAgP,SAKA,SAAAjP,EAAAC,EAAAC,GAGA,YAgBA,SAAA4P,GAAAC,EAAAC,GACA,MAAAA,GAAApM,QAAAmM,EACAC,EACAA,EAAAC,OAAA,EAAAF,EAAA,SAYA,QAAAG,GAAAtM,EAAAoM,GACA,KAAAA,EAAApM,UACAoM,GAAA,GACA,OAAAA,GAGA,QAAAG,GAAAC,GACA,MAAAA,GACAC,QAAA,oBAAAC,GAA6C,MAAAA,GAAAC,gBAC7CF,QAAA,oBAAAC,GAA6C,UAAAA,EAAAC,gBAS7C,QAAAC,GAAAnO,GACA,iBAAAqH,KAAAG,UAAAxH,GAAA,IAEA,QAAAoO,GAAAvH,GACA,GAAAwH,GAAAC,EAAAzH,GACA0H,EAAAF,EAAAG,MAAA,6BACA,OAAAD,KAAA,GAAAF,EAGA,QAAAC,GAAAzH,GACA,GAAA4H,GAAA/K,EAAAC,QAAAkD,KAAAqB,UAAA,GAAArB,CACA,OAAA4H,MAAA/H,YAAA,YAeA,QAAAc,GAAAoC,GAEA,QAAA8E,GAAArF,GACA,GAAA3F,EAAAoG,SAAAT,GAAA,CACA,GAAAsF,EAAAvG,QAAAiB,QACA,sBACAsF,GAAAtM,KAAAgH,GAEA,MAAAuF,GAAAvF,GAPA,GAAAsF,KASA,OAAAtH,MAAAG,UAAAoC,EAAA,SAAA7H,EAAAsH,GAAmD,MAAAqF,GAAArF,KAAsB2E,QAAA,YApFzE,GAAAtK,GAAA7F,EAAA,GACAgR,EAAAhR,EAAA,IACAiR,EAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACAkR,EAAAlR,EAAA,IACAmR,EAAAnR,EAAA,GAeAD,GAAA6P,YAeA7P,EAAAiQ,YAMAjQ,EAAAkQ,cAeAlQ,EAAAwQ,mBAKAxQ,EAAA0Q,YACA,IAAAW,GAAAJ,EAAAK,UAAAD,6BACAL,EAAA3L,EAAA6H,UACA7H,EAAAC,IAAAQ,EAAAgG,WAAAzG,EAAAoG,IAAA,eACA3F,EAAAiG,OAAA1G,EAAAoG,IAAA,UACA3F,EAAAqG,UAAAoE,IACAc,EAAA,SAAAnL,GAAkD,MAAAA,GAAAqL,qBAAAzI,cAClDzD,EAAAkI,GAAA0D,EAAAK,WAAAjM,EAAA2H,OAAA,cACA3H,EAAAkI,GAAA4D,EAAAK,YAAAnM,EAAA2H,OAAA,cACA3H,EAAAkI,GAAA6D,EAAAK,YAAApM,EAAA2H,OAAA,cACAlH,EAAA0F,aAAAgF,IACAnL,EAAAoG,KAAA,GAAAyF,EAAAhJ,WAcAlI,GAAA4J,YAEA5J,EAAA0R,kBAAA,SAAAC,GAA8C,gBAAA5B,GAC9C,IAAAA,EACA,aACA,IAAA9I,GAAA8I,EAAAvF,QAAAmH,EACA,OAAA1K,SACA8I,EAAA,KACAA,EAAAC,OAAA,EAAA/I,GAAA8I,EAAAC,OAAA/I,EAAA,OAMA,SAAAlH,EAAAC,EAAAC,GAGA,YACA,IAAAiR,GAAAjR,EAAA,GACA2R,EAAA3R,EAAA,GACA4R,EAAA5R,EAAA,IACA,SAAA6R,GACAA,IAAA,2BACAA,IAAA,qBACAA,IAAA,qBACAA,IAAA,sBACE9R,EAAA8R,aAAA9R,EAAA8R,eACF,IAAAA,GAAA9R,EAAA8R,WACAR,EAAA,WACA,QAAAA,GAAAS,EAAAC,EAAAC,GACAtQ,KAAAoQ,OACApQ,KAAAqQ,UACArQ,KAAAsQ,SA2CA,MAzCAX,GAAAlH,UAAAtB,SAAA,WACA,GAAAoJ,GAAA,SAAAC,GAA0C,MAAAA,MAAArJ,WAAAvG,OAAA6H,UAAAtB,SAAAqJ,EAAArJ,WAAA+I,EAAAjI,UAAAuI,IAC1CJ,EAAApQ,KAAAoQ,KAAAC,EAAArQ,KAAAqQ,QAAAC,EAAAC,EAAAvQ,KAAAsQ,OACA,oCAAAF,EAAA,cAAAC,EAAA,aAAAC,EAAA,KAEAX,EAAAlH,UAAAgI,UAAA,WACA,MAAAlB,GAAAnN,OAAA6N,EAAA7D,SAAAC,GAAAqE,OAAA1Q,OAA0E4P,qBAAA5P,QAG1E2P,EAAAD,6BAAA,SAAAlR,GACA,MAAAA,IAAA,kBAAAA,GAAAmS,MAAAnS,EAAAoR,+BAAAD,IAGAA,EAAAiB,WAAA,SAAAN,EAAAO,GACA,GAAAR,GAAA,6EACAS,EAAA,GAAAnB,GAAAQ,EAAAY,WAAAV,EAAAC,EAIA,OAHAO,MAAAG,aACAF,EAAAE,YAAA,GAEAF,GAGAnB,EAAAqB,WAAA,SAAAV,GACA,MAAAX,GAAAiB,WAAAN,GAA8CU,YAAA,KAG9CrB,EAAAsB,QAAA,SAAAX,GACA,GAAAD,GAAA,yCACA,WAAAV,GAAAQ,EAAAe,QAAAb,EAAAC,IAGAX,EAAAtK,QAAA,SAAAiL,GACA,GAAAD,GAAA,6BACA,WAAAV,GAAAQ,EAAAgB,QAAAd,EAAAC,IAGAX,EAAAyB,QAAA,SAAAd,GAEA,GAAAD,GAAA,kCACA,WAAAV,GAAAQ,EAAAkB,QAAAhB,EAAAC,IAEAX,IAEAtR,GAAAsR,aAKA,SAAAvR,EAAAC,EAAAC,GAEA,YAEA,IAAAgT,GAAAhT,EAAA,IACA2R,EAAA3R,EAAA,GACAiR,EAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAoF,EAAApF,EAAA,GACAiT,EAAAjT,EAAA,IACAkT,EAAAlT,EAAA,IACAmT,EAAAnT,EAAA,IACAoT,EAAApT,EAAA,IACAqT,EAAArT,EAAA,IACAsT,EAAAtT,EAAA,IACAgR,EAAAhR,EAAA,IACAuT,EAAA,EACAC,EAAApO,EAAAM,KAAA,QAOA6L,EAAA,WAWA,QAAAA,GAAAkC,EAAAC,EAAAC,GACA,GAAA/L,GAAAlG,IAYA,IAXAA,KAAAiS,qBACAjS,KAAAkS,UAAAjC,EAAA7D,SAAAC,GAAA8F,QAOAnS,KAAAoS,QAAApS,KAAAkS,UAAAE,QACApS,KAAAqS,YAAA,WAAyC,MAAAnM,GAAAoM,cACzCtS,KAAAuS,SAAA,WAAsC,MAAArM,OAAAsM,SAAA1E,YACtCkE,EAAAS,QACA,SAAA5N,OAAAmN,EAAAU,QAGAnB,GAAAoB,aAAAC,MAAA,GAAArB,GAAAoB,aAAA3S,MAEAA,KAAAwS,SAAAjD,EAAAnN,QAA0C0L,QAAApK,EAAAoG,IAAA9J,OAA2BgS,EAAAnB,WACrE7Q,KAAA6S,IAAAhB,GACA,IAAAiB,GAAArB,EAAAsB,YAAAC,YAAAjB,EAAAC,EACAc,GAAArB,EAAAsB,YAAAE,iBAAAhB,EAAAiB,MAAAJ,GACA9S,KAAAsS,aAAAb,EAAAsB,YAAAV,YAAAN,EAAAe,EAAA9S,KAAAwS,SAAAW,aACA1B,EAAAsB,YAAAK,sBAAApT,KAAAsS,aAAAtS,MA4RA,MA1RA6P,GAAApH,UAAA4K,MAAA,WACA,MAAA9D,GAAA5J,KAAA3F,KAAAsS,aAAApR,MAAAoS,OAEAzD,EAAApH,UAAA8K,IAAA,WACA,MAAAhE,GAAA5J,KAAA3F,KAAAsS,aAAAnR,IAAAmS,OAOAzD,EAAApH,UAAAvH,KAAA,WACA,MAAAlB,MAAAqT,QAAAG,MAOA3D,EAAApH,UAAAtH,GAAA,WACA,MAAAnB,MAAAuT,MAAAC,MAKA3D,EAAApH,UAAAmD,GAAA,SAAA6H,GACA,MAAAA,aAAA5D,GAEA7P,KAAA4L,IAA6BzK,GAAAsS,EAAAF,MAAA/R,KAAAN,KAAAuS,EAAAJ,QAAA7R,SAE7BiS,EAAAtS,KAAAoQ,EAAAmC,WAAA1T,KAAAuT,MAAAE,EAAAtS,KACAsS,EAAAvS,OAAAqQ,EAAAmC,WAAA1T,KAAAqT,QAAAI,EAAAvS,QASA2O,EAAApH,UAAAkL,OAAA,SAAAC,GAEA,MADA,UAAAA,IAAmCA,EAAA,MACnC5T,KAAAsS,aAAAsB,GAAA7P,IAAAL,EAAAM,KAAA,gBAAAiB,OAAAsK,EAAAtG,YAQA4G,EAAApH,UAAAoL,SAAA,WACA,MAAAtE,GAAAxL,IAAAwL,EAAA5J,KAAA3F,KAAAsS,aAAAnR,IAAA2S,eAAAC,iBAAA,SAAAC,GAAkH,MAAAA,GAAAC,QAQlHpE,EAAApH,UAAAyL,YAAA,SAAAL,EAAAP,GACA,SAAAA,IAAgCA,EAAA,GAChC,IAAAa,GAAA,gBAAAb,OAAA9R,KACA4S,EAAApU,KAAAsS,aAAAnR,GACAkT,EAAA9E,EAAA9K,KAAA2P,EAAA,SAAAE,GAAiE,MAAAA,GAAAhB,MAAA9R,OAAA2S,GACjE5E,GAAA5J,KAAAyO,GAAAN,eAAAS,eAAA3C,EAAA9B,WAAA0E,gBAAAX,GAAAQ,EAAAf,QAOAzD,EAAApH,UAAAgM,SAAA,WACA,MAAAzU,MAAAwS,SAAAiC,UAAA,MAOA5E,EAAApH,UAAAoI,QAAA,WACA,MAAA7Q,MAAAwS,UAOA3C,EAAApH,UAAAiM,SAAA,WACA,MAAAnF,GAAAxL,IAAA/D,KAAAsS,aAAAoC,SAAAhR,EAAAM,KAAA,UAAAD,IAAA+N,IAOAjC,EAAApH,UAAAkM,QAAA,WACA,MAAApF,GAAAxL,IAAA/D,KAAAsS,aAAAqC,QAAAjR,EAAAM,KAAA,UAAAD,IAAA+N,GAAA7G,WAQA4E,EAAApH,UAAAmM,SAAA,WACA,MAAArF,GAAAxL,IAAA/D,KAAAsS,aAAAsC,SAAAlR,EAAAM,KAAA,UAAAD,IAAA+N,IAcAjC,EAAApH,UAAAoM,MAAA,SAAAjB,EAAAN,GACA,SAAAM,IAAmCA,EAAA,WACnC,IAAAhR,GAAA5C,KAAAsS,aAAAsB,EAEA,OADAhR,GAAA0Q,EAAA1Q,EAAArB,OAAAmC,EAAA+H,OAAA,QAAA6H,IAAA1Q,EACAA,EAAAmB,IAAAL,EAAAM,KAAA,UAAAzC,OAAAgO,EAAAhJ,UAAAtB,OAAAsK,EAAAhG,aAcAsG,EAAApH,UAAAqM,SAAA,SAAA9C,GACA,GAAA+C,GAAAxF,EAAAnN,UAA4CpC,KAAA6Q,UAAAmB,EAAAnB,WAA0C4D,SAAAzU,MACtFgS,GAAA,GAAAN,GAAAsD,YAAAhD,EAAAiD,aAAAjD,EAAAkD,SAAAlD,EAAA2B,SAAAoB,EACA,IAAAI,GAAA,GAAAtF,GAAA7P,KAAAsS,aAAApR,KAAA8Q,EAAAhS,KAAAiS,oBACAkB,EAAAnB,EAAAnB,UAAAsC,YAIAiC,EAAApV,KAAAqS,cAAAlR,GACAkU,EAAA7D,EAAA8D,KAAAC,SAAAJ,EAAA9C,cAAAlR,GAAAiU,GACA7T,OAAA,SAAA+S,GAAsC,OAAAnB,MAAAqC,SAAAlB,EAAAhB,MAAA9R,QACtCiU,EAAA,SAAAC,EAAAlT,GAAuD,sCAAAqG,QAAArG,QAEvD,OADA6S,GAAA5T,QAAA,SAAA6S,EAAAhP,GAAuD,MAAAiK,GAAAnN,OAAAkS,EAAAT,SAAAtE,EAAAhO,OAAA6T,EAAA9P,GAAAuO,SAAA4B,MACvDN,GAGAtF,EAAApH,UAAAkN,eAAA,WACA,GAAAC,GAAA5V,KAAAsS,aAAAnR,EAAAyU,EAAAzU,GAAAD,EAAA0U,EAAA1U,IACA,KAAAlB,KAAAwS,SAAAqD,QAAAtG,EAAA5J,KAAAxE,GAAAmS,QAAA/D,EAAA5J,KAAAzE,GAAAoS,MAAA,CAEA,GAAAwC,GAAA3U,EAAA4C,IAAA,SAAAuQ,GAAmD,MAAAA,GAAAyB,cACnDC,GAAA7U,EAAAD,GAAA6C,IAAA,SAAAnB,GAAkD,MAAAA,GAAAmB,IAAA,SAAAQ,GAA+B,MAAAA,GAAA0R,gBAA4BC,EAAAF,EAAA,GAAAG,EAAAH,EAAA,GAC7GI,EAAA7G,EAAAxK,YAAA+Q,EAAAI,EAAAC,EACA,OAAAC,GAAArS,IAAA,SAAA6R,GACA,GAAAS,GAAAT,EAAA,GAAAU,EAAAV,EAAA,GAAAW,EAAAX,EAAA,EACA,OAAAjE,GAAA6E,MAAAC,QAAAJ,EAAAC,EAAAC,KACUtR,OAAAsK,EAAAhG,cASVsG,EAAApH,UAAAiO,QAAA,WACA,GAAAC,GAAA3W,KAAA2V,gBACA,SAAAgB,KAAA5S,IAAA,SAAAQ,GAA6D,MAAAA,GAAAmS,UAAoBzR,OAAAsK,EAAAjG,UAAA,IASjFuG,EAAApH,UAAApD,QAAA,WACA,GAAAsR,GAAA3W,KAAA2V,gBACA,SAAAgB,GAAA,IAAAA,EAAA3U,QAKA6N,EAAApH,UAAAmO,YAAA,WACA,UAAArF,GAAAsF,YAAA7W,KAAAiS,mBAAAjS,MACA8W,WAAA9W,KACA8N,QAAA9N,KAAAwS,SAAA1E,WAUA+B,EAAApH,UAAAsO,IAAA,WACA,GAAA7Q,GAAAlG,KACA4W,EAAA5W,KAAA4W,cACAI,EAAAzF,EAAA0F,eAAAD,oBAGAE,EAAA,WAA4C,MAAAF,GAAAJ,EAAAO,wBAA+D,IAC3GC,EAAA,SAAAC,GAAiD,MAAAL,GAAAJ,EAAAU,mBAA4DD,YAAmB,GAEhIrX,MAAAoS,QAAAzB,KAAAuG,EAAAE,EACA,IAAAG,GAAAP,EAAAJ,EAAAY,mBACA,IAAAlI,EAAAK,UAAAD,6BAAA6H,GAAA,CACAA,WAAA,WAA2C,UAC3C,IAAAE,GAAAF,EAAA3H,oBAEA,OADA5P,MAAAkS,UAAAxB,OAAA+G,GACAzX,KAAAoS,QAEA,IAAApS,KAAAyS,QAAA,CACA,GAAAC,GAAA,GAAA7N,OAAA7E,KAAA0S,QAEA,OADA1S,MAAAkS,UAAAxB,OAAAgC,GACA1S,KAAAoS,QAEA,GAAApS,KAAAqF,UAGA,MAFAiM,GAAAoG,MAAAC,uBAAA3X,MACAA,KAAAkS,UAAAxB,OAAApB,EAAAK,UAAAtK,WACArF,KAAAoS,OAGA,IAAAsD,GAAA,WACAxP,EAAA0R,SAAA,EACA1R,EAAAgM,UAAAwD,QAAAxP,GACAoL,EAAAoG,MAAAG,aAAA3R,EAAAqN,MAAArN,IAEAwK,EAAA,SAAAgC,GAIA,MAHAxM,GAAA0R,SAAA,EACA1R,EAAAgM,UAAAxB,OAAAgC,GACApB,EAAAoG,MAAAI,WAAApF,EAAAxM,GACA+J,EAAA7D,SAAAC,GAAAqE,OAAAgC,GAEApB,GAAAoG,MAAAK,qBAAA/X,KACA,IAAAgY,GAAApB,EAAAqB,aAAAhT,OAAA,SAAAiT,EAAAC,GAA8E,MAAAD,GAAAvH,KAAAwH,EAAAC,WAAA1W,KAAAyW,KAAkDZ,EAEhI,OADAS,GAAArH,KAAA+E,EAAAhF,GACA1Q,KAAAoS,SAOAvC,EAAApH,UAAAgK,MAAA,WACA,OAAAzS,KAAA0S,SAOA7C,EAAApH,UAAAiK,MAAA,WACA,GAAAY,GAAAtT,KAAAuT,KACA,OAAAD,GAAAE,KAAAjE,EAAAlH,aACA,wCAAAiL,EAAA9R,KAAA,IACAmQ,EAAA6E,MAAA6B,UAAA/E,EAAAgF,aAAAtY,KAAA2T,UAAA,OACA,qCAAAL,EAAA9R,KAAA,KAOAqO,EAAApH,UAAAtB,SAAA,WACA,GAAAoR,GAAAvY,KAAAkB,OACAsX,EAAAxY,KAAAmB,KACAsX,EAAA,SAAA9E,GACA,cAAAA,EAAA,MAAA/N,SAAA+N,EAAA,KAAAA,EAAApE,EAAA9L,KAAAkQ,EAAA,MAGAvT,EAAAJ,KAAA6S,IAAA3R,EAAAiD,EAAAoG,SAAAgO,KAAA/W,KAAA+W,EAAAG,EAAAnJ,EAAAvH,OAAAyQ,EAAAzY,KAAAsS,aAAApR,KAAA6C,IAAAL,EAAAM,KAAA,gBAAAiB,OAAAsK,EAAAtG,aAAgP0P,EAAA3Y,KAAAyS,QAAA,UAAAtR,EAAAgD,EAAAoG,SAAAiO,KAAAhX,KAAAgX,EAAAI,EAAArJ,EAAAvH,OAAAyQ,EAAAzY,KAAA2T,UAChP,qBAAAvT,EAAA,MAAAc,EAAA,IAAAwX,EAAA,OAAAC,EAAA,IAAAxX,EAAA,IAAAyX,EAAA,MAEA/I,IAEAxR,GAAAwR,cAKA,SAAAzR,EAAAC,EAAAC,GAEA,YAoCA,SAAAua,GAAAC,GACA,MAAAA,GAEA,YAAAA,EAAA1Y,GAAA,2BAAA0Y,EAAAC,gBAAAvX,MAAA,6BAAAsX,EAAAE,IAAA,aAAAF,EAAAtX,KAAA,IAAAsX,EAAAC,gBAAA,KADA,oBAQA,QAAAE,GAAAC,GACA,MAAA/U,GAAAmG,SAAA4O,GAAAC,EAAAD,GAAAC,IAAAD,IAfA,GAAAxV,GAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACA4R,EAAA5R,EAAA,GAQA8a,EAAA,SAAAC,GACA,4BAAAA,EAAAC,SAAAC,SAAA/X,MAAA,wCAAA6X,EAAAC,SAAAE,YAAA,IAAAH,EAAAC,SAAAG,qBAAA,MAmBA,SAAAN,GACAA,IAAA,qBACAA,IAAA,2BACAA,IAAA,eACAA,IAAA,mBACAA,IAAA,mBACAA,IAAA,4BACE9a,EAAA8a,WAAA9a,EAAA8a,aACF,IAAAA,GAAA9a,EAAA8a,SAIAO,EAAA,WACA,QAAAA,KAEA1Z,KAAA2Z,YACA3Z,KAAA4Z,mBAAA,EA8KA,MA3KAF,GAAAjR,UAAAoR,KAAA,SAAAC,EAAAC,GACA,GAAA7T,GAAAlG,IACA+Z,GAAA/X,SACA+X,EAAAnZ,OAAAU,KAAA6X,GACA5X,OAAA,SAAA4B,GAAuC,MAAA6W,OAAAC,SAAA9W,EAAA,OACvCY,IAAA,SAAAvB,GAAsC,MAAA2W,GAAA3W,MAEtCuX,EAAAhW,IAAAkV,GAAAxX,QAAA,SAAAyY,GAAoE,MAAAhU,GAAAyT,SAAAO,GAAAJ,KAYpEJ,EAAAjR,UAAA0R,OAAA,WAEA,OADAJ,MACAjY,EAAA,EAAyBA,EAAAC,UAAAC,OAAuBF,IAChDiY,EAAAjY,EAAA,GAAAC,UAAAD,EAEA9B,MAAA6Z,MAAA,EAAAE,IAYAL,EAAAjR,UAAA2R,QAAA,WAEA,OADAL,MACAjY,EAAA,EAAyBA,EAAAC,UAAAC,OAAuBF,IAChDiY,EAAAjY,EAAA,GAAAC,UAAAD,EAEA9B,MAAA6Z,MAAA,EAAAE,IAWAL,EAAAjR,UAAAqR,QAAA,SAAAI,GACA,QAAAla,KAAA2Z,SAAAV,EAAAiB,KAGAR,EAAAjR,UAAAsP,qBAAA,SAAAjB,GACA,GAAA9W,KAAA8Z,QAAAX,EAAAkB,YAAA,CAEA,GAAAC,GAAAxD,EAAAjE,IAAA0H,EAAAva,KAAA4Z,mBAAAY,EAAAtK,EAAAjI,UAAA6O,EACA2D,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,iBAAAC,KAGAd,EAAAjR,UAAAkP,uBAAA,SAAAb,GACA,GAAA9W,KAAA8Z,QAAAX,EAAAkB,YAAA,CAEA,GAAAC,GAAAxD,EAAAjE,IAAA0H,EAAAva,KAAA4Z,mBAAAY,EAAAtK,EAAAjI,UAAA6O,EACA2D,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,iBAAAC,KAGAd,EAAAjR,UAAAkS,oBAAA,SAAAxC,EAAAtH,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAyB,MAAA,CAEA,GAAAN,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAAiB,EAAAnX,EAAAqE,MAAA,sBAAA8I,IAAA,WAAAiK,EAAApX,EAAAqE,MAAA,gCAAA8I,IAAAnN,EAAAqE,MAAA,qBAAA8I,IAAA,UAAArP,EAAA0O,EAAArB,iBAAAsJ,EAAA7Q,GACAmT,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,eAAAM,EAAA,aAAAC,EAAA,KAAA5K,EAAAhC,UAAA,IAAA1M,MAGAkY,EAAAjR,UAAAsS,gBAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAlb,KAAA8Z,QAAAX,EAAAyB,MAAA,CAEA,GAAAN,GAAA5W,EAAAqE,MAAA,kBAAAmT,GAAAX,EAAAva,KAAA4Z,mBAAAuB,EAAAjL,EAAAjI,UAAA+S,GAAAI,EAAAlL,EAAAjI,UAAAgT,EACAR,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,yBAAArK,EAAAhC,UAAA,IAAAiN,GAAA,wBAAAjL,EAAAhC,UAAA,IAAAkN,MAGA1B,EAAAjR,UAAA4S,iBAAA,SAAAzY,EAAAiO,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAmC,SAAA,CAEA,GAAAhB,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAA2B,EAAA3Y,KAAAuE,WAAAqU,EAAA3K,KAAA4K,aACAhB,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,uBAAAgB,EAAA,KAAAC,EAAA,OAGA9B,EAAAjR,UAAAiT,wBAAA,SAAAC,EAAAC,EAAA/K,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAmC,UAEAM,EAAA5Z,OAAA,CAEA,GAAAsY,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAAiC,EAAAjb,OAAAU,KAAAsa,GAAAzO,KAAA,MAAA2O,EAAAH,KAAAxU,WAAAqU,EAAA3K,KAAA4K,aACAhB,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,qBAAAuB,EAAA,kBAAAD,EAAA,MAAAL,EAAA,OAGA9B,EAAAjR,UAAAsT,uBAAA,SAAAC,EAAAnL,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAmC,SAAA,CAEA,GAAAhB,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAAqC,EAAAD,KAAA7U,UACAsT,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,gCAAA0B,KAGAvC,EAAAjR,UAAAyT,wBAAA,SAAAF,EAAAnL,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAmC,SAAA,CAEA,GAAAhB,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAAqC,EAAAD,KAAA7U,WAAA9C,EAAA6L,EAAAjI,UAAA+T,EAAA/H,KACAwG,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,gCAAA0B,EAAA,QAAA/L,EAAAhC,UAAA,IAAA7J,MAGAqV,EAAAjR,UAAA0T,uBAAA,SAAA7H,EAAAhN,EAAA8U,EAAAvL,GACA,GAAA7Q,KAAA8Z,QAAAX,EAAAkD,QAAA,CAEA,GAAA/B,GAAA5W,EAAAqE,MAAA,kBAAA8I,GAAA0J,EAAAva,KAAA4Z,mBAAAzF,EAAAG,KAAAhB,OAAAgB,EAAAhB,MAAAnM,WAAAmE,EAAA4E,EAAArB,iBAAAvH,EACAmT,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,oBAAA1J,EAAAyL,KAAA,cAAAnI,EAAA,IAAAjE,EAAAhC,UAAA,IAAA5C,MAGAoO,EAAAjR,UAAAqP,WAAA,SAAApF,EAAAoE,GACA,GAAA9W,KAAA8Z,QAAAX,EAAAkB,YAAA,CAEA,GAAAC,GAAAxD,EAAAjE,IAAA0H,EAAAva,KAAA4Z,mBAAAY,EAAAtK,EAAAjI,UAAA6O,EACA2D,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,iBAAAC,EAAA,aAAA9H,KAGAgH,EAAAjR,UAAAoP,aAAA,SAAA0E,EAAAzF,GACA,GAAA9W,KAAA8Z,QAAAX,EAAAkB,YAAA,CAEA,GAAAC,GAAAxD,EAAAjE,IAAA0H,EAAAva,KAAA4Z,mBAAAtG,EAAAiJ,EAAA/a,KAAAgZ,EAAAtK,EAAAjI,UAAA6O,EACA2D,SAAAC,IAAA,eAAAJ,EAAA,YAAAC,EAAA,iBAAAC,EAAA,kBAAAlH,KAGAoG,EAAAjR,UAAA+T,iBAAA,SAAA3B,EAAA/B,EAAAtQ,GACA,SAAAA,IAAgCA,EAAA,IAChCxI,KAAA8Z,QAAAX,EAAAsD,SAEAhC,QAAAC,IAAA,YAAAxK,EAAA5B,UAAA,GAAAuM,GAAA,IAAAhC,EAAAC,GAAAtQ,IAGAkR,EAAAjR,UAAAiU,yBAAA,SAAA5D,EAAAgC,GACA9a,KAAA8Z,QAAAX,EAAAsD,SAEAzc,KAAAwc,iBAAA,WAAA1D,EAAA,kCAAAgC,EAAA,MAGApB,EAAAjR,UAAAkU,wBAAA,SAAA7D,EAAA8D,GACA5c,KAAA8Z,QAAAX,EAAAsD,SAEAzc,KAAAwc,iBAAA,oBAAA1D,EAAA,YAAA8D,EAAA/J,MAGA6G,EAAAjR,UAAAoU,gBAAA,SAAA/D,EAAAgE,GACA9c,KAAA8Z,QAAAX,EAAAsD,SAEAzc,KAAAwc,iBAAA,OAAA1D,EAAA,UAAA5I,EAAAhC,UAAA,IAAA4O,KAGApD,EAAAjR,UAAAsU,sBAAA,SAAAlC,EAAAxB,GACArZ,KAAA8Z,QAAAX,EAAA6D,aAEAvC,QAAAC,IAAA,eAAAG,EAAA,IAAAzB,EAAAC,KAGAK,EAAAjR,UAAAwU,4BAAA,SAAApC,EAAA/B,GACA9Y,KAAA8Z,QAAAX,EAAA6D,aAEAvC,QAAAC,IAAA,eAAAG,EAAA,IAAAhC,EAAAC,KAEAY,IAEArb,GAAAqb,OAWA,IAAAhC,GAAA,GAAAgC,EACArb,GAAAqZ,SAKA,SAAAtZ,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAWAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAGA,YAoHA,SAAA4e,GAAAC,GAEA,MADA,UAAAA,IAAuCA,GAAA,GACvC,SAAApQ,EAAAqQ,GACA,GAAAC,GAAAF,KAAA,EACAG,GAAAvQ,EAAAuH,KAAAhB,MAAA1Q,KAAAZ,OAAAob,EAAA9I,KAAAhB,MAAA1Q,KAAAZ,QAAAqb,CACA,YAAAC,IAAAF,EAAAG,KAAAC,SAAAzQ,EAAAwQ,KAAAC,UAxHA,GAAAjO,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,IAeAuY,EAAA,WACA,QAAAA,GAAA4G,EAAA3G,EAAA4G,GACA,GAAAxX,GAAAlG,IACAA,MAAAyd,eACAzd,KAAA8W,aACA9W,KAAA0d,kBAIA1d,KAAAwX,iBAAA,WAA8C,MAAAtR,GAAAyX,gBAAA,gBAAAT,IAAAtX,QAAyEgY,OAAA,KACvH5d,KAAA6d,gBAAA,WAA6C,MAAA3X,GAAAyX,gBAAA,eAAAT,MAC7Cld,KAAA8d,eAAA,WAA4C,MAAA5X,GAAAyX,gBAAA,mBAAAT,GAAA,YAAA5I,GAAqF,OAAUyJ,QAAAzJ,EAAAhB,UAC3ItT,KAAAge,iBAAA,WAA8C,MAAA9X,GAAAyX,gBAAA,sBAAAT,IAAA,SAAA5I,GAAoF,OAAUyJ,QAAAzJ,EAAAhB,UAC5ItT,KAAAie,gBAAA,WAA6C,MAAA/X,GAAAyX,gBAAA,qBAAAT,IAAA,SAAA5I,GAAmF,OAAUyJ,QAAAzJ,EAAAhB,UAC1ItT,KAAAke,iBAAA,WAA8C,MAAAhY,GAAAyX,gBAAA,gBAAAT,IAAA,SAAA5I,GAA8E,OAAU6J,cAAAjY,EAAAmM,gBACtIrS,KAAAmX,kBAAA,WAA+C,MAAAjR,GAAAyX,gBAAA,iBAAAT,IAAAtX,QAA0EgY,OAAA,EAAAQ,oBAAA,KACzHpe,KAAAsX,gBAAA,WAA6C,MAAApR,GAAAyX,gBAAA,eAAAT,IAAAtX,QAAwEgY,OAAA,EAAAQ,oBAAA,KACrHpe,KAAAqS,YAAAyE,EAAAzE,cACArS,KAAAqe,QAAA9O,EAAA5J,KAAA3F,KAAAqS,YAAAlR,IAAAmS,MACAtT,KAAAse,UAAA/O,EAAA5J,KAAA3F,KAAAqS,YAAAnR,MAAAoS,MACAtT,KAAAkb,kBAAApE,EAAAjG,UAkEA,MAhEAgG,GAAApO,UAAAwP,WAAA,WACA,GAAAsG,GAAAve,KAAA6d,kBACAW,EAAAxe,KAAA8d,iBACAW,EAAAze,KAAAge,mBACAU,EAAA1e,KAAAie,kBACAU,EAAA3e,KAAAke,mBACAjG,GAAAsG,EAAAC,EAAAC,EAAAC,EAAAC,EACA,OAAA1G,GAAAhT,OAAAsK,EAAAhG,YAAAhI,OAAAgO,EAAAhJ,WAeAsQ,EAAApO,UAAAkV,gBAAA,SAAAiB,EAAAC,EAAAC,EAAAC,EAAAlO,GACA,GAAA3K,GAAAlG,IACA,UAAA+e,IAAoCA,EAAA,SAAAzK,GAA8B,UAElE,IAAA0K,GAAAhf,KAAAif,eAAAL,EAAA5e,KAAAqS,YACA,KAAA2M,EACA,QACA,IAAAE,GAAA,SAAA3B,GAEA,GAAA1Q,GAAA0Q,EAAA1Q,QAAA3G,EAAAmM,aAEA8M,EAAAtS,EAAAgS,EAEA,OAAAM,GAAApb,IAAA,SAAAuQ,GACA,GAAA9B,GAAAjD,EAAAnN,QAAiDV,KAAA6b,EAAA7b,KAAA0d,WAA8BR,WAAA9D,QAAAxG,IAAsCpO,EAAAwX,gBAAA7M,GACrHwO,EAAA,GAAA9N,GAAA0F,eAAAsG,EAAAtZ,SAAA8a,EAAAzK,KAAAR,eAAAtB,EACA,QAAyB+K,OAAAjJ,OAAA+K,oBAGzB,OAAAL,GAAAjb,IAAAmb,GACAja,OAAAsK,EAAAhG,YACA+V,KAAAR,GACA/a,IAAA,SAAAwb,GAAoC,MAAAA,GAAAF,kBAapCxI,EAAApO,UAAAwW,eAAA,SAAAO,EAAAnN,GACA,OAAArS,KAAA8W,WAAA9W,KAAAyd,cACA1Z,IAAA,SAAA0b,GAAkC,MAAAA,GAAAC,SAAAF,KAClCje,OAAAgO,EAAA5K,gBAAAR,EAAAC,QAAA,uBAAAob,IACAva,OAAAsK,EAAAhG,YACAhI,OAAA,SAAAgc,GAAsC,MAAAA,GAAA1Q,QAAAwF,MAEtCwE,IAEAxY,GAAAwY,eAsBA,SAAAzY,EAAAC,EAAAC,GAEA,YAeA,SAAAoV,GAAAJ,EAAAqM,GAEA,QAAAC,GAAAC,GAEA,OADAC,GAAAC,EACA7c,EAAA,EAAwBA,EAAA4c,EAAA9d,OAAwBkB,IAAA,CAChD,GAAA0J,GAAAoT,EAAAtT,KAAAU,WAAA0S,EAAA5c,GACA,IAAA0J,KAAAC,QAAAgT,EAAAre,QAAAoL,GAAAkT,EAAA5c,KAAA2c,EAAAre,KACA,SAGA,SATA,GAAAue,GAAA5b,EAAAuB,SAAAia,SAWAM,EAAA9b,EAAAW,WAAAib,KAAAH,CACA,SAAAK,EAAA3M,GA0CA,QAAA4M,GAAAC,EAAA3e,GACA,gBAAA4e,EAAAnc,EAAA4M,GACA,SAAAA,IAAkCA,KAClC,IAAAwP,GAAA,GAAAC,GAAAF,EAAAnc,EAAA4M,EAEA,OADAsP,GAAA3e,GAAAsB,KAAAud,GACA,WACA9Q,EAAAzG,WAAAqX,EAAA3e,IAAA6e,KA1EA,GAAA9Q,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACA0hB,EAAA1hB,EAAA,EA0BAD,GAAAqV,YACA,IAAA4M,GAAA,WACA,QAAAA,GAAAC,EAAAtc,EAAA4M,GACA,SAAAA,IAAkCA,MAClC7Q,KAAAiE,WACAjE,KAAAugB,cAAAhR,EAAAnN,QAA+CjB,IAAA,EAAAD,MAAA,EAAAyT,SAAA,EAAAC,UAAA,EAAAF,UAAA,GAAsE6L,GACrHvgB,KAAAwd,SAAA3M,EAAA2M,UAAA,EACAxd,KAAA0B,KAAAmP,EAAAnP,MAAA,KA6BA,MA3BA4e,GAAAE,eAAA,SAAArB,EAAAQ,GACA,GAAAA,KAAA,EACA,MAAAR,EACA,IAAA5J,GAAA4J,EAAA5d,OAAA,SAAA+S,GAAsD,MAAAZ,GAAAY,EAAAhB,MAAAqM,IACtD,OAAApK,GAAAvT,OAAAuT,EAAA,MAQA+K,EAAA7X,UAAAoE,QAAA,SAAAwF,GACA,GAAAoO,GAAAzgB,KAAAugB,cAAAC,EAAAF,EAAAE,eACA3T,GACA1L,GAAAqf,GAAAjR,EAAA5J,KAAA0M,EAAAlR,KAAAsf,EAAAtf,IACAD,KAAAsf,GAAAjR,EAAA5J,KAAA0M,EAAAnR,OAAAuf,EAAAvf,MACAyT,QAAA6L,EAAAnO,EAAAsC,QAAA8L,EAAA9L,SACAC,SAAA4L,EAAAnO,EAAAuC,SAAA6L,EAAA7L,UACAF,SAAA8L,EAAAnO,EAAAqC,SAAA+L,EAAA/L,WAGAgM,GAAA,6CACA3c,IAAA,SAAAC,GAAmC,MAAA6I,GAAA7I,KACnCiB,OAAAsK,EAAAnG,UAAA,EACA,OAAAsX,GAAA7T,EAAA,MAEAyT,IAEAjiB,GAAAiiB,WAYA,IAAA3N,GAAA,WACA,QAAAA,KACA,GAAAzM,GAAAlG,IACAA,MAAA2gB,mBACAC,YAAAC,WAAAC,WAAAC,YAAAC,UAAAC,YAAAC,aAAAC,YAEAnhB,KAAA0f,SAAA,SAAAle,GAA0C,MAAA0E,GAAAya,kBAAAnf,IAC1CxB,KAAA4gB,SAAAV,EAAAlgB,KAAA2gB,kBAAA,YACA3gB,KAAA6gB,QAAAX,EAAAlgB,KAAA2gB,kBAAA,WAiBA3gB,KAAA8gB,QAAAZ,EAAAlgB,KAAA2gB,kBAAA,WAiBA3gB,KAAA+gB,SAAAb,EAAAlgB,KAAA2gB,kBAAA,YAiBA3gB,KAAAghB,OAAAd,EAAAlgB,KAAA2gB,kBAAA,UAeA3gB,KAAAihB,SAAAf,EAAAlgB,KAAA2gB,kBAAA,YAkBA3gB,KAAAkhB,UAAAhB,EAAAlgB,KAAA2gB,kBAAA,aAcA3gB,KAAAmhB,QAAAjB,EAAAlgB,KAAA2gB,kBAAA,WAKA,MAHAhO,GAAAC,MAAA,SAAAwO,EAAAC,GACAzgB,OAAAU,KAAA8f,EAAAT,mBAAAxe,QAAA,aAAAV,QAAA,SAAAe,GAA4F,MAAA6e,GAAA7e,GAAA4e,EAAA5e,MAE5FmQ,IAEAtU,GAAAsU,gBAKA,SAAAvU,EAAAC,EAAAC,GAEA,YACA,IAAAiR,GAAAjR,EAAA,GACA4R,EAAA5R,EAAA,GACA6F,EAAA7F,EAAA,GACAoF,EAAApF,EAAA,GACAgT,EAAAhT,EAAA,IACA2R,EAAA3R,EAAA,GACAgR,EAAAhR,EAAA,IACAiT,EAAAjT,EAAA,IACAgjB,GACA1D,OAAA,EACAQ,oBAAA,EACAtQ,QAAAyB,EAAAnH,KACA0O,WAAA,KACAsI,aACA1d,KAAA,MAEAuV,EAAA,WACA,QAAAA,GAAA3P,EAAAia,EAAAzN,EAAAjD,GACA,GAAA3K,GAAAlG,IACAA,MAAAsH,KACAtH,KAAAuhB,SACAvhB,KAAA8T,iBACA9T,KAAA6Q,UACA7Q,KAAAwhB,aAAA,WAA0C,MAAAtb,GAAA2K,QAAA/C,YAAA5H,EAAA2K,QAAAiG,YAC1C9W,KAAA6Q,QAAAtB,EAAA5N,SAAAkP,EAAAyQ,GA6EA,MA3EArK,GAAAxO,UAAA2P,WAAA,SAAAqJ,GACA,GAAAvb,GAAAlG,KACA4V,EAAA5V,KAAA6Q,EAAA+E,EAAA/E,QAAAvJ,EAAAsO,EAAAtO,GAAAwM,EAAA8B,EAAA9B,eACAyN,EAAAhS,EAAAnN,UAAwCpC,KAAAuhB,OAAAE,EAExC,IADAnQ,EAAAoG,MAAAiD,oBAAA3a,KAAA6Q,GACAA,EAAAuN,oBAAApe,KAAAwhB,eACA,MAAAlS,GAAAK,UAAAiB,WAAAC,EAAA/C,WAAA2C,WAGA,KAAAI,EAAA+M,MAAA,CACA,GAAA5C,GAAAlH,EAAA4N,UAAApa,EAAAia,EAAA1Q,EACA,OAAA7Q,MAAA2hB,iBAAA3G,GAEA,MAAAlH,GAAA8N,YAAAta,EAAAia,EAAA1Q,GAAAF,KAAA,SAAA7G,GAAqF,MAAA5D,GAAAyb,iBAAA7X,MAQrFmN,EAAAxO,UAAAkZ,iBAAA,SAAA3G,GACA,GAAA9U,GAAAlG,IACA,IAAAmE,EAAAgG,UAAA6Q,GAAA,CAKA,GAAA6G,GAAAne,EAAA6H,UAEAvL,KAAAwhB,aAAA,WAA8C,MAAAlS,GAAAK,UAAAiB,WAAA1K,EAAA2K,QAAA/C,WAAA2C,eAE9C/M,EAAAqI,IAAA,cAA4C,MAAAuD,GAAAK,UAAAyB,QAAA,2BAAAX,eAE5C/M,EAAAkI,GAAA2F,EAAAyD,aAAA,SAAAqM,GAAiE,MAAA/R,GAAAK,UAAAqB,WAAAqQ,GAAA5Q,eAEjEtM,EAAAqG,UAAA,SAAA4H,GAA0D,MAAAA,GAAAzB,KAAAzK,EAAAyb,iBAAAjgB,KAAAwE,QAE1D+U,EAAA4G,EAAA7G,EAGA,OAFAC,IACA3J,EAAAoG,MAAAqD,gBAAAC,EAAAC,EAAAjb,KAAA6Q,SACAoK,IAEAhE,EAAAxO,UAAAtB,SAAA,WACA,GAAAyO,GAAA5V,KAAA6Q,EAAA+E,EAAA/E,QAAAvJ,EAAAsO,EAAAtO,GACAuT,EAAAnX,EAAAqE,MAAA,sBAAA8I,IAAA,WAAAiK,EAAApX,EAAAqE,MAAA,gCAAA8I,IAAAnN,EAAAqE,MAAA,qBAAA8I,IAAA,UAAArP,EAAA0O,EAAAnB,WAAAzH,EACA,OAAAuT,GAAA,aAAAC,EAAA,KAAA5K,EAAAhC,UAAA,IAAA1M,IAOAyV,EAAAD,oBAAA,SAAAmJ,EAAAoB,EAAAO,GACA,SAAAP,IAAiCA,MACjC,SAAAO,IAA4CA,GAAA,EAE5C,QADAC,MACA7e,EAAA,EAAwBA,EAAAid,EAAAne,OAAkBkB,IAC1C,IACA6e,EAAAjf,KAAAqd,EAAAjd,GAAAkV,WAAAmJ,IAEA,MAAAS,GACA,IAAAF,EACA,MAAAxS,GAAAK,UAAAyB,QAAA4Q,GAAAvR,WAEAgK,SAAA/H,MAAA,wDAAAsP,GAGA,GAAAC,GAAAF,EAAAxgB,OAAA+N,EAAAK,UAAAD,6BACA,OAAAuS,GAAAjgB,OACAigB,EAAA,GACAF,EACAxgB,OAAA4C,EAAAqG,WACAvF,OAAA,SAAA+S,EAAA5F,GAAgD,MAAA4F,GAAArH,KAAAjN,EAAAoG,IAAAsI,KAAyCnC,EAAA7D,SAAAC,GAAAiQ,SAEzFrF,IAEA5Y,GAAA4Y,kBAKA,SAAA7Y,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YAEA,IAAA6F,GAAA7F,EAAA,GACAiR,EAAAjR,EAAA,GAsBA4jB,EAAA,WACA,QAAAA,GAAAC,GACAniB,KAAAmiB,gBACAniB,KAAAoiB,oBACA7S,EAAAtO,cAAAihB,EAAAzZ,UAAAzI,WAqQA,MAxKAkiB,GAAAzZ,UAAA4Z,UAAA,SAAA7gB,EAAA8gB,GACA,MAAAtiB,MAAAmiB,cAAAE,UAAA7gB,EAAA8gB,IAAAtiB,MAwIAkiB,EAAAzZ,UAAA6K,MAAA,SAAA9R,EAAA+gB,GAQA,MAPApe,GAAAoG,SAAA/I,GACA+gB,EAAA/gB,EAGA+gB,EAAA/gB,OAEAxB,KAAAmiB,cAAAK,SAAAD,GACAviB,MAoBAkiB,EAAAzZ,UAAAga,UAAA,SAAAxe,GACAjE,KAAAoiB,iBAAAtf,KAAAmB,IAEAie,IAEA7jB,GAAA6jB,iBAKA,SAAA9jB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAoF,EAAApF,EAAA,GACAiT,EAAAjT,EAAA,IACAokB,EAAA,SAAAC,GACA,IAAAxe,EAAAuB,SAAAid,GACA,QACA,IAAA7iB,GAAA,MAAA6iB,EAAAC,OAAA,EACA,QAAa9Y,IAAAhK,EAAA6iB,EAAAE,UAAA,GAAAF,EAAA7iB,SAcbgjB,EAAA,WACA,QAAAA,GAAAC,EAAAC,GACAhjB,KAAA+iB,SACA,IAAAvP,GAAAxT,KACAijB,EAAA,SAAA3P,GAAwC,WAAAA,EAAA9R,MACxC1B,EAAA,WAAiC,MAAAijB,GAAAte,KAAA,IACjCzE,MAAAkjB,UACA1P,MAAA,SAAAF,GAEA,MADAA,GAAAE,KAAA2P,QAAA,WAAuD,MAAA7P,IACvDA,EAAAE,OAEAjL,QAAA,SAAA+K,GACA,MAAA2P,GAAA3P,GACA,KACAyP,EAAAte,KAAA+O,EAAA4P,WAAA9P,KAAAxT,MAEAmU,MAAA,SAAAX,GAIA,MAHAA,GAAA/K,QAAA+K,EAAA/K,OAAA0L,OACAX,EAAAW,KAAAX,EAAAE,KAAAS,KAAA1E,EAAAjH,QAAAgL,EAAA/K,OAAA0L,KAAAX,EAAAW,OAEAX,EAAAW,OAGA0O,KAAA,SAAArP,GACA,GAAA+P,GAAA/P,EACAgQ,EAAAZ,EAAAW,EAAAV,KAAApa,EAAA+K,EAAA/K,OACAoa,EAAAW,EAAAN,EAAAO,QAAAD,EAAAxZ,KACA6J,OAAAL,EAAAK,WACA6P,SAAA,SAAAC,EAAAC,GAGA,MAFAL,GAAAM,kBAAA,GAAAD,IACAD,EAAAlU,EAAAnN,OAAAqhB,OAAmF/M,SAAA,KACnF+M,KALAJ,EAAAV,GAQA,KAAAA,EACA,WACA,KAAAK,EAAAY,UAAAjB,GACA,SAAA9d,OAAA,gBAAA8d,EAAA,eAAArP,EAAA,IACA,OAAAgQ,MAAAxjB,KAAA6iB,GAAApa,KAAAsb,WAAA/jB,KAAA6iB,IAAAmB,OAAAnB,KAGAkB,WAAA,SAAAvQ,GACA,OAAA2P,EAAA3P,MAAAqP,IAAArP,IAAA/K,OAAA+K,EAAA/K,OAAAsb,UAAA,OAEAlQ,QAAA,SAAAL,GACA,GAAAyQ,GAAA,SAAAlkB,EAAAO,GAAkE,MAAAmR,GAAAiF,MAAAwN,WAAA5jB,EAAA,KAAAP,IAClEokB,EAAA3Q,EAAAqP,KAAArP,EAAAqP,IAAArK,YAAyEhQ,SAAA,QACzE4b,EAAA3U,EAAApG,OAAAoG,EAAAxL,IAAAwL,EAAA9L,KAAA6P,EAAAK,WAAqGsQ,EAAAlgB,IAAAL,EAAAM,KAAA,QAAA+f,GACrG,OAAAE,GAAA9hB,OAAA+hB,GAAAngB,IAAA,SAAAtD,GAA6E,OAAAA,EAAAL,GAAAK,KAAoBwE,OAAAsK,EAAAhK,iBAIjGsP,SAEAjS,MAAA,SAAA0Q,GACA,MAAAA,GAAA/K,OAAA+K,EAAA/K,OAAA3F,KAAAT,OAAAmR,SAGAkC,UAAA,SAAAlC,GACA,GAAAkC,GAAAlC,EAAA/K,OAAAgH,EAAAnN,UAAqEkR,EAAA/K,OAAAiN,YAErE,OADAA,GAAAlC,EAAA9R,OAAA,EACAgU,KA6DA,MA/CAsN,GAAAra,UAAA0b,QAAA,SAAA3iB,EAAA8F,GACA,GAAA4b,GAAAljB,KAAAkjB,SACAta,EAAAsa,EAAA1hB,MAEA,OAAA2C,GAAAuB,SAAAlE,KAAA2C,EAAAgG,UAAA7C,GACAsB,EAAA5G,OAAA,EAAA4G,IAAA,GACAzE,EAAAuB,SAAAlE,IAAA2C,EAAAW,WAAAwC,IAEA4b,EAAA1hB,GAAAoH,EACAsa,EAAA1hB,GAAAsB,KAAAwE,GACA,WAA6B,MAAA4b,GAAA1hB,GAAAwH,OAAAka,EAAA1hB,GAAAqH,QAAAvB,EAAA,YAJ7B,QAaAwb,EAAAra,UAAA2b,MAAA,SAAA9Q,GACA,GAAAsC,GAAA5V,KAAA+iB,EAAAnN,EAAAmN,QAAAG,EAAAtN,EAAAsN,SACA3a,EAAAvI,KAAAojB,WAAA9P,EACA,IAAA/K,IAAAwa,EAAAte,KAAA8D,GACA,WACA,QAAA/F,KAAA0gB,GACA,GAAAA,EAAAviB,eAAA6B,GAAA,CAEA,GAAAwV,GAAAkL,EAAA1gB,GAAAyC,OAAA,SAAAof,EAAAlM,GAAyE,gBAAA0H,GAA2B,MAAA1H,GAAA0H,EAAAwE,KAAoC9U,EAAAnH,KACxIkL,GAAA9Q,GAAAwV,EAAA1E,GAEA,MAAAA,IAEAwP,EAAAra,UAAA2a,WAAA,SAAA9P,GACA,GAAA9R,GAAA8R,EAAA9R,MAAA,EACA,OAAAA,GAAAqH,QAAA,UACArH,EAAAqhB,UAAA,EAAArhB,EAAA8iB,YAAA,MACAhR,EAAA/K,OAEApE,EAAAuB,SAAA4N,EAAA/K,QAAA+K,EAAA/K,OAAA+K,EAAA/K,OAAA/G,KADA,IAGAshB,EAAAra,UAAAjH,KAAA,SAAA8R,GACA,GAAA9R,GAAA8R,EAAA9R,IACA,IAAAA,EAAAqH,QAAA,YAAAyK,EAAA/K,OACA,MAAA/G,EACA,IAAA4hB,GAAAjf,EAAAuB,SAAA4N,EAAA/K,QAAA+K,EAAA/K,OAAA+K,EAAA/K,OAAA/G,IACA,OAAA4hB,KAAA,IAAA5hB,KAEAshB,IAEAzkB,GAAAykB,gBAKA,SAAA1kB,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAUAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YAiBA,SAAAimB,GAAAC,GAEA,MADAA,GAAAC,EAAAD,KAAgC1jB,MAAA0jB,IAAaA,EAC7CjV,EAAAnN,OAAAoiB,GACAE,KAAAvgB,EAAA0F,aAAA2a,EAAA1jB,OAAA0jB,EAAA1jB,MAAA,WAA+E,MAAA0jB,GAAA1jB,SAG/E,QAAA6jB,GAAAH,EAAAI,EAAArY,EAAAnM,GACA,GAAAokB,EAAApU,MAAAwU,GAAA,WAAAA,EAAApjB,KACA,SAAAqD,OAAA,UAAAzE,EAAA;AACA,MAAAokB,GAAApU,MAAAwU,GAAA,WAAAA,EAAApjB,MAAAqjB,EAAAC,WAAA1U,KAAAoU,EAAApU,MACAyU,EAAAC,WAAA1U,KAAAoU,EAAApU,MACAwU,EACAA,EACAJ,EAAApU,KAEAoU,EAAApU,eAAA2U,GAAAC,KAAAR,EAAApU,KAAAyU,EAAAC,WAAA1U,KAAAoU,EAAApU,MADA7D,IAAA0Y,EAAAC,OAAAL,EAAAC,WAAA1U,KAAA,OAAAyU,EAAAC,WAAA1U,KAAA,UAMA,QAAA+U,GAAAtlB,EAAAulB,GACA,GAAAC,GAAAxlB,EAAAwlB,MACA,KAAAD,GAAAC,KAAA,EACA,QACA,KAAAlhB,EAAAgG,UAAAkb,IAAA,MAAAA,EACA,MAAAC,GAAAC,cAAAC,qBACA,IAAAH,KAAA,GAAAlhB,EAAAuB,SAAA2f,GACA,MAAAA,EACA,UAAAxgB,OAAA,2BAAAwgB,EAAA,uDAEA,QAAAI,GAAA5lB,EAAA6lB,EAAAN,EAAAC,GACA,GAAA5W,GAAAkX,EAAAC,IACU1kB,KAAA,GAAAC,GAAAikB,GAAAM,EAAA9f,OAAA,KACA1E,KAAA,KAAAC,GAAAikB,GAAAM,EAAA9f,OAAA,IAMV,OAJA6I,GAAAtK,EAAAC,QAAAvE,EAAA4O,SAAA5O,EAAA4O,WACAtK,EAAAuB,SAAA2f,IACA5W,EAAA3L,MAAuB5B,KAAAmkB,EAAAlkB,GAAAyE,SACvB+f,EAAApW,EAAAxL,IAAA0K,EAAA/K,EAAAM,KAAA,SACAuL,EAAAhO,OAAAqkB,EAAA,SAAAphB,GAA4D,MAAAmhB,GAAA9c,QAAArE,EAAAtD,aAAmDiB,OAAAsM,GAtD/G,GAAAc,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACA2R,EAAA3R,EAAA,GACAgnB,EAAAhnB,EAAA,IACAymB,EAAAzmB,EAAA,IACAumB,EAAAvmB,EAAA,IACAunB,EAAAjlB,OAAA6H,UAAA9H,eACA8jB,EAAA,SAAAD,GAAmC,MAAoF,MAApF,2CAAAjjB,OAAAskB,EAAAnkB,KAAA8iB,QAAoFxiB,SACvH,SAAAijB,GACAA,IAAA,eACAA,IAAA,mBACAA,IAAA,oBACE5mB,EAAA4mB,UAAA5mB,EAAA4mB,YACF,IAAAA,GAAA5mB,EAAA4mB,QA0CAzO,EAAA,WACA,QAAAA,GAAApW,EAAAgQ,EAAAvQ,EAAA0M,GAUA,QAAAuZ,KACA,GAAAC,IAAkCnd,MAAA2D,IAAA0Y,EAAAe,QAAA,QAClCC,EAAA7lB,EAAA6O,MAAA,UAA+DrG,OAAA,KAC/D,OAAA2G,GAAAnN,OAAA2jB,EAAAE,EAAApmB,GAAA+I,MAZA/I,EAAA0kB,EAAA1kB,GACAuQ,EAAAuU,EAAA9kB,EAAAuQ,EAAA7D,EAAAnM,EACA,IAAAslB,GAAAI,GACA1V,GAAAsV,EAAAtV,EAAA8V,SAAAR,EAAAnZ,IAAA0Y,EAAAe,QAAA5V,CACA,IAAAgV,GAAAxf,SAAA/F,EAAAiB,MACA4V,EAAA7W,EAAA6W,WAAA,EACA2O,EAAAF,EAAAtlB,EAAAulB,GACA3W,EAAAgX,EAAA5lB,EAAA6lB,EAAAN,EAAAC,EAOA9V,GAAAnN,OAAApC,MAAgCI,KAAAgQ,OAAA7D,WAAA8Y,SAAA5W,UAAA2W,aAAA1O,UAAA7W,SAAA+I,MAAA8c,IAkGhC,MAhGAlP,GAAA/N,UAAA0d,eAAA,SAAArlB,GACA,MAAAd,MAAAolB,YAAAplB,KAAAoQ,KAAAjI,OAAAnI,KAAAc,YAMA0V,EAAA/N,UAAA3H,MAAA,SAAAA,GACA,GAAAoF,GAAAlG,KAIAomB,EAAA,WACA,IAAAnW,EAAA7D,SAAAE,UACA,SAAAzH,OAAA,8DACA,IAAAwhB,GAAApW,EAAA7D,SAAAE,UAAAjB,OAAAnF,EAAArG,OAAA6kB,KACA,WAAA2B,GAAAzgB,SAAAygB,IAAAngB,EAAAkK,KAAAxE,GAAAya,GACA,SAAAxhB,OAAA,kBAAAwhB,EAAA,oBAAAngB,EAAA9F,GAAA,iCAAA8F,EAAAkK,KAAA5O,KAAA,IACA,OAAA6kB,IAEAC,EAAA,SAAAxc,GACA,GAAAyc,GAAAhX,EAAAxL,IAAAwL,EAAAhO,OAAA2E,EAAAuI,QAAA/K,EAAA+H,OAAA,OAAA3B,IAAApG,EAAAM,KAAA,MACA,OAAAuiB,GAAAvkB,OAAAukB,EAAA,GAAAzc,EAGA,OADAhJ,GAAAwlB,EAAAxlB,GACAqD,EAAAgG,UAAArJ,GAAAd,KAAAoQ,KAAAoW,WAAA1lB,GAAAslB,KAEA5P,EAAA/N,UAAAib,SAAA,WACA,MAAA1jB,MAAAuM,WAAA0Y,EAAAe,QAEAxP,EAAA/N,UAAA4P,UAAA,SAAAvX,GAEA,KAAAqD,EAAAgG,UAAArJ,IAAA,OAAAA,IAAAd,KAAAolB,WACA,QAEA,IAAAqB,GAAAzmB,KAAAoQ,KAAAoW,WAAA1lB,EACA,KAAAd,KAAAoQ,KAAAxE,GAAA6a,GACA,QAEA,IAAAC,GAAA1mB,KAAAoQ,KAAAuW,OAAAF,EACA,SAAAtiB,EAAAuB,SAAAghB,KAAA1mB,KAAAoQ,KAAA7E,QAAAqb,KAAAF,KAEAlQ,EAAA/N,UAAAtB,SAAA,WACA,gBAAkBnH,KAAAI,GAAA,IAAAJ,KAAAoQ,KAAA,aAAApQ,KAAAqlB,OAAA,eAAArlB,KAAAolB,WAAA,KAGlB5O,EAAAwN,WAAA,SAAA5jB,EAAAgQ,EAAAvQ,GACA,UAAA2W,GAAApW,EAAAgQ,EAAAvQ,EAAAolB,EAAAC,SAGA1O,EAAAzE,SAAA,SAAA3R,EAAAgQ,EAAAvQ,GACA,UAAA2W,GAAApW,EAAAgQ,EAAAvQ,EAAAolB,EAAA4B,OAGArQ,EAAAsQ,WAAA,SAAA1mB,EAAAgQ,EAAAvQ,GACA,UAAA2W,GAAApW,EAAAgQ,EAAAvQ,EAAAolB,EAAAe,SAEAxP,EAAArN,OAAA,SAAAwK,EAAAxK,GAEA,MADA,UAAAA,IAAiCA,MACjCwK,EAAA5P,IAAA,SAAAgjB,GAA6C,OAAAA,EAAA3mB,GAAA2mB,EAAAjmB,MAAAqI,EAAA4d,EAAA3mB,QAAoD6E,OAAAsK,EAAAhK,gBAajGiR,EAAAC,QAAA,SAAA9C,EAAAqT,EAAAC,GAGA,MAFA,UAAAD,IAAkCA,MAClC,SAAAC,IAAkCA,MAClCtT,EAAApS,OAAA,SAAAwlB,GAAgD,OAAAA,EAAA3W,KAAAjI,OAAA6e,EAAAD,EAAA3mB,IAAA6mB,EAAAF,EAAA3mB,QAWhDoW,EAAArO,OAAA,SAAAwL,EAAAqT,EAAAC,GAGA,MAFA,UAAAD,IAAkCA,MAClC,SAAAC,IAAkCA,MAClC,IAAAzQ,EAAAC,QAAA9C,EAAAqT,EAAAC,GAAAjlB,QAGAwU,EAAA6B,UAAA,SAAA1E,EAAAxK,GAEA,MADA,UAAAA,IAAiCA,MACjCwK,EAAA5P,IAAA,SAAAgjB,GAA6C,MAAAA,GAAA1O,UAAAlP,EAAA4d,EAAA3mB,OAA4C6E,OAAAsK,EAAAnG,UAAA,IAEzFoN,IAEAnY,GAAAmY,SAKA,SAAApY,EAAAC,EAAAC,GAEA,YAEA,IAAA6F,GAAA7F,EAAA,GACA4oB,EAAA,WACA,QAAAA,KACAlnB,KAAAmnB,oBAAA,EACAnnB,KAAAonB,eAAA,EACApnB,KAAAqnB,sBAAA,EAaA,MAXAH,GAAAze,UAAA6e,gBAAA,SAAAxmB,GACA,MAAAd,MAAAmnB,mBAAAhjB,EAAAgG,UAAArJ,KAAAd,KAAAmnB,oBAEAD,EAAAze,UAAA8e,WAAA,SAAAzmB,GACA,MAAAd,MAAAonB,cAAAjjB,EAAAgG,UAAArJ,KAAAd,KAAAonB,eAEAF,EAAAze,UAAA+c,oBAAA,SAAA1kB,GACA,GAAAqD,EAAAgG,UAAArJ,SAAA,GAAAA,KAAA,IAAAqD,EAAAuB,SAAA5E,GACA,SAAA+D,OAAA,0BAAA/D,EAAA,kDACA,OAAAd,MAAAqnB,qBAAAljB,EAAAgG,UAAArJ,KAAAd,KAAAqnB,sBAEAH,IAEA7oB,GAAA6oB,gBAEA7oB,EAAAknB,cAAA,GAAA2B,IAKA,SAAA9oB,EAAAC,EAAAC,GAEA,YAOA,SAAAkpB,GAAApX,EAAAqX,GAGA,QAAAC,GAAA5d,GAA8B,MAAA3F,GAAAC,QAAA0F,KAAA3F,EAAAgG,UAAAL,UAE9B,QAAA6d,GAAA7d,GACA,OAAAA,EAAA9H,QACA,aACA,uBAAAylB,EAAA3d,EAAA,GAAAA,CACA,eAAAA,IAIA,QAAA8d,GAAA3jB,EAAA4jB,GACA,gBAAA/d,GACA,GAAA3F,EAAAC,QAAA0F,IAAA,IAAAA,EAAA9H,OACA,MAAA8H,EACA,IAAA5F,GAAAwjB,EAAA5d,GACAzF,EAAAkL,EAAAxL,IAAAG,EAAAD,EACA,OAAA4jB,MAAA,EAAkG,IAAlGtY,EAAAhO,OAAA8C,EAAA,SAAAE,GAAqF,OAAAA,IAAavC,OAAA2lB,EAAAtjB,IAIlG,QAAAyjB,GAAA7jB,GACA,gBAAA8jB,EAAAC,GACA,GAAAC,GAAAP,EAAAK,GAAAG,EAAAR,EAAAM,EACA,IAAAC,EAAAjmB,SAAAkmB,EAAAlmB,OACA,QACA,QAAAkB,GAAA,EAA4BA,EAAA+kB,EAAAjmB,OAAiBkB,IAC7C,IAAAe,EAAAgkB,EAAA/kB,GAAAglB,EAAAhlB,IACA,QAEA,WA/BA,GAAAgD,GAAAlG,MAkCA,yCAAA+D,IAAA,SAAAvC,GACA0E,EAAA1E,IAAA,WAAAA,EAAAsmB,EAAAF,GAAAxX,EAAA5O,GAAAE,KAAA0O,MAEAb,EAAAnN,OAAApC,MACAwB,KAAA4O,EAAA5O,KACA+J,QAAA6E,EAAA7E,QACAK,GAAAgc,EAAAxX,EAAAxE,GAAAlK,KAAA0O,IAAA,GACA+X,WAAAV,IA/CA,GAAAlY,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GAoEA0mB,EAAA,WAMA,QAAAA,GAAAoD,GACApoB,KAAAuL,QAAA,KACAgE,EAAAnN,OAAApC,KAAAooB,GAuCA,MAnCApD,GAAAvc,UAAAmD,GAAA,SAAA9B,EAAAtH,GAA8C,UAE9CwiB,EAAAvc,UAAAke,OAAA,SAAA7c,EAAAtH,GAAkD,MAAAsH,IAElDkb,EAAAvc,UAAA4f,OAAA,SAAAve,EAAAtH,GAAkD,MAAAsH,IAElDkb,EAAAvc,UAAAN,OAAA,SAAAnF,EAAAC,GAA8C,MAAAD,IAAAC,GAC9C+hB,EAAAvc,UAAA6f,YAAA,WACA,GAAAC,GAAAvoB,KAAAuL,QAAApE,UACA,OAAAohB,GAAAla,OAAA,EAAAka,EAAAvmB,OAAA,IAEAgjB,EAAAvc,UAAAtB,SAAA,WACA,eAAkBnH,KAAAwB,KAAA,KAGlBwjB,EAAAvc,UAAA+d,WAAA,SAAA1c,GACA,MAAA9J,MAAA4L,GAAA9B,KAAA9J,KAAAqoB,OAAAve,IAYAkb,EAAAvc,UAAAyd,SAAA,SAAAuB,EAAA/D,GACA,IAAA+D,EACA,MAAAznB,KACA,aAAAynB,IAAA/D,EACA,SAAA7e,OAAA,iDACA,WAAA2iB,GAAAxnB,KAAAynB,IAEAzC,IAEA3mB,GAAA2mB,QAKA,SAAA5mB,EAAAC,EAAAC,GAEA,YAWA,SAAAkqB,GAAA1e,GAA4B,aAAAA,IAAA3C,WAAAsH,QAAA,WAAAA,QAAA,aAAA3E,EAC5B,QAAA2e,GAAA3e,GAA8B,aAAAA,IAAA3C,WAAAsH,QAAA,YAAAA,QAAA,WAAA3E,EAV9B,GAAAyF,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAoF,EAAApF,EAAA,GACA2R,EAAA3R,EAAA,GACAymB,EAAAzmB,EAAA,IAOAoqB,EAAA,WACA,QAAAA,KACA1oB,KAAAwN,SAAA,EACAxN,KAAA2oB,aACA3oB,KAAA4oB,cACAC,MACAlC,OAAA6B,EACAH,OAAAI,EACA7c,GAAAlI,EAAAkI,GAAAkd,QACAvd,QAAA,KACApD,OAAA,SAAAnF,EAAAC,GAA0C,MAAAD,IAAAC,IAE1C8lB,QACApC,OAAA6B,EACAH,OAAAI,EACA7c,GAAAlI,EAAAkI,GAAAkd,QACAvd,QAAA,UAEAyd,OACArC,OAAA6B,EACAH,OAAA,SAAAve,GAAyC,MAAAmQ,UAAAnQ,EAAA,KACzC8B,GAAA,SAAA9B,GAAqC,MAAA3F,GAAAgG,UAAAL,IAAA9J,KAAAqoB,OAAAve,EAAA3C,cAAA2C,GACrCyB,QAAA,SAEA0d,MACAtC,OAAA,SAAA7c,GAAyC,MAAAA,IAAA,MACzCue,OAAA,SAAAve,GAAyC,WAAAmQ,SAAAnQ,EAAA,KACzC8B,GAAAlI,EAAAkI,GAAAsd,SACA3d,QAAA,OAEA4d,MACAxC,OAAA,SAAA7c,GACA,MAAA9J,MAAA4L,GAAA9B,IACAA,EAAAsf,eACA,KAAAtf,EAAAuf,WAAA,IAAA1gB,WACA,IAAAmB,EAAAwf,WAAA3gB,WACAwE,KAAA,KAJAvH,QAMAyiB,OAAA,SAAAve,GACA,GAAA9J,KAAA4L,GAAA9B,GACA,MAAAA,EACA,IAAAmF,GAAAjP,KAAAupB,QAAA3C,KAAA9c,EACA,OAAAmF,GAAA,GAAAua,MAAAva,EAAA,GAAAA,EAAA,KAAAA,EAAA,IAAArJ,QAEAgG,GAAA,SAAA9B,GAAqC,MAAAA,aAAA0f,QAAAxP,MAAAlQ,EAAA2f,YACrCthB,OAAA,SAAA4E,EAAAqQ,GACA,2CACAnY,OAAA,SAAAykB,EAAApiB,GAAqD,MAAAoiB,IAAA3c,EAAAzF,OAAA8V,EAAA9V,OAAqC,IAE1FiE,QAAA,0DACAge,QAAA,yDAEAI,MACAhD,OAAApX,EAAAvH,OACAqgB,OAAA9Y,EAAA1H,SACA+D,GAAAlI,EAAAkI,GAAAhL,QACAuH,OAAAoH,EAAApH,OACAoD,QAAA,UAEAlE,KACAsf,OAAApX,EAAAhJ,SACA8hB,OAAA9Y,EAAAhJ,SACA4B,OAAAoH,EAAApH,OACAoD,QAAA,MAIA,IAAAqe,GAAA,SAAArH,EAAA/gB,GAAqD,UAAAujB,GAAAC,KAAAzV,EAAAnN,QAAyCZ,QAAa+gB,IAC3GviB,MAAA6pB,MAAAta,EAAAjH,QAAAiH,EAAAxL,IAAA/D,KAAA4oB,aAAAgB,OAuBA,MArBAlB,GAAAjgB,UAAA2H,KAAA,SAAA5O,EAAA+gB,EAAAuH,GACA,IAAA3lB,EAAAgG,UAAAoY,GACA,MAAAviB,MAAA6pB,MAAAroB,EACA,IAAAxB,KAAA6pB,MAAAlpB,eAAAa,GACA,SAAAqD,OAAA,iBAAArD,EAAA,8BAOA,OANAxB,MAAA6pB,MAAAroB,GAAA,GAAAujB,GAAAC,KAAAzV,EAAAnN,QAA6DZ,QAAa+gB,IAC1EuH,IACA9pB,KAAA2oB,UAAA7lB,MAAkCtB,OAAA4mB,IAAA0B,IAClC9pB,KAAAwN,SACAxN,KAAA+pB,mBAEA/pB,MAEA0oB,EAAAjgB,UAAAshB,gBAAA,WACA,KAAA/pB,KAAA2oB,UAAA3mB,QAAA,CACA,GAAAoO,GAAApQ,KAAA2oB,UAAAjb,OACA,IAAA0C,EAAA7E,QACA,SAAA1G,OAAA,oDACA0K,GAAAnN,OAAApC,KAAA6pB,MAAAzZ,EAAA5O,MAAAyO,EAAA7D,SAAAE,UAAAjB,OAAA+E,EAAAgY,QAGAM,IAEArqB,GAAAqqB,aACArqB,EAAAymB,WAAA,GAAA4D,IAKA,SAAAtqB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACA0rB,EAAA,WACA,QAAAA,GAAArW,GACA,SAAAA,IAAiCA,MACjCpE,EAAAnN,OAAApC,KAAA2T,GA4BA,MAlBAqW,GAAAvhB,UAAAwhB,SAAA,SAAAC,EAAAC,EAAA5W,GACA,GAAA6W,GAAAC,EAAA9a,EAAA9M,UAAA0nB,EAAA5W,GAAA+W,KAAsFC,IACtF,QAAArnB,KAAAmnB,GACA,GAAAA,EAAAnnB,IAAAmnB,EAAAnnB,GAAAyQ,SAEAyW,EAAAxpB,OAAAU,KAAA+oB,EAAAnnB,GAAAyQ,QACAyW,EAAApoB,QAEA,OAAAwoB,KAAAJ,GACAG,EAAA1hB,QAAAuhB,EAAAI,KAAA,IAEAD,EAAAznB,KAAAsnB,EAAAI,IACAF,EAAAF,EAAAI,IAAAxqB,KAAAoqB,EAAAI,IAGA,OAAAjb,GAAAnN,UAAkCkoB,EAAAJ,IAGlCF,IAEA3rB,GAAA2rB,eAKA,SAAA5rB,EAAAC,EAAAC,GAEA,YACA,IAAAgR,GAAAhR,EAAA,IACAmsB,EAAAnsB,EAAA,IACAosB,EAAApsB,EAAA,IACAqsB,EAAArsB,EAAA,IACAssB,EAAAtsB,EAAA,IACA2R,EAAA3R,EAAA,GAkBAusB,EAAA,WACA,QAAAA,GAAA/T,EAAA2G,EAAAqN,EAAA5X,EACAgC,EAAA6V,GACA/qB,KAAA8W,aACA9W,KAAAyd,eACAzd,KAAA8qB,aACA9qB,KAAAkT,QACAlT,KAAAkV,SACAlV,KAAA+qB,UACA/qB,KAAAqM,GAAA4D,EAAA7D,SAAAC,GACArM,KAAAgrB,UAAA,GAAAN,GAAAO,UAAAnU,EAAA5D,GACAlT,KAAAkrB,eAAA,GAAAP,GAAAQ,eAAArU,GACA9W,KAAAorB,aAAA,GAAAR,GAAAS,aAAAvU,GACA9W,KAAAqS,YAAAyE,EAAAzE,cACArS,KAAAsrB,4BACAtrB,KAAAgrB,UAAAO,gBACAvrB,KAAAkrB,eAAAK,gBACAvrB,KAAAorB,aAAAG,gBA4CA,MA1CAV,GAAApiB,UAAA+iB,cAAA,WACA,GAAAtlB,GAAAlG,IAEA,OADAA,MAAA+qB,QAAAU,kBAAAje,QAAAxN,KAAA8W,YACA9W,KAAA8W,WAAAC,MACApG,KAAA,SAAA+a,GAAqC,MAAAA,GAAAvqB,OADrCnB,SAEA,SAAA0S,GAAsC,MAAAxM,GAAAylB,cAAAjZ,MAEtCmY,EAAApiB,UAAA6iB,0BAAA,WAEAtrB,KAAA8W,WAAAoK,aAAqClhB,KAAA4rB,UAAAlqB,KAAA1B,OAA8Bwd,SAAA,QAEnEqN,EAAApiB,UAAAkjB,cAAA,SAAAjZ,GACA,GAAAkD,GAAA5V,KAAA8W,EAAAlB,EAAAkB,WAAA5B,EAAAU,EAAAV,OAAA7I,EAAAuJ,EAAAvJ,EAEA,IAAAqG,YAAApD,GAAAK,UAAA,CACA,GAAA+C,EAAAtC,OAAAd,EAAAa,WAAAgB,QAEA,MADAnR,MAAA8qB,WAAAe,SACA3W,EAAApH,OAEA,IAAA4E,EAAAtC,OAAAd,EAAAa,WAAAY,YAAA2B,EAAA1B,YAAA0B,EAAApC,iBAAAma,GAAAzV,YACA,MAAAhV,MAAA8rB,aAAAhV,EAAAhC,SAAApC,EAAApC,SAAAkb,eAEA9Y,GAAAtC,OAAAd,EAAAa,WAAAkB,SACArR,KAAA8qB,WAAAe,SAIA,MADA7rB,MAAAyd,aAAAsO,sBAAArZ,GACArG,EAAAqE,OAAAgC,IAEAmY,EAAApiB,UAAAmjB,UAAA,WACA,GAAA9U,GAAA9W,KAAA8W,WACAlB,EAAA5V,KAAA8qB,EAAAlV,EAAAkV,WAAA5V,EAAAU,EAAAV,OACArE,EAAAiG,EAAAjG,SACAA,GAAAtE,UAAA2I,EAAAiV,SAAAtG,WACAiH,EAAAhoB,KAAAoS,EAAAiV,SAAAtG,UAAAlB,IAAAzN,EAAAvB,QAA4ElF,QAAA,YAAAoC,EAAAtE,WAE5Eue,EAAAe,QAAA,IAEAhB,EAAApiB,UAAAqjB,aAAA,SAAAhX,GACA,GAAAc,GAAA5V,KAAAyd,EAAA7H,EAAA6H,aAAAqN,EAAAlV,EAAAkV,WAAA5X,EAAA0C,EAAA1C,MAAAgC,EAAAU,EAAAV,OAAA6V,EAAAnV,EAAAmV,OACA,WAAAF,GAAA/V,EAAA2I,EAAAqN,EAAA5X,EAAAgC,EAAA6V,IAEAF,IAEAxsB,GAAAwsB,qBAKA,SAAAzsB,EAAAC,GAGA,YAeA,IAAA2W,GAAA,WACA,QAAAA,GAAAgX,EAAAC,EAAAC,EAAA1Z,GACA,SAAA0Z,IAAkCA,MAClC,SAAA1Z,IAAmCA,MACnCxS,KAAAgsB,cACAhsB,KAAAisB,cACAjsB,KAAAwS,WACAxS,KAAAksB,cAqCA,MAnCAlX,GAAAvM,UAAAjH,KAAA,WACA,MAAAxB,MAAAisB,aAAAjsB,KAAAisB,YAAAzqB,MAAAxB,KAAAgsB,aAEAhX,EAAAvM,UAAAwM,WAAA,WACA,MAAAjV,MAAAgsB,aAEAhX,EAAAvM,UAAAkL,OAAA,WACA,MAAA3T,MAAAksB,SAEAlX,EAAAvM,UAAAyM,OAAA,WACA,MAAAlV,MAAAisB,aAEAjX,EAAAvM,UAAA6K,MAAA,WACA,MAAAtT,MAAAisB,aAAAjsB,KAAAisB,YAAAzY,MAEAwB,EAAAvM,UAAAoI,QAAA,WACA,MAAA7Q,MAAAwS,UAEAwC,EAAAvM,UAAA0jB,OAAA,WACA,SAAAnsB,KAAAisB,cAAAjsB,KAAAisB,YAAAzY,OAEAwB,EAAAvM,UAAAgK,MAAA,WACA,OAAAzS,KAAA0S,SAEAsC,EAAAvM,UAAAiK,MAAA,WACA,GAAA0Z,GAAApsB,KAAA6Q,UAAAwb,QACA,KAAArsB,KAAAisB,aAAAG,EAAA,CACA,GAAAjY,GAAAiY,EAAA5qB,KAAA4qB,EAAA5qB,KAAA4qB,CACA,6BAAApsB,KAAAwB,OAAA,iBAAA2S,EAAA,IAEA,MAAAnU,MAAAisB,YAEAjsB,KAAAisB,YAAAzY,KAAA,OACA,UAAAxT,KAAAwB,OAAA,8BAFA,kBAAAxB,KAAAwB,OAAA,KAIAwT,IAEA3W,GAAA2W,eAKA,SAAA5W,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACA2R,EAAA3R,EAAA,GACA2sB,EAAA,WACA,QAAAA,GAAAnU,EAAA5D,GACAlT,KAAA8W,aACA9W,KAAAkT,QACAlT,KAAAqS,YAAAyE,EAAAzE,cACArS,KAAAssB,cAAAxV,EAAAjC,MAAA,YACA7U,KAAAusB,aAAAzV,EAAAjC,MAAA,WAkBA,MAhBAoW,GAAAxiB,UAAA+jB,qBAAA,WACA,MAAAvc,GAAA7D,SAAAC,GAAAvF,IAAA9G,KAAAssB,cAAAvoB,IAAA,SAAA0oB,GAAuF,MAAAA,GAAAC,UAAsB/b,KAAApB,EAAAnH,OAE7G6iB,EAAAxiB,UAAAkkB,YAAA,WACA,GAAAzZ,GAAAlT,KAAAkT,KACAlT,MAAAusB,aAAA9qB,QAAA,SAAA4X,GAA0D,MAAAnG,GAAA0Z,qBAAAvT,KAC1DrZ,KAAAssB,cAAA7qB,QAAA,SAAA4X,GAA2D,MAAAnG,GAAA2Z,mBAAAxT,KAC3DnG,EAAA4Z,QAEA7B,EAAAxiB,UAAA8iB,cAAA,WACAvrB,KAAAssB,cAAAtqB,QACAhC,KAAA8W,WAAA+J,WAAuC7gB,KAAAwsB,qBAAA9qB,KAAA1B,QAEvCA,KAAAusB,aAAAvqB,QAAAhC,KAAAssB,cAAAtqB,SACAhC,KAAA8W,WAAAoK,aAAyClhB,KAAA2sB,YAAAjrB,KAAA1B,QAEzCirB,IAEA5sB,GAAA4sB,aAKA,SAAA7sB,EAAAC,GAEA,YACA,IAAA8sB,GAAA,WACA,QAAAA,GAAArU,GACA9W,KAAA8W,aAsBA,MApBAqU,GAAA1iB,UAAA8iB,cAAA,WACAvrB,KAAA+sB,uBACA/sB,KAAAgtB,wBACAhtB,KAAAitB,uBAEA9B,EAAA1iB,UAAAskB,qBAAA,WACA,GAAA7mB,GAAAlG,IACAA,MAAA8W,WAAApC,WAAAnT,OAAA,SAAA+R,GAA6D,QAAAA,EAAAwN,UAC7Drf,QAAA,SAAA6R,GAAwC,MAAApN,GAAA4Q,WAAAgK,SAAkCpM,SAAApB,EAAA9R,MAAuB8R,EAAAwN,YAEjGqK,EAAA1iB,UAAAukB,sBAAA,WACA,GAAA9mB,GAAAlG,IACAA,MAAA8W,WAAAlC,WAAArT,OAAA,SAAA+R,GAA6D,QAAAA,EAAAyN,WAC7Dtf,QAAA,SAAA6R,GAAwC,MAAApN,GAAA4Q,WAAAiK,UAAmCnM,SAAAtB,EAAA9R,MAAuB8R,EAAAyN,aAElGoK,EAAA1iB,UAAAwkB,oBAAA,WACA,GAAA/mB,GAAAlG,IACAA,MAAA8W,WAAAnC,UAAApT,OAAA,SAAA+R,GAA4D,QAAAA,EAAA0N,SAC5Dvf,QAAA,SAAA6R,GAAwC,MAAApN,GAAA4Q,WAAAkK,QAAiCrM,QAAArB,EAAA9R,MAAsB8R,EAAA0N,WAE/FmK,IAEA9sB,GAAA8sB,kBAKA,SAAA/sB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA4uB,EAAA5uB,EAAA,IACA6uB,EAAA7uB,EAAA,GACAmR,EAAAnR,EAAA,IACA8uB,EAAAF,EAAAG,cAAAH,EAAAG,cAAAD,MACAE,EAAAJ,EAAAG,cAAAH,EAAAG,cAAAC,OAOAjC,EAAA,WACA,QAAAA,GAAAvU,GACA9W,KAAA8W,aA2BA,MAzBAuU,GAAA5iB,UAAA8iB,cAAA,WAIA,QAAAgC,GAAAC,GACA,MAAAje,GAAA5J,KAAA0M,EAAAlR,IAAA2S,eAAA2Z,YAAAle,EAAAnN,QAA8F0U,WAAA0W,IAA8B/R,cAAA6R,KAI5H,QAAAI,GAAA3P,EAAAyP,GACA,GAAAlZ,GAAA/E,EAAA9K,KAAA4N,EAAAqC,SAAAhR,EAAA+H,OAAA,QAAAsS,IAEAjD,EAAAxG,EAAAR,eACA6Z,EAAA,GAAAle,GAAAK,WAAA,uBAAmF,MAAAP,GAAAxL,IAAA+W,EAAA/G,iBAAA,SAAAqJ,GAA6D,MAAAA,GAAAnJ,SAChJpD,EAAAtB,EAAAnN,QAA4C0U,WAAA0W,IAA8B/R,cAAA2R,GAE1E,OAAAtS,GAAA8S,mBAAAtZ,EAAAhB,MAAAzC,GACAF,KAAA,WAAoC,MAAAgd,GAAAE,kBAAA/S,KACpCnK,KAAA,WAAoC,MAAAmK,GAAAvG,gBAAgCoZ,aAAuBrZ,EAAAhB,SAjB3F,GAAAjB,GAAArS,KAAA8W,WAAAzE,aAEAkb,GAAAO,SAAA,gBAKAJ,EAAAI,SAAA,0BAaA9tB,KAAA8W,WAAA+J,WAAmC0M,GAAsB/P,SAAA,MAEzDxd,KAAA8W,WAAAgK,SAAkCpM,SAAAyY,EAAArjB,KAAA,IAA4B4jB,GAA8BlQ,SAAA,OAE5F6N,IAEAhtB,GAAAgtB,gBAKA,SAAAjtB,EAAAC,GAEA,cAEA,SAAAgvB,GACAA,IAAA,aACAA,IAAA,eACAA,IAAA,kBACEhvB,EAAAgvB,gBAAAhvB,EAAAgvB,kBACFhvB,GAAAgvB,eAKA,SAAAjvB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACA2R,EAAA3R,EAAA,GACAgT,EAAAhT,EAAA,IAaAwR,EAAA,WACA,QAAAA,GAAAtO,EAAAusB,EAAAC,GACAhuB,KAAAoS,QAAAxM,OACA2J,EAAAnN,OAAApC,MACAwB,OACAusB,YACA3R,KAAAnM,EAAA7D,SAAAE,UAAA2hB,SAAAF,EAAA9d,EAAA7D,SAAAE,UAAA4hB,UACAja,KAAA+Z,IA6DA,MAhDAle,GAAArH,UAAAolB,kBAAA,SAAA/Z,EAAAjD,GACA,GAAA3K,GAAAlG,IACA,UAAA6Q,IAAkCA,KAClC,IAAA+E,GAAA5V,KAAAwB,EAAAoU,EAAApU,KAAA4a,EAAAxG,EAAAwG,KAAA2R,EAAAnY,EAAAmY,SACAzc,GAAAoG,MAAAqE,uBAAA/b,KAAA6Q,EAEA,IAAAsd,GAAAle,EAAA7D,SAAAC,GAAA8F,OACAnS,MAAAoS,QAAA+b,EAAA/b,OAGA,IAAAgc,GAAAta,EAAAC,eAAA,MAAoEsa,eAAA7sB,KAEpE8sB,EAAA/e,EAAAlN,KAAA+rB,EAAAhS,GAEAmS,EAAAhf,EAAAxL,IAAAuqB,EAAA,SAAAtS,GAA+E,MAAAA,GAAAwS,IAAA1a,EAAAjD,IAG/E,OAAAZ,GAAA7D,SAAAC,GAAAvF,IAAAynB,GAAA5d,KAAA,SAAA4Q,GACA,IACA,GAAAld,GAAA4L,EAAA7D,SAAAE,UAAAjB,OAAA0iB,EAAA,KAAAxM,EACA4M,GAAAzY,QAAArR,GAEA,MAAAqO,GACAyb,EAAAzd,OAAAgC,GAEA,MAAAxM,GAAAkM,UACUzB,KAAA,SAAAsD,GAGV,MAFA/N,GAAA+N,OACA3C,EAAAoG,MAAAwE,wBAAAhW,EAAA2K,GACA3K,EAAAkM,WAGAtC,EAAArH,UAAA+lB,IAAA,SAAA1a,EAAAjD,GACA,MAAA7Q,MAAAoS,SAAApS,KAAA6tB,kBAAA/Z,EAAAjD,IAEAf,EAAArH,UAAAtB,SAAA,WACA,0BAAAnH,KAAAwB,KAAA,gBAAAxB,KAAAoc,KAAA,MAKAtM,EAAA0E,gBAAA,SAAAX,GAEA,GAAA5C,GAAA1B,EAAAhO,OAAAsS,EAAAnQ,EAAAC,IAAAQ,EAAA0F,eAAAvI,EAAAV,OAAAU,KAAA2P,EACA,IAAA3P,EAAAU,OACA,SAAA6C,OAAA,8BAAAvD,EAAA,OAAA2P,EAAA3P,EAAA,IACA,OAAAiO,GAAAxL,IAAA8P,EAAA,SAAAvM,EAAA9F,GAA4D,UAAAsO,GAAAtO,EAAA8F,MAE5DwI,IAEAzR,GAAAyR,cAKA,SAAA1R,EAAAC,EAAAC,GAGA,YACA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GAaAmwB,EAAA,WACA,QAAAA,GAAA5uB,GACA0P,EAAAnN,OAAApC,KAAAH,GA+DA,MA9CA4uB,GAAAhmB,UAAAmD,GAAA,SAAA8iB,GACA,MAAA1uB,QAAA0uB,GAAA1uB,KAAAwT,OAAAkb,GAAA1uB,KAAAgZ,QAAA0V,GAYAD,EAAAhmB,UAAAuQ,IAAA,WACA,KAAAhZ,KAAAuI,QAAAvI,KAAAuI,iBAAAvI,MAAA8L,aACA,MAAA9L,MAAAwB,IACA,IAAAA,GAAAxB,KAAAuI,OAAAyQ,KACA,OAAAxX,KAAA,IAAAxB,KAAAwB,KAAAxB,KAAAwB,MAYAitB,EAAAhmB,UAAA3I,KAAA,WACA,MAAAE,MAAAuI,QAAAvI,KAAAuI,OAAAzI,QAAAE,MAEAyuB,EAAAhmB,UAAA6P,WAAA,SAAA1W,GACAA,EAAA2N,EAAA5N,SAAAC,GAAyC0G,SAAA,GACzC,IAAAgiB,GAAA1oB,EAAA0G,SAAAtI,KAAAuI,QAAAvI,KAAAuI,OAAA+P,gBACA,OAAAgS,GAAAnoB,OAAAoN,EAAApG,OAAAnJ,KAAA2T,UAEA8a,EAAAhmB,UAAAkmB,UAAA,SAAAvuB,EAAAwB,GAEA,MADA,UAAAA,IAA+BA,MAC/B5B,KAAA2iB,KAAA3iB,KAAA2iB,IAAAgM,UAAAvuB,EAAAwB,IACA2N,EAAA9K,KAAA8K,EAAApG,OAAAnJ,KAAA2T,QAAAjQ,EAAA+H,OAAA,KAAArL,KACAwB,EAAA0G,SAAAtI,KAAAuI,QAAAvI,KAAAuI,OAAAomB,UAAAvuB,IAEAquB,EAAAhmB,UAAAtB,SAAA,WACA,MAAAnH,MAAAgZ,OAEAyV,IAEApwB,GAAAowB,SAKA,SAAArwB,EAAAC,EAAAC,GAEA,YAEA,IAAA6F,GAAA7F,EAAA,GACAswB,EAAA,WACA,QAAAA,GAAAC,GACA7uB,KAAA6uB,UAwCA,MAtCAD,GAAAnmB,UAAAqmB,WAAA,SAAA3a,GAEA,MADAA,MAAA,GACA,IAAAA,EAAAtL,QAAA,UAAAsL,EAAAtL,QAAA,MAEA+lB,EAAAnmB,UAAAhE,KAAA,SAAAsqB,EAAA3C,GACA,GAAA2C,GAAA,KAAAA,EAAA,CAEA,GAAAC,GAAA7qB,EAAAuB,SAAAqpB,GACAvtB,EAAAwtB,EAAAD,IAAAvtB,IACAxB,MAAA8uB,WAAAttB,KACAA,EAAAxB,KAAAytB,YAAAjsB,EAAA4qB,GACA,IAAA9Y,GAAAtT,KAAA6uB,QAAArtB,EACA,QAAA8R,IAAA0b,OAAA1b,IAAAyb,GAAAzb,EAAAE,OAAAub,GAAA,OACAzb,IAIAsb,EAAAnmB,UAAAglB,YAAA,SAAAjsB,EAAA4qB,GACA,IAAAA,EACA,SAAAvnB,OAAA,sCAAArD,EAAA,IAGA,KAFA,GAAAytB,GAAAjvB,KAAAyE,KAAA2nB,GACA8C,EAAA1tB,EAAAkK,MAAA,KAAAxI,EAAA,EAAAisB,EAAAD,EAAAltB,OAAA8L,EAAAmhB,EACe/rB,EAAAisB,EAAgBjsB,IAC/B,QAAAgsB,EAAAhsB,IAAA,IAAAA,EAAA,CAIA,SAAAgsB,EAAAhsB,GAMA,KALA,KAAA4K,EAAAvF,OACA,SAAA1D,OAAA,SAAArD,EAAA,0BAAAytB,EAAAztB,KAAA,IACAsM,KAAAvF,WANAuF,GAAAmhB,CAWA,IAAAG,GAAAF,EAAAvmB,MAAAzF,GAAAiK,KAAA,IACA,OAAAW,GAAAtM,MAAAsM,EAAAtM,MAAA4tB,EAAA,QAAAA,GAEAR,IAEAvwB,GAAAuwB,gBAKA,SAAAxwB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,IACA+wB,EAAA,WACA,QAAAA,GAAAC,EAAAnL,EAAAoL,GACAvvB,KAAAsvB,SACAtvB,KAAAmkB,UACAnkB,KAAAuvB,qBACAvvB,KAAAwvB,SAiEA,MA/DAH,GAAA5mB,UAAA+Z,SAAA,SAAA3iB,GACA,GAAA+V,GAAA5V,KAAAsvB,EAAA1Z,EAAA0Z,OAAAE,EAAA5Z,EAAA4Z,MAAAta,EAAAU,EAAAV,OAGA5B,EAAA/D,EAAAjH,QAAA,GAAAiJ,GAAAkd,MAAAlf,EAAAnN,UAA8EvC,GAC9E2T,KAAA3T,EACA6V,QAAA7V,EAAA6V,YACAvO,SAAA,WAAoC,MAAAtH,GAAA2B,QAEpC,KAAA2C,EAAAuB,SAAA4N,EAAA9R,MACA,SAAAqD,OAAA,+BACA,IAAAyqB,EAAA3uB,eAAA2S,EAAA9R,OAAA+N,EAAA3L,MAAA4rB,EAAA,QAAA3mB,QAAAyK,EAAA9R,WACA,SAAAqD,OAAA,UAAAyO,EAAA9R,KAAA,uBAKA,OAJAguB,GAAA1sB,KAAAwQ,GACAtT,KAAAkV,QACAlV,KAAAyvB,MAAAva,GAEA5B,GAEA+b,EAAA5mB,UAAAgnB,MAAA,SAAAva,GAGA,IAFA,GACA7Q,GAAAiP,EAAAoc,EADA9Z,EAAA5V,KAAAwvB,EAAA5Z,EAAA4Z,MAAAF,EAAA1Z,EAAA0Z,OAAAnL,EAAAvO,EAAAuO,QACAwL,KAAAC,KACAJ,EAAAxtB,OAAA,GAIA,GAHAsR,EAAAkc,EAAA9hB,QACArJ,EAAA8f,EAAAC,MAAA9Q,GACAoc,EAAAC,EAAA9mB,QAAAyK,GACAjP,EAAA,CACA,GAAAirB,EAAA3uB,eAAA2S,EAAA9R,MACA,SAAAqD,OAAA,UAAArD,KAAA,uBACA8tB,GAAAhc,EAAA9R,MAAA8R,EACAtT,KAAA6vB,YAAA3a,EAAA5B,GACAoc,GAAA,GACAC,EAAA3mB,OAAA0mB,EAAA,OANA,CASA,GAAAI,GAAAF,EAAAtc,EAAA9R,KAEA,IADAouB,EAAAtc,EAAA9R,MAAAguB,EAAAxtB,OACA0tB,GAAA,GAAAI,IAAAN,EAAAxtB,OAGA,MAAAstB,EAEAI,GAAA,GACAC,EAAA7sB,KAAAwQ,GAEAkc,EAAA1sB,KAAAwQ,GAEA,MAAAgc,IAEAD,EAAA5mB,UAAAsnB,UAAA,SAAA7a,GACAlV,KAAAkV,SACAlV,KAAAyvB,MAAAva,IAEAma,EAAA5mB,UAAAonB,YAAA,SAAA3a,EAAA5B,GACA,GAAAic,GAAAvvB,KAAAuvB,oBACAjc,EAAA/D,EAAAlH,cAAAiL,EAAAqP,KAEA4M,EAAAjT,KAAAhJ,EAAAqP,KAAA,iCAAAqN,EAAAC,GACA/a,EAAAiV,SAAAtG,YAAAvQ,GAAA/D,EAAAxM,aAAAitB,EAAAC,IACA/a,EAAAgb,aAAA5c,EAAA0c,GAAyD1nB,SAAA,EAAAiE,UAAA,QAIzD8iB,IAEAhxB,GAAAgxB,qBAKA,SAAAjxB,EAAAC,EAAAC,GAGA,YACA,IAAA6xB,GAAA7xB,EAAA,IACA8xB,EAAA9xB,EAAA,IACA+xB,EAAA/xB,EAAA,IACAgyB,EAAA,WACA,QAAAA,GAAAC,EAAAC,GACAxwB,KAAAsvB,UACAtvB,KAAA+iB,QAAA,GAAAoN,GAAAvB,aAAA5uB,KAAAsvB,QACAtvB,KAAAmkB,QAAA,GAAAiM,GAAAtN,aAAA9iB,KAAA+iB,QAAAwN,GACAvwB,KAAAywB,WAAA,GAAAJ,GAAAhB,kBAAArvB,KAAAsvB,OAAAtvB,KAAAmkB,QAAAqM,EACA,IAAAE,IACAlvB,KAAA,GACAmhB,IAAA,IACA9N,MAAA,KACAlB,QACAgd,KAAuB7vB,MAAA,KAAAsP,KAAA,OAAAsG,SAAA,IAEvBka,YAAA,GAEAC,EAAA7wB,KAAA6wB,MAAA7wB,KAAAywB,WAAAjO,SAAAkO,EACAG,GAAAhN,UAAA,KAkBA,MAhBAyM,GAAA7nB,UAAA3I,KAAA,WACA,MAAAE,MAAA6wB,OAEAP,EAAA7nB,UAAA+Z,SAAA,SAAAsO,GACA,MAAA9wB,MAAAywB,WAAAjO,SAAAsO,IAEAR,EAAA7nB,UAAA+lB,IAAA,SAAAO,EAAA3C,GACA,GAAAlmB,GAAAlG,IACA,QAAA+B,UAAAC,OACA,MAAApB,QAAAU,KAAAtB,KAAAsvB,QAAAvrB,IAAA,SAAAvC,GAAkE,MAAA0E,GAAAopB,OAAA9tB,GAAAgS,MAClE,IAAAud,GAAA/wB,KAAA+iB,QAAAte,KAAAsqB,EAAA3C,EACA,OAAA2E,MAAAvd,MAAA,MAEA8c,EAAA7nB,UAAA4Z,UAAA,SAAA7gB,EAAA8gB,GACA,MAAAtiB,MAAAmkB,gBAAA3iB,EAAA8gB,IAEAgO,IAEAjyB,GAAAiyB,iBAKA,SAAAlyB,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACA0yB,EAAA1yB,EAAA,GACA2R,EAAA3R,EAAA,GACAmT,EAAAnT,EAAA,IACAkT,EAAAlT,EAAA,IACA2yB,EAAA3yB,EAAA,IACAgR,EAAAhR,EAAA,IACAmsB,EAAAnsB,EAAA,IACA4yB,EAAA5yB,EAAA,IACA6yB,EAAA7yB,EAAA,IACA0hB,EAAA1hB,EAAA,GACA8yB,EAAA9yB,EAAA,GACA+yB,EAAA/yB,EAAA,GACAgzB,EAAA,WACA,QAAAA,GAAApe,EAAA4X,EAAArN,EAAA0E,EAAAoP,EAAAxG,GACA/qB,KAAAkT,QACAlT,KAAA8qB,aACA9qB,KAAAyd,eACAzd,KAAAmiB,gBACAniB,KAAAuxB,gBACAvxB,KAAA+qB,SACA,IAAAyG,IAAA,4CACAC,EAAA7wB,OAAAU,KAAAgwB,EAAA7oB,WAAAlH,OAAA,SAAAiB,GAAmF,MAAAgvB,GAAA3oB,QAAArG,SACnF6uB,GAAApwB,cAAAqwB,EAAA7oB,UAAAzI,UAAAyxB,GAuaA,MAraA7wB,QAAAC,eAAAywB,EAAA7oB,UAAA,cACA+lB,IAAA,WAA2B,MAAAxuB,MAAA+qB,QAAAjU,YAC3B4a,YAAA,EACAC,cAAA,IAEA/wB,OAAAC,eAAAywB,EAAA7oB,UAAA,UACA+lB,IAAA,WAA2B,MAAAxuB,MAAA+qB,QAAApX,QAC3B+d,YAAA,EACAC,cAAA,IAEA/wB,OAAAC,eAAAywB,EAAA7oB,UAAA,WACA+lB,IAAA,WAA2B,MAAAxuB,MAAA+qB,QAAAjd,SAC3B4jB,YAAA,EACAC,cAAA,IAEA/wB,OAAAC,eAAAywB,EAAA7oB,UAAA,YACA+lB,IAAA,WAA2B,MAAAxuB,MAAA+qB,QAAAZ,UAC3BuH,YAAA,EACAC,cAAA,IAUAL,EAAA7oB,UAAAmpB,0BAAA,SAAA7f,EAAA8f,GAqBA,QAAAC,KACA,GAAAC,GAAAC,EAAArkB,SACA,OAAA/H,UAAAmsB,EACAziB,EAAAK,UAAAsB,QAAA4gB,EAAAnf,SAAAjC,YACAwhB,EAAAF,GAAAphB,KAAAuhB,GAAAvhB,KAAA,SAAAtM,GAAgG,MAAAA,IAAAytB,MAxBhG,GAAA5rB,GAAAlG,KACAmyB,EAAA,WAAwC,MAAAjsB,GAAA6kB,QAAAU,kBAAAzd,YACxCokB,EAAAD,IACAE,EAAA5gB,EAAAsB,YAAAuf,gBAAAvgB,GACAigB,EAAA,GAAAhB,GAAA3jB,SAAAlL,OAAAnC,KAAAuxB,cAAAnP,mBACA/V,EAAA4D,EAAA7D,SAAAC,GAAAC,EAAA2D,EAAA7D,SAAAE,UACA2lB,EAAA,SAAAhuB,GAAmD,MAAAoI,GAAAiQ,KAAAhQ,EAAAjB,OAAApH,EAAA,MAAkD4tB,OAAAQ,aACrGH,EAAA,SAAA7tB,GACA,GAAAA,YAAAomB,GAAAzV,YAAA,CAGA,GAAAqM,GAAAhd,CAGA,OADAgd,GAAAnb,EAAAmb,SAAApM,aAAAoM,EAAA1N,SAAA0N,EAAAxQ,WACAwQ,EAAA5O,QAEA0f,MAAAC,EACA9iB,EAAAK,UAAAiB,aAAAH,YACAvK,EAAAgqB,aAAA7O,EAAApM,aAAAoM,EAAA1N,SAAA0N,EAAAxQ,WAHAvB,EAAAK,UAAAsB,QAAAoQ,EAAA3O,SAAAjC,aAWA,OAAAqhB,MA+CAR,EAAA7oB,UAAAoN,OAAA,SAAA1C,GACA,MAAAnT,MAAAkwB,aAAAlwB,KAAA8N,QAAA9N,KAAA2T,QACAkC,QAAA1R,EAAAgG,UAAAgJ,MACA7K,SAAA,EACAiqB,QAAA,KAsEAjB,EAAA7oB,UAAA+pB,GAAA,SAAArxB,EAAAwS,EAAA9C,GACA,GAAA4hB,IAA6BpG,SAAArsB,KAAAmqB,SAAA7hB,SAAA,GAC7BoqB,EAAAnjB,EAAA5N,SAAAkP,EAAA4hB,EAAAxB,EAAA0B,iBACA,OAAA3yB,MAAAkwB,aAAA/uB,EAAAwS,EAAA+e,IAIApB,EAAA7oB,UAAA4Y,OAAA,SAAApM,EAAAtB,EAAA9C,GAGA,GAFA,SAAAA,IAAkCA,MAElC1M,EAAAoG,SAAAsG,EAAAgF,UAAAhF,EAAAgF,OAAArU,KACA,SAAAqD,OAAA,8BAEA,IADAgM,EAAAsC,YAAAtC,EAAAgF,UAAA,EAAA7V,KAAAmiB,cAAAriB,OAAAE,KAAAmiB,cAAAY,QAAAte,KAAAoM,EAAAgF,OAAAhF,EAAAwb,UACAxb,EAAAgF,SAAAhF,EAAAsC,YACA,SAAAtO,OAAA,0BAAAV,EAAAuB,SAAAmL,EAAAgF,QAAAhF,EAAAgF,OAAAhF,EAAAgF,OAAArU,MAAA,IACA,IAAAsvB,GAAA9wB,KAAAmiB,cAAAY,QAAAte,KAAAwQ,EAAApE,EAAAwb,SACA,WAAA5B,GAAAzV,YAAAC,EAAA6b,EAAAnd,EAAA9C,IAyCAygB,EAAA7oB,UAAAynB,aAAA,SAAA/uB,EAAAyX,EAAA/H,GACA,GAAA3K,GAAAlG,IACA,UAAA4Y,IAAmCA,MACnC,SAAA/H,IAAkCA,KAClC,IAAA+hB,GAAA5yB,KAAA+qB,QAAAU,iBACA5a,GAAAtB,EAAA5N,SAAAkP,EAAAogB,EAAA0B,kBACA9hB,EAAAtB,EAAAnN,OAAAyO,GAA6C/C,QAAA8kB,EAAA5kB,SAAAtM,KAAAkxB,IAC7C,IAAAlE,GAAA1uB,KAAAqhB,OAAAlgB,EAAAyX,EAAA/H,GACAgiB,EAAA7yB,KAAA+qB,QAAA+H,sBAAA9kB,WACA+kB,EAAA,WAAqC,MAAAthB,GAAAsB,YAAAigB,sBAAA,GAAAxhB,GAAA8D,KAAApP,EAAAic,cAAAriB,WACrCmzB,EAAAJ,IAAAxgB,cAAAlR,GAAA4xB,GACA,KAAArE,EAAAvC,SACA,MAAAnsB,MAAA4xB,0BAAAqB,EAAAvE,EACA,KAAAA,EAAAjc,QACA,MAAAxC,GAAA7D,SAAAC,GAAAqE,OAAAge,EAAAhc,QACA,IAAAoE,GAAA9W,KAAAyd,aAAAyV,OAAAD,EAAAvE,GACAyE,EAAA,GAAAjC,GAAArG,kBAAA/T,EAAA9W,KAAAyd,aAAAzd,KAAA8qB,WAAA9qB,KAAAkT,MAAAlT,UAAA+qB,SACAqI,EAAAD,EAAA3H,eAEA,OAAAjc,GAAAnN,OAAAgxB,GAAoDtc,gBAqCpDwa,EAAA7oB,UAAAmD,GAAA,SAAAmjB,EAAApb,EAAA9C,GACAA,EAAAtB,EAAA5N,SAAAkP,GAA+Cwb,SAAArsB,KAAAmqB,UAC/C,IAAA7W,GAAAtT,KAAAmiB,cAAAY,QAAAte,KAAAsqB,EAAAle,EAAAwb,SACA,IAAAloB,EAAAgG,UAAAmJ,GAEA,MAAAtT,MAAAmqB,WAAA7W,KAEAnP,EAAAgG,UAAAwJ,IAAA,OAAAA,GAAAwd,EAAA3a,MAAArO,OAAAmL,EAAAgF,aAAAtY,KAAA2T,YAsDA2d,EAAA7oB,UAAA+M,SAAA,SAAAuZ,EAAApb,EAAA9C,GACAA,EAAAtB,EAAA5N,SAAAkP,GAA+Cwb,SAAArsB,KAAAmqB,UAC/C,IAAAvd,GAAAzI,EAAAuB,SAAAqpB,IAAA/O,EAAAtT,KAAAU,WAAA2hB,EACA,IAAAniB,EAAA,CACA,IAAAA,EAAAC,QAAA7M,KAAAmqB,SAAA3oB,MACA,QACAutB,GAAA/uB,KAAAmqB,SAAA3oB,KAEA,GAAA8R,GAAAtT,KAAAmiB,cAAAY,QAAAte,KAAAsqB,EAAAle,EAAAwb,UAAAgH,EAAArzB,KAAAmqB,SAAA3U,QACA,IAAArR,EAAAgG,UAAAmJ,GAEA,QAAAnP,EAAAgG,UAAAkpB,EAAA/f,EAAA9R,UAGAmS,GAAAyd,EAAAruB,aAAAouB,EAAA3a,MAAArN,OAAAmK,EAAAgF,aAAA3E,GAAA3T,KAAA2T,OAAA/S,OAAAU,KAAAqS,MA8BA2d,EAAA7oB,UAAA6qB,KAAA,SAAAvE,EAAApb,EAAA9C,GACA,GAAA0iB,IACAC,OAAA,EACAlrB,SAAA,EACAmrB,UAAA,EACApH,SAAArsB,KAAAmqB,SAEAtZ,GAAAtB,EAAA5N,SAAAkP,EAAA0iB,EACA,IAAAjgB,GAAAtT,KAAAmiB,cAAAY,QAAAte,KAAAsqB,EAAAle,EAAAwb,SACA,KAAAloB,EAAAgG,UAAAmJ,GACA,WACAzC,GAAAvI,UACAqL,EAAA3T,KAAA2T,OAAAsW,SAAAtW,MAAuD3T,KAAAmqB,SAAA7W,GACvD,IAAAogB,GAAApgB,GAAAzC,EAAA2iB,MAAAlgB,EAAAuQ,UAAAvQ,CACA,OAAAogB,IAAA9tB,SAAA8tB,EAAA/Q,KAAA,OAAA+Q,EAAA/Q,IAGA3iB,KAAA8qB,WAAAwI,KAAAI,EAAA/Q,IAAAwO,EAAA3a,MAAArN,OAAAmK,EAAAgF,aAAA3E,IACA8f,SAAA5iB,EAAA4iB,WAHA,MAOAnC,EAAA7oB,UAAA+lB,IAAA,SAAAO,EAAA3C,GACA,WAAArqB,UAAAC,OACAhC,KAAAmiB,cAAAqM,MACAxuB,KAAAmiB,cAAAqM,IAAAO,EAAA3C,GAAApsB,KAAAmqB,WAEAmH,IAEAjzB,GAAAizB,gBAKA,SAAAlzB,EAAAC,EAAAC,GAGA,YACA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACAiT,EAAAjT,EAAA,IACAkT,EAAAlT,EAAA,IACAoT,EAAApT,EAAA,IAIAyU,EAAA,WACA,QAAAA,MAqIA,MAlIAA,GAAAuf,gBAAA,SAAA1vB,GACA,GAAA0Q,GAAA/D,EAAA5J,KAAA/C,GAAA0Q,KACA,WAAA/B,GAAAyD,YAAA1B,IAAA1Q,EAAAmB,IAAAL,EAAAM,KAAA,gBAAAiB,OAAAsK,EAAAtG,aAEA8J,EAAA4gB,UAAA,SAAA3hB,GACA,GAAA4G,GAAA5G,EAAA2B,QACA,OAAA3B,GAAAkD,SAAAtS,KAAAmB,IAAA,SAAAuP,GAAgE,UAAA9B,GAAA8D,KAAAhC,GAAAsgB,eAAAhb,MAGhE7F,EAAAC,YAAA,SAAAjB,EAAAC,GACA,GAAAc,GAAAC,EAAA4gB,UAAA3hB,EACA,OAAAA,GAAAnB,UAAAvI,QACAyK,EAAA8gB,cAAA9hB,EAAAe,EAAAlS,OAAAU,KAAA0Q,EAAA2B,WAEAb,GAEAC,EAAAE,iBAAA,SAAAC,EAAAtQ,GACA,MAAAA,GAAAmB,IAAA,SAAAuQ,GACA,GAAAwf,GAAAvkB,EAAApG,OAAAmL,EAAAhB,MAAAuB,WACAkf,EAAAD,EAAA/vB,IAAA,SAAA0oB,GAA8D,MAAAvZ,GAAA8gB,iBAAA1f,EAAAmY,KAA6CxnB,OAAAsK,EAAAhG,WAC3G,OAAAgG,GAAAnN,OAAAkS,GAA2CO,MAAAkf,OAc3ChhB,EAAA8gB,cAAA,SAAA9hB,EAAAe,EAAAmhB,GAEA,QAAAC,GAAAtxB,EAAA0Q,GACA,GAAAgB,GAAA/E,EAAA9K,KAAA7B,EAAAc,EAAA+H,OAAA,QAAA6H,GACA,OAAA/D,GAAAnN,UAAsCkS,KAAA2B,aAHtC,SAAAge,IAAiCA,KASjC,IAAAE,GAAAzwB,EAAAqF,MAAA,SAAAqrB,EAAAC,EAAAC,GAEA,GAAAC,GAAAhlB,EAAAnN,UAAiDkyB,KAAAre,aAEjDue,EAAAjlB,EAAAlN,KAAAkyB,EAAAF,EACAE,GAAAhlB,EAAA9L,KAAA8wB,EAAAF,EACA,IAAAI,GAAAP,EAAAE,EAAAE,EAAAhhB,WAEAohB,EAAAnlB,EAAAnN,OAAAmyB,EAAAE,EAAAD,EACA,WAAAhjB,GAAA8D,KAAAgf,EAAAhhB,OAAAsgB,eAAAc,IAGA,OAAA5hB,GAAA/O,IAAAowB,EAAApiB,EAAAkiB,KAOAlhB,EAAAigB,qBAAA,SAAAvF,GACA,GAAA3Z,GAAA,GAAApC,GAAAijB,eAAAlH,EASA,OALAA,GAAAhsB,QAAA,SAAA6S,GACAA,EAAAR,iBAAA8gB,cAAAtgB,EAAAhB,OACAgB,EAAAugB,gBAAA,GAAAnjB,GAAAojB,gBAAAxgB,EAAAR,eAAAQ,EAAAhB,OACAgB,EAAAT,SAAA,gBAAAnC,GAAA5B,WAAA,0BAAkG,MAAAwE,GAAA2B,aAA2B3B,EAAA2B,eAE7HwX,GAKA1a,EAAAV,YAAA,SAAAN,EAAAe,EAAAK,GAQA,QAAA4hB,GAAAC,EAAA1vB,GACA,GAAA2vB,GAAAzjB,EAAA8D,KAAA4f,MAAAF,EAEA,OADAC,GAAAhf,YAAAnD,EAAAxN,GAAA2Q,YACAgf,EAPA,IAHA,GAAAE,GAAA,EAAAhnB,EAAAhJ,KAAAD,IAAA6M,EAAA/P,OAAA8Q,EAAA9Q,QACAozB,EAAA,SAAA9hB,GAA8C,MAAAA,GAAAgF,YAA0BhQ,SAAA,IAAiB/G,OAAAmC,EAAAC,IAAAD,EAAAM,KAAA,aAAAD,IAAAL,EAAAM,KAAA,QACzFqxB,EAAA,SAAAC,EAAAC,GAAmD,MAAAD,GAAAntB,OAAAotB,EAAAH,EAAAE,EAAAhiB,SACnD6hB,EAAAhnB,GAAA4D,EAAAojB,GAAA7hB,QAAAH,GAAAkiB,EAAAtjB,EAAAojB,GAAAriB,EAAAqiB,KACAA,GAQA,IAAAj0B,GAAA0T,EAAAD,EAAAD,EAAAvT,EAEAq0B,EAAAC,EAAAC,CAaA,OAZAx0B,GAAA6Q,EACA6C,EAAA1T,EAAAyH,MAAA,EAAAwsB,GACAxgB,EAAAzT,EAAAyH,MAAAwsB,GAEAK,EAAA5gB,EAAA7Q,IAAAgxB,GACAU,EAAA3iB,EAAAnK,MAAAwsB,GAEAO,EAAA,EAAAvzB,OAAAszB,GAEAt0B,EAAA4R,EAAAigB,qBAAA0C,GAEAhhB,EAAAvT,EAAAwH,MAAAwsB,IACiBj0B,OAAAC,KAAAyT,WAAAD,UAAAD,aAEjB3B,EAAAK,sBAAA,SAAAf,EAAAyE,GACA,GAAA6e,GAAAtjB,EAAAlR,GAAA,EACAw0B,GAAA9hB,SAAA,gBAAAnC,GAAA5B,WAAA,0BAAkG,MAAAgH,IAAqBA,IAWvH/D,EAAA6iB,QAAA,SAAAhzB,EAAA0Q,GACA,GAAAgB,GAAA/E,EAAA9K,KAAA7B,EAAA,SAAAizB,GAA0D,MAAAA,GAAAviB,YAC1DwiB,EAAAlzB,EAAAiG,QAAAyL,EACA,IAAAwhB,OACA,SAAAjxB,OAAA,wCAAAyO,EACA,OAAA1Q,GAAA+F,MAAA,EAAAmtB,EAAA,IAGA/iB,EAAAkD,YAAA,SAAArT,GAAgD,MAAAA,GAAAqC,OAAA,SAAAykB,EAAApV,GAA0C,MAAA/E,GAAAnN,OAAAsnB,EAAApV,EAAA2B,mBAC1FlD,IAEA1U,GAAA0U,eAKA,SAAA3U,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACAiT,EAAAjT,EAAA,IACAgX,EAAA,WACA,QAAAA,GAAAhC,GACA,GAAAA,YAAAgC,GAAA,CACA,GAAAhB,GAAAhB,CACAtT,MAAAsT,MAAAgB,EAAAhB,MACAtT,KAAA+V,YAAAzB,EAAAyB,YAAApN,QACA3I,KAAAiW,YAAA1G,EAAAnN,UAAkDkS,EAAA2B,aAClDjW,KAAA6T,SAAAtE,EAAAnN,UAA+CkS,EAAAT,UAC/C7T,KAAA6U,MAAAP,EAAAO,OAAAP,EAAAO,MAAAlM,QACA3I,KAAA8T,eAAAQ,EAAAR,eACA9T,KAAA60B,gBAAAvgB,EAAAugB,oBAGA70B,MAAAsT,QACAtT,KAAA+V,YAAAzC,EAAAgF,YAAkDhQ,SAAA,IAClDtI,KAAAiW,eACAjW,KAAA6T,SAAAtE,EAAArG,OAAAoK,EAAAoC,QAAA,SAAApO,EAAA9F,GAAiF,UAAA+P,GAAAzB,WAAAtO,EAAA8F,KAiCjF,MA9BAgO,GAAA7M,UAAAmrB,eAAA,SAAAjgB,GACA,GAAAoiB,GAAA,SAAAC,GAAgD,OAAAA,EAAA51B,GAAA41B,EAAAl1B,MAAA6S,EAAAqiB,EAAA51B,MAEhD,OADAJ,MAAAiW,YAAAjW,KAAA+V,YAAA9Q,OAAA,SAAAO,EAAAywB,GAA2E,MAAA1mB,GAAAhK,WAAAC,EAAAuwB,EAAAE,SAC3Ej2B,MAEAsV,EAAA7M,UAAAkmB,UAAA,SAAAntB,GACA,MAAA+N,GAAA9K,KAAAzE,KAAA+V,YAAArS,EAAA+H,OAAA,KAAAjK,KAEA8T,EAAA7M,UAAAN,OAAA,SAAAmM,EAAAhT,GACA,GAAA4E,GAAAlG,IACA,UAAAsB,IAA+BA,EAAAtB,KAAA+V,YAAAhS,IAAAL,EAAAM,KAAA,OAC/B,IAAAkyB,GAAA,SAAA1zB,GAA2C,MAAA0D,GAAAyoB,UAAAnsB,GAAA4N,KAAAjI,OAAAjC,EAAA+P,YAAAzT,GAAA8R,EAAA2B,YAAAzT,IAC3C,OAAAxC,MAAAsT,QAAAgB,EAAAhB,OAAAhS,EAAAyC,IAAAmyB,GAAAjxB,OAAAsK,EAAAnG,UAAA,IAEAkM,EAAA4f,MAAA,SAAA5gB,GACA,UAAAgB,GAAAhB,IASAgB,EAAAC,SAAA,SAAA7S,EAAAC,GACA,GAAAwzB,GAAAzzB,EAAAuC,OAAA,SAAA6qB,EAAAxb,EAAApR,GACA,MAAA4sB,KAAA5sB,KAAAP,EAAAX,QAAAsS,EAAAhB,QAAA3Q,EAAAO,GAAAoQ,MAAApQ,EAAA,EAAA4sB,GACU,EACV,OAAAptB,GAAAiG,MAAA,EAAAwtB,IAEA7gB,IAEAjX,GAAAiX,QAKA,SAAAlX,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YAgKA,SAAA83B,GAAAC,EAAAra,GAEA,GAAAsa,GAAAnyB,EAAAuB,SAAA2wB,KAAA,KACAE,EAAApyB,EAAAoG,SAAA8rB,QACAG,EAAAD,EAAAva,EAAAxa,OAAA80B,GAAAG,CACA,OAAAvJ,GAAAG,cAAAmJ,GAnKA,GAAAjnB,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACAgT,EAAAhT,EAAA,IACA2R,EAAA3R,EAAA,GACA4uB,EAAA5uB,EAAA,IACA8yB,EAAA9yB,EAAA,GACAmT,EAAAnT,EAAA,IAEAm4B,EAAAvJ,EAAAG,cAAAH,EAAAG,cAAAD,MACAuH,EAAA,WACA,QAAAA,GAAA+B,GACA12B,KAAA02B,QACAnnB,EAAAnN,OAAApC,MACA22B,SAAA,SAAArjB,GACA,MAAA/D,GAAA9K,KAAAzE,KAAA02B,MAAAhzB,EAAA+H,OAAA,QAAA6H,KAEAsjB,QAAA,SAAAtjB,GACA,MAAA7B,GAAAsB,YAAA6iB,QAAA51B,KAAA02B,MAAApjB,MAiIA,MAvGAqhB,GAAAlsB,UAAAsL,eAAA,SAAAT,EAAAzC,GACAA,EAAAtB,EAAA5N,SAAAkP,GAA+Cwd,kBAC/C,IAAAzrB,GAAA0Q,EAAAtT,KAAA42B,QAAAtjB,GAAAtT,KAAA02B,MACAG,EAAAtnB,EAAA5J,KAAA/C,EACA,OAAAA,GAAAqC,OAAA,SAAAO,EAAA8O,GACA,GAAAwiB,GAAAxiB,IAAAuiB,EAAAhmB,EAAAwd,iBACA0I,EAAAxnB,EAAA9L,KAAA6Q,EAAAT,SAAAijB,EACA,OAAAvnB,GAAAnN,OAAAoD,EAAAuxB,SAIApC,EAAAlsB,UAAAuuB,oBAAA,SAAA1vB,GACA,GAAA8U,GAAAnM,EAAA7D,SAAAE,UAAA2hB,SAAA3mB,EAAA2I,EAAA7D,SAAAE,UAAA4hB,SACA,OAAA3e,GAAAlN,KAAArC,KAAA+T,iBAAAqI,IAEAuY,EAAAlsB,UAAAmsB,cAAA,SAAAthB,GACA,UAAAqhB,GAAA30B,KAAA42B,QAAAtjB,KAEAqhB,EAAAlsB,UAAA8L,eAAA,SAAA0iB,EAAA3jB,GACA/D,EAAAnN,OAAApC,KAAA22B,SAAArjB,GAAAO,SAAAojB,IAGAtC,EAAAlsB,UAAAyuB,kBAAA,SAAA5jB,GACA,MAAA/D,GAAAnN,UAAkCpC,KAAA22B,SAAArjB,GAAAO,WAGlC8gB,EAAAlsB,UAAAglB,YAAA,SAAA5c,GACA,GAAA3K,GAAAlG,IACA,UAAA6Q,IAAkCA,MAClCS,EAAAoG,MAAA2D,iBAAArb,KAAA02B,MAAA7lB,EACA,IAAAsmB,GAAA,SAAA7iB,GAA+C,MAAApO,GAAA0nB,mBAAAtZ,EAAAhB,MAAAzC,GAC/C,OAAAZ,GAAA7D,SAAAC,GAAAvF,IAAAyI,EAAAxL,IAAA/D,KAAA02B,MAAAS,IAAAxmB,KAAA,SAAA7J,GAA8G,MAAAA,GAAA7B,OAAAmsB,EAAAnoB,cAM9G0rB,EAAAlsB,UAAAmlB,mBAAA,SAAAta,EAAAzC,GACA,GAAA3K,GAAAlG,IACA,UAAA6Q,IAAkCA,KAElC,IAAAumB,GAAAvmB,KAAA4K,cACA4b,EAAAnK,EAAAG,cAAA+J,GAAAX,GAEAQ,EAAAj3B,KAAAk3B,kBAAA5jB,GACAgkB,EAAA,SAAAtb,GAA6D,MAAAoa,GAAA9iB,EAAAmI,cAAAO,IAAAqb,GAC7DE,EAAAhoB,EAAAhO,OAAA01B,EAAAK,GACAE,EAAA,SAAAxb,GAAwD,MAAAA,GAAAwS,IAAAtoB,EAAA0uB,cAAAthB,GAAAzC,IACxD+K,EAAArM,EAAAxL,IAAAwzB,EAAAC,EAEA,OADAlmB,GAAAoG,MAAAgE,wBAAA1b,KAAAu3B,EAAA1mB,GACAZ,EAAA7D,SAAAC,GAAAvF,IAAA8U,IAeA+Y,EAAAlsB,UAAAmZ,YAAA,SAAAta,EAAAia,EAAA1Q,GACA,GAAA3K,GAAAlG,IACA,UAAAuhB,IAAiCA,MACjC,SAAA1Q,IAAkCA,KAClC,IAAAomB,GAAAj3B,KAAAg3B,oBAAA1vB,EACAgK,GAAAoG,MAAAyE,uBAAA5M,EAAA5J,KAAA3F,KAAA02B,OAAApvB,EAAA1G,OAAAU,KAAA21B,GAAA1nB,EAAAnN,QAAwHka,KAAA,SAAgBzL,GACxI,IAAA4mB,GAAA,SAAAzb,GAAiD,MAAAA,GAAAwS,IAAAtoB,EAAA2K,IACjD6mB,EAAAnoB,EAAAxL,IAAAkzB,EAAAQ,EACA,OAAAxnB,GAAA7D,SAAAC,GAAAvF,IAAA4wB,GAAA/mB,KAAA,WACA,IACA,MAAAzK,GAAAwb,UAAApa,EAAAia,EAAA1Q,GAEA,MAAA6B,GACA,MAAAzC,GAAA7D,SAAAC,GAAAqE,OAAAgC,OAkBAiiB,EAAAlsB,UAAAiZ,UAAA,SAAApa,EAAAia,EAAA1Q,GACA,SAAAA,IAAkCA,KAClC,IAAAomB,GAAAj3B,KAAAg3B,oBAAA1vB,EACAgK,GAAAoG,MAAAyE,uBAAA5M,EAAA5J,KAAA3F,KAAA02B,OAAApvB,EAAA1G,OAAAU,KAAA21B,GAAA1nB,EAAAnN,QAAwHka,KAAA,SAAgBzL,GACxI,IAAA8mB,GAAApoB,EAAAxL,IAAAkzB,EAAAvzB,EAAAM,KAAA,QACA,OAAAiM,GAAA7D,SAAAE,UAAAjB,OAAA/D,EAAAuJ,EAAAnP,MAAA,KAAA6N,EAAAnN,UAAqGmf,EAAAoW,KAErGhD,IAEAt2B,GAAAs2B,kBAoBA,SAAAv2B,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACAw2B,EAAA,WACA,QAAAA,GAAA8C,EAAA/X,GACA7f,KAAA43B,kBACA53B,KAAA6f,SAgBA,MAbAiV,GAAArsB,UAAAmZ,YAAA,SAAAiW,EAAAtW,GACA,MAAAvhB,MAAA43B,gBAAAhW,YAAAiW,EAAAtW,IAGAuT,EAAArsB,UAAAiZ,UAAA,SAAAmW,EAAAtW,GACA,MAAAvhB,MAAA43B,gBAAAlW,UAAA,KAAAmW,EAAAtW,IAGAuT,EAAArsB,UAAAsW,UAAA,SAAA8Y,GACA,GAAA3xB,GAAAlG,KACA0V,EAAA,SAAA0H,GAAqC,MAAAA,GAAAoR,IAAAtoB,EAAA0xB,iBACrC,OAAAroB,GAAAxL,IAAA/D,KAAA43B,gBAAAZ,oBAAAa,GAAAniB,IAEAof,IAEAz2B,GAAAy2B,mBAKA,SAAA12B,EAAAC,EAAAC,GAEA,YACA,IAAAkR,GAAAlR,EAAA,IACAw5B,EAAAx5B,EAAA,GAOAD,GAAAs0B,kBACApmB,UAAA,EACA8f,SAAA,KACA/jB,SAAA,EACAiqB,QAAA,EACA1c,QAAA,EACAkiB,UACAjqB,QAAA,WAA2B,aAQ3B,IAAAkqB,GAAA,WACA,QAAAA,GAAA9kB,GACAlT,KAAAkT,QACAlT,KAAAi4B,qBAAA,SAAA5gB,GACAA,YAAAxS,QACA4V,QAAA/H,MAAA2E,IAGAygB,EAAAnlB,aAAAC,MAAA,GAAAklB,GAAAnlB,aAAA3S,MAiBA,MAfAg4B,GAAAvvB,UAAAsjB,oBAAA,SAAAmM,GACA,MAAAl4B,MAAAi4B,qBAAAC,GAAAl4B,KAAAi4B,sBAWAD,EAAAvvB,UAAAyqB,OAAA,SAAAnhB,EAAAC,GACA,UAAAxC,GAAAK,WAAAkC,EAAAC,EAAAhS,OAEAg4B,IAEA35B,GAAA25B,qBAKA,SAAA55B,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,KACAoC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YAUA,SAAA65B,GAAApP,EAAAhC,GACA,GAAAqR,IAAA,OAAA/zB,EAAA0kB,EAAAta,QAAA,wBAAiF,OACjF,KAAAsY,EACA,MAAA1iB,EACA,QAAA0iB,EAAA1B,QACA,OACA+S,GAAA,SAAArR,EAAA3B,WAAA,QACA,MACA,QACA/gB,IAAAoK,QAAA,UACA2pB,GAAA,gBACA,MACA,SACAA,GAAA,IAAArR,EAAA1B,OAAA,UAGA,MAAAhhB,GAAA+zB,EAAA,GAAArR,EAAA3W,KAAA7E,QAAA6V,OAAAgX,EAAA,GAxBA,GAAA7oB,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,IACA+5B,EAAA/5B,EAAA,GACA6yB,EAAA7yB,EAAA,IACA8yB,EAAA9yB,EAAA,GACA+yB,EAAA/yB,EAAA,GAmBAg6B,EAAA,SAAA95B,EAAAwF,EAAAsD,GAA2C,MAAA9I,GAAAwF,GAAAxF,EAAAwF,IAAAsD,KAwD3CixB,EAAA,WACA,QAAAA,GAAAhtB,EAAA1L,GACA,GAAAqG,GAAAlG,IACAA,MAAAuL,UACAvL,KAAAH,SACAG,KAAAw4B,QAAwB51B,QAAA2I,QAAA,MACxBvL,KAAAy4B,aACAz4B,KAAAksB,WACAlsB,KAAA04B,aACA14B,KAAA24B,aACA34B,KAAAH,OAAA0P,EAAA5N,SAAA3B,KAAAH,QACA8T,UACAilB,QAAA,EACAtR,iBAAA,EACA9D,SAAAjU,EAAAhJ,UAsCA,KAvBA,GAAiOhG,GAsBjOE,EAAAo4B,EAtBAC,EAAA,wFAAgHC,EAAA,4FAAiHlC,EAAA,EAAAmC,KACjOC,EAAA,SAAA74B,GACA,IAAAm4B,EAAAW,cAAAC,KAAA/4B,GACA,SAAAyE,OAAA,2BAAAzE,EAAA,iBAAAmL,EAAA,IACA,IAAAgE,EAAA9K,KAAAyB,EAAAgmB,QAAAxoB,EAAA+H,OAAA,KAAArL,IACA,SAAAyE,OAAA,6BAAAzE,EAAA,iBAAAmL,EAAA,MAIA6tB,EAAA,SAAA74B,EAAAmjB,GAEA,GAAAtjB,GAAAG,EAAA,IAAAA,EAAA,GAAA84B,EAAA3V,EAAAnjB,EAAA,GAAAA,EAAA,WAAAA,EAAA,aACA,QACAH,KACAi5B,SACA7U,IAAAte,EAAArG,OAAA8T,OAAAvT,GACAy4B,QAAAttB,EAAAsX,UAAAgU,EAAAt2B,EAAA+4B,OACAlpB,KAAAipB,EAAA9nB,EAAAuT,WAAA1U,KAAAipB,GAAA,WAAA9pB,EAAAjH,QAAAiJ,EAAAuT,WAAA1U,KAAA,WACA7E,QAAA,GAAAguB,QAAAF,EAAAnzB,EAAArG,OAAAynB,gBAAA,IAAA1hB,UADA,QAMArF,EAAAu4B,EAAAlS,KAAArb,MACA9K,EAAA24B,EAAA74B,GAAA,KACAE,EAAAo4B,QAAAhwB,QAAA,WAEAowB,EAAAx4B,EAAAL,IACAJ,KAAAksB,QAAAppB,KAAAyO,EAAAiF,MAAAzE,SAAAtR,EAAAL,GAAAK,EAAA2P,KAAApQ,KAAAH,OAAA2jB,SAAA/iB,EAAA+jB,KAAA,KACAxkB,KAAA04B,UAAA51B,KAAArC,EAAAo4B,SACAG,EAAAl2B,MAAArC,EAAAo4B,QAAAtpB,EAAA5J,KAAA3F,KAAAksB,WACA2K,EAAAiC,EAAAU,SAEAX,GAAAttB,EAAAsX,UAAAgU,EAEA,IAAA3zB,GAAA21B,EAAAhwB,QAAA,IACA,IAAA3F,GAAA,GACA,GAAAu2B,GAAAZ,EAAAhW,UAAA3f,EAEA,IADA21B,IAAAhW,UAAA,EAAA3f,GACAu2B,EAAAz3B,OAAA,EAEA,IADA60B,EAAA,EACAt2B,EAAAw4B,EAAAnS,KAAA6S,IACAh5B,EAAA24B,EAAA74B,GAAA,GACA04B,EAAAx4B,EAAAL,IACAJ,KAAAksB,QAAAppB,KAAAyO,EAAAiF,MAAAsQ,WAAArmB,EAAAL,GAAAK,EAAA2P,KAAApQ,KAAAH,OAAA2jB,SAAA/iB,EAAA+jB,KAAA,KACAqS,EAAAiC,EAAAU,UAIAx5B,KAAA04B,UAAA51B,KAAA+1B,GACAtpB,EAAAnN,OAAApC,MACA24B,UAAAK,EAAAj1B,IAAA,SAAAwH,GAAyD,MAAA4sB,GAAAj2B,MAAA,KAAAqJ,KAA2CpJ,OAAAg2B,EAAAU,IACpGa,OAAA15B,KAAA04B,UAAA,KAEA93B,OAAA+4B,OAAA35B,MA0PA,MA3OAu4B,GAAA9vB,UAAAqb,OAAA,SAAAnB,GAIA,MAHA3iB,MAAAy4B,UAAA31B,KAAA6f,GACApT,EAAA9N,QAAAkhB,EAAA6V,OAAA,SAAA1uB,EAAAtH,GAA2D,MAAAmgB,GAAA6V,OAAAh2B,GAAA2B,EAAAC,QAAA0F,MAAA,OAC3D6Y,EAAA6V,OAAA51B,KAAA5C,KAAAw4B,OAAA51B,KAAAT,OAAAnC,MACA2iB,GAEA4V,EAAA9vB,UAAAwa,OAAA,WACA,WAAAjjB,KAAAw4B,OAAA51B,KAAAZ;EAEAu2B,EAAA9vB,UAAAtB,SAAA,WACA,MAAAnH,MAAAuL,SA4BAgtB,EAAA9vB,UAAAme,KAAA,SAAAhkB,EAAA62B,EAAA5Q,EAAAhY,GAkBA,QAAA+oB,GAAA7Q,GACA,GAAA8Q,GAAA,SAAAzrB,GAAiD,MAAAA,GAAA1C,MAAA,IAAAT,UAAAkC,KAAA,KACjD2sB,EAAA,SAAA1rB,GAAiD,MAAAA,GAAAK,QAAA,aACjD/C,EAAAmuB,EAAA9Q,GAAArd,MAAA,WACAquB,EAAAxqB,EAAAxL,IAAA2H,EAAAmuB,EACA,OAAAtqB,GAAAxL,IAAAg2B,EAAAD,GAAA7uB,UAtBA,GAAA/E,GAAAlG,IACA,UAAAy5B,IAAiCA,MACjC,SAAA5oB,IAAkCA,KAClC,IAAA5B,GAAAqpB,EAAAt4B,KAAAw4B,OAAA,qBACA,UAAAe,SACA,IACAhqB,EAAA9F,OAAAvD,EAAAsyB,OAAA51B,KAAAT,OAAA+D,GAAAnC,IAAAL,EAAAM,KAAA,eAAAmJ,KAAA,IACAjH,EAAArG,OAAA+4B,UAAA,UACA,KACAzrB,KAAA,IAAAjH,EAAArG,OAAAynB,gBAAA,IAAA1hB,UACUghB,KAAAhkB,EACV,KAAAqM,EACA,WAEA,IAAA+qB,GAAAh6B,KAAAsY,aAAA2hB,EAAAD,EAAAz4B,OAAA,SAAAwlB,GAA4F,OAAAA,EAAArD,aAA4BwW,EAAAF,EAAAz4B,OAAA,SAAAwlB,GAAqD,MAAAA,GAAArD,aAA2ByW,EAAAn6B,KAAAw4B,OAAA51B,KAAAT,OAAAnC,MAAA+D,IAAA,SAAAq2B,GAAsE,MAAAA,GAAA1B,UAAA12B,OAAA,IAAoCiD,OAAA,SAAAjC,EAAAuB,GAA0B,MAAAvB,GAAAuB,IAAgB4E,IAC5V,IAAAgxB,IAAAlrB,EAAAjN,OAAA,EACA,SAAA6C,OAAA,sCAAA7E,KAAAuL,QAAA,IAQA,QAAArI,GAAA,EAAwBA,EAAAi3B,EAAmBj3B,IAAA,CAI3C,OAHA6jB,GAAAkT,EAAA/2B,GACApC,EAAAmO,EAAA/L,EAAA,GAEAsnB,EAAA,EAA4BA,EAAAzD,EAAAtY,QAAAzM,OAA0BwoB,IACtDzD,EAAAtY,QAAA+b,GAAAtpB,OAAAJ,IACAA,EAAAimB,EAAAtY,QAAA+b,GAAArpB,GAEAL,IAAAimB,EAAAne,SAAA,IACA9H,EAAA84B,EAAA94B,IACAu3B,EAAAluB,UAAArJ,KACAA,EAAAimB,EAAA3W,KAAAiY,OAAAvnB,IACAqI,EAAA4d,EAAA3mB,IAAA2mB,EAAAjmB,SAcA,MAZAyO,GAAA9N,QAAAy4B,EAAA,SAAAnT,GAEA,OADAjmB,GAAA24B,EAAA1S,EAAA3mB,IACAoqB,EAAA,EAA4BA,EAAAzD,EAAAtY,QAAAzM,OAA0BwoB,IACtDzD,EAAAtY,QAAA+b,GAAAtpB,OAAAJ,IACAA,EAAAimB,EAAAtY,QAAA+b,GAAArpB,GAEAk3B,GAAAluB,UAAArJ,KACAA,EAAAimB,EAAA3W,KAAAiY,OAAAvnB,IACAqI,EAAA4d,EAAA3mB,IAAA2mB,EAAAjmB,WAEA+nB,IACA1f,EAAA,KAAA0f,GACA1f,GAaAovB,EAAA9vB,UAAA6P,WAAA,SAAA1W,GAEA,MADA,UAAAA,IAA+BA,MAC/BA,EAAA0G,WAAA,EACAtI,KAAAksB,QACA3c,EAAA9F,OAAAzJ,KAAAw4B,OAAA51B,KAAAT,OAAAnC,MAAA+D,IAAAL,EAAAM,KAAA,cAEAu0B,EAAA9vB,UAAAkmB,UAAA,SAAAvuB,EAAAwB,GACA,SAAAA,IAA+BA,KAC/B,IAAA2G,GAAAgH,EAAA5J,KAAA3F,KAAAw4B,OAAA51B,KACA,OAAA2M,GAAA9K,KAAAzE,KAAAksB,QAAAxoB,EAAA+H,OAAA,KAAArL,KACAwB,EAAA0G,WAAA,GAAAC,KAAAomB,UAAAvuB,IACA,MAcAm4B,EAAA9vB,UAAA4P,UAAA,SAAA1E,GACA,GAAAzN,GAAAlG,KACAq6B,EAAA,SAAAtT,EAAAjd,GAAoD,OAAAid,KAAA1O,UAAAvO,GACpD,OAAAyF,GAAA5F,MAAAgK,OAA2C5P,IAAA,SAAA6R,GAC3C,GAAApT,GAAAoT,EAAA,GAAA9L,EAAA8L,EAAA,EACA,OAAAykB,GAAAn0B,EAAAyoB,UAAAnsB,GAAAsH,KACU7E,OAAAsK,EAAAnG,UAAA,IAqBVmvB,EAAA9vB,UAAA0G,OAAA,SAAAhG,GAcA,QAAAmxB,GAAAvT,GAEA,GAAAjmB,GAAAimB,EAAAjmB,MAAAqI,EAAA4d,EAAA3mB,KACA+lB,EAAAY,EAAAZ,eAAArlB,GAEAukB,IAAAc,GAAAY,EAAA1B,OAEAqB,EAAAK,EAAA3W,KAAAuW,OAAA7lB,EACA,QAAqBimB,QAAAjmB,QAAAqlB,iBAAAd,SAAAqB,WApBrB,GADA,SAAAvd,IAAiCA,OACjCnJ,KAAAqY,UAAAlP,GACA,WAEA,IAAAoxB,GAAAv6B,KAAAw4B,OAAA51B,KAAA+F,QAAAxG,OAAAnC,MAEAw6B,EAAAD,EAAAx2B,IAAAw0B,EAAAiC,uBAAAv1B,OAAAmsB,EAAA7nB,YAEAkxB,EAAAF,EAAAx2B,IAAAw0B,EAAAkC,aAAAx1B,OAAAmsB,EAAA7nB,YAgBAmxB,EAAAF,EAAAv1B,OAAA,SAAAykB,EAAAnlB,GAEA,GAAAJ,EAAAuB,SAAAnB,GACA,MAAAmlB,GAAAnlB,CAEA,IAAAqR,GAAA0kB,EAAA/1B,GAAA8gB,EAAAzP,EAAAyP,OAAAqB,EAAA9Q,EAAA8Q,QAAAK,EAAAnR,EAAAmR,KAEA,OAAA1B,MAAA,EACAqE,EAAAza,MAAA,OAAAya,EAAA/gB,MAAA,MAAA+gB,EAEAvlB,EAAAuB,SAAA2f,GACAqE,EAAArE,EACAA,KAAA,EACAqE,EACA,MAAAhD,EACAgD,EAEAvlB,EAAAC,QAAAsiB,GACAgD,EAAAna,EAAAxL,IAAA2iB,EAAA6R,EAAAoC,cAAAxtB,KAAA,KAEA4Z,EAAA3W,KAAAwqB,IACAlR,EAAAhD,EAEAgD,EAAAmR,mBAAAnU,IACU,IAGVoU,EAAAL,EAAA12B,IAAA,SAAAgjB,GACA,GAAAnR,GAAA0kB,EAAAvT,GAAA1B,EAAAzP,EAAAyP,OAAAqB,EAAA9Q,EAAA8Q,QAAAP,EAAAvQ,EAAAuQ,cACA,YAAAO,GAAAP,GAAAd,KAAA,KAEAlhB,EAAAC,QAAAsiB,KACAA,OACA,IAAAA,EAAA1kB,QAIA,MAFA+kB,GAAA3W,KAAAwqB,MACAlU,EAAAnX,EAAAxL,IAAA2iB,EAAAmU,qBACAnU,EAAA3iB,IAAA,SAAA+F,GAAgD,MAAAid,GAAA3mB,GAAA,IAAA0J,MACtCvI,OAAAgO,EAAAhJ,UAAAtB,OAAAmsB,EAAA7nB,YAAA4D,KAAA,IAEV,OAAAutB,IAAAI,EAAA,IAAAA,EAAA,KAAA3xB,EAAA,SAAAA,EAAA,UAEAovB,EAAAoC,aAAA,SAAAvsB,GACA,MAAAysB,oBAAAzsB,GAAAK,QAAA,cAAAjO,GAAoE,aAAAA,EAAAu6B,WAAA,GAAA5zB,SAAA,IAAA6zB,iBAGpEzC,EAAAiC,sBAAA,SAAAzX,GACA,GAAAkY,GAAAlY,EAAA2V,UACAuB,EAAAlX,EAAAmJ,QAAA3qB,OAAA,SAAAd,GAA+D,MAAAA,GAAA8L,WAAA4kB,EAAAlM,QAAA4B,MAC/D,OAAAwK,GAAAtsB,YAAAk2B,EAAAhB,EAAA93B,OAAAyD,SAAAX,OAAAmsB,EAAA7nB,YAAAhI,OAAA,SAAAgD,GAAqI,WAAAA,GAAA8zB,EAAAluB,UAAA5F,MAGrIg0B,EAAAkC,YAAA,SAAA1X,GACA,MAAAA,GAAAmJ,QAAA3qB,OAAA,SAAAd,GAAqD,MAAAA,GAAA8L,WAAA4kB,EAAAlM,QAAAe,UAErDuS,EAAAW,cAAA,4BACAX,IAEAl6B,GAAAk6B,cAKA,SAAAn6B,EAAAC,EAAAC,GAEA,YAMA,SAAA48B,KACA,OACAtC,OAAArnB,EAAAgU,cAAAgC,aACAD,gBAAA/V,EAAAgU,cAAA+B,mBAPA,GAAA/X,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,IACAoT,EAAApT,EAAA,IAaA68B,EAAA,WACA,QAAAA,KACA5rB,EAAAnN,OAAApC,MAAgCu4B,WAAAhnB,EAAAgnB,WAAA/hB,MAAA9E,EAAA8E,QA8HhC,MAtHA2kB,GAAA1yB,UAAA6e,gBAAA,SAAAxmB,GACA,MAAAyQ,GAAAgU,cAAA+B,gBAAAxmB,IAQAq6B,EAAA1yB,UAAA8e,WAAA,SAAAzmB,GACA,MAAAyQ,GAAAgU,cAAAgC,WAAAzmB,IAaAq6B,EAAA1yB,UAAA+c,oBAAA,SAAA1kB,GACA,MAAAyQ,GAAAgU,cAAAC,oBAAA1kB,IASAq6B,EAAA1yB,UAAA8a,QAAA,SAAAhY,EAAA1L,GACA,UAAA0R,GAAAgnB,WAAAhtB,EAAAgE,EAAAnN,OAAA84B,IAAAr7B,KASAs7B,EAAA1yB,UAAAmb,UAAA,SAAAha,GAEA,IAAAzF,EAAAoG,SAAAX,GACA,QACA,IAAAvF,IAAA,CAKA,OAJAkL,GAAA9N,QAAA8P,EAAAgnB,WAAA9vB,UAAA,SAAAqB,EAAAtI,GACA2C,EAAAW,WAAAgF,KACAzF,KAAAF,EAAAgG,UAAAP,EAAApI,KAAA2C,EAAAW,WAAA8E,EAAApI,OAEA6C,GAsDA82B,EAAA1yB,UAAA2H,KAAA,SAAA5O,EAAA+gB,EAAAuH,GACA,GAAA1Z,GAAAsB,EAAAoT,WAAA1U,KAAA5O,EAAA+gB,EAAAuH,EACA,OAAA3lB,GAAAgG,UAAAoY,GAAAviB,KAAAoQ,GAIA+qB,EAAA1yB,UAAA2yB,KAAA,WAGA,MAFA1pB,GAAAoT,WAAAtX,SAAA,EACAkE,EAAAoT,WAAAiF,kBACA/pB,MAGAm7B,IAEA98B,GAAA88B,qBAKA,SAAA/8B,EAAAC,EAAAC,GAEA,YAOA,SAAA+8B,GAAAC,GACA,GAAA5B,GAAA,kDAA6D9S,KAAA0U,EAAAla,OAC7D,cAAAsY,IAAA,GAAAjrB,QAAA,kBAGA,QAAA8sB,GAAAhwB,EAAA0D,GACA,MAAA1D,GAAAkD,QAAA,iBAA0C,SAAAlO,EAAAi7B,GAC1C,MAAAvsB,GAAA,MAAAusB,EAAA,EAAAvuB,OAAAuuB,MAGA,QAAAC,GAAAnvB,EAAA2jB,EAAAiI,EAAAjpB,GACA,IAAAA,EACA,QACA,IAAA5K,GAAAiI,EAAAjB,OAAA6sB,KAAsDlI,OAAA/gB,EAAAghB,gBACtD,QAAA9rB,EAAAgG,UAAA9F,MAEA,QAAAq3B,GAAA/Y,EAAAgZ,EAAAlI,GACA,GAAAmI,GAAA3rB,EAAA7D,SAAAI,eAAAovB,UACA,aAAAA,EACAjZ,EACAgZ,EACAC,EAAAjzB,MAAA,MAAAga,EACA8Q,EACAmI,EAAAjzB,MAAA,GAAAga,EACAA,EAGA,QAAAkJ,GAAAgQ,EAAAC,EAAAC,GAGA,QAAAC,GAAAC,GACA,GAAAC,GAAAD,EAAAhsB,EAAA7D,SAAAE,UAAA6vB,EACA,SAAAD,IAEA/3B,EAAAuB,SAAAw2B,KACAC,EAAA1tB,UACA0tB,EAAAxZ,IAAAuZ,KAEA,GAVA,IAAAH,MAAAK,iBAAA,CAYA,GAAAl5B,GAAAL,EAAAg5B,EAAA75B,MACA,KAAAkB,EAAA,EAAgBA,EAAAL,EAAOK,IACvB,GAAA84B,EAAAH,EAAA34B,IACA,MAGA44B,IACAE,EAAAF,IApDA,GAAAvsB,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACA2R,EAAA3R,EAAA,GACA69B,EAAAlsB,EAAA7D,SAAAG,SAmEA8vB,EAAA,WACA,QAAAA,GAAAC,EAAArM,GACAjwB,KAAAs8B,qBACAt8B,KAAAiwB,eAEAjwB,KAAA67B,SAEA77B,KAAA87B,YAAA,KAEA97B,KAAAu8B,mBAAA,EAwNA,MAvLAF,GAAA5zB,UAAAwzB,KAAA,SAAAA,GACA,IAAA93B,EAAAW,WAAAm3B,GACA,SAAAp3B,OAAA,4BAEA,OADA7E,MAAA67B,MAAA/4B,KAAAm5B,GACAj8B,MAkCAq8B,EAAA5zB,UAAA+zB,UAAA,SAAAP,GACA,IAAA93B,EAAAW,WAAAm3B,KAAA93B,EAAAuB,SAAAu2B,GACA,SAAAp3B,OAAA,sCAEA,OADA7E,MAAA87B,YAAA33B,EAAAuB,SAAAu2B,GAAA,WAAuE,MAAAA,IAAeA,EACtFj8B,MA0CAq8B,EAAA5zB,UAAA6T,KAAA,SAAAkf,EAAAtD,GACA,GACApjB,GADAc,EAAA5V,KAAAs8B,EAAA1mB,EAAA0mB,mBAAArM,EAAAra,EAAAqa,aACAwM,EAAAt4B,EAAAuB,SAAAwyB,EAIA,IAFA/zB,EAAAuB,SAAA81B,KACAA,EAAAc,EAAA/Y,QAAAiY,KACAiB,IAAAt4B,EAAAW,WAAAozB,KAAA/zB,EAAAC,QAAA8zB,GACA,SAAArzB,OAAA,8BACA,IAAA63B,IACA3Z,QAAA,SAAA4Z,EAAAC,GAKA,MAJAH,KACA3nB,EAAAwnB,EAAA/Y,QAAAqZ,GACAA,GAAA,SAAA9nB,EAAA3F,OAAAzN,KAAAoT,KAEAvF,EAAAnN,OAAA,WACA,MAAAq5B,GAAAxrB,EAAA7D,SAAAE,UAAA2jB,EAAA2M,EAAAD,EAAA/V,KAAAuV,EAAAv5B,OAAAu5B,EAAA1C,SAAA0C,EAAAtT,WAEA6Q,OAAAv1B,EAAAuB,SAAAi3B,EAAAjD,QAAAiD,EAAAjD,OAAA,MAGAmD,MAAA,SAAAF,EAAAC,GACA,GAAAD,EAAAG,QAAAH,EAAAI,OACA,SAAAl4B,OAAA,6CAKA,OAJA43B,KACA3nB,EAAA8nB,EACAA,GAAA,kBAAA5M,GAA8D,MAAAuL,GAAAzmB,EAAAkb,MAE9DzgB,EAAAnN,OAAA,WACA,MAAAq5B,GAAAxrB,EAAA7D,SAAAE,UAAA2jB,EAAA2M,EAAAD,EAAA/V,KAAAuV,EAAAv5B,WAEA82B,OAAA2B,EAAAsB,OAIAX,GACAjZ,QAAAuZ,EAAA1Y,UAAA4X,GACAqB,MAAArB,YAAAjC,QAEA,QAAA12B,KAAAm5B,GACA,GAAAA,EAAAn5B,GACA,MAAA7C,MAAAi8B,KAAAS,EAAA75B,GAAA24B,EAAAtD,GAEA,UAAArzB,OAAA,6BAmDAw3B,EAAA5zB,UAAAu0B,eAAA,SAAA7qB,GACAvM,SAAAuM,IACAA,GAAA,GACAnS,KAAAu8B,kBAAApqB,GAGAkqB,IAEAh+B,GAAAg+B,mBACA,IAAAY,GAAA,WACA,QAAAA,GAAAzM,GACAxwB,KAAAwwB,oBACAjhB,EAAAtO,cAAAg8B,EAAAx0B,UAAAzI,WA6FA,MAjEAi9B,GAAAx0B,UAAAqkB,KAAA,WACAjB,EAAA7rB,KAAAwwB,kBAAAqL,MAAA77B,KAAAwwB,kBAAAsL,cAEAmB,EAAAx0B,UAAAy0B,OAAA,WACA,GAAAh3B,GAAAlG,IACA,OAAAA,MAAAm9B,SAAAn9B,KAAAm9B,UAAAhB,EAAAiB,SAAA,SAAArB,GAAoF,MAAAlQ,GAAA3lB,EAAAsqB,kBAAAqL,MAAA31B,EAAAsqB,kBAAAsL,YAAAC,MAEpFkB,EAAAx0B,UAAAojB,OAAA,SAAAwR,GACA,MAAAA,QACAr9B,KAAAuM,SAAA4vB,EAAAxZ,YAGAwZ,EAAAxZ,QAAA3iB,KAAAuM,WAEA4vB,EAAAxZ,IAAA3iB,KAAAuM,UACA4vB,EAAA1tB,aAEAwuB,EAAAx0B,UAAA3F,KAAA,SAAAw6B,EAAA3pB,EAAA9C,GACAsrB,EAAAxZ,IAAA2a,EAAAnuB,OAAAwE,QACA9C,KAAApC,SACA0tB,EAAA1tB,WA2BAwuB,EAAAx0B,UAAA6qB,KAAA,SAAAgK,EAAA3pB,EAAA9C,GACA,IAAAysB,EAAAjlB,UAAA1E,GACA,WACA,IAAAgP,GAAA2a,EAAAnuB,OAAAwE,EACA9C,QACA,IAAA2T,GAAAvU,EAAA7D,SAAAI,eACAmvB,EAAAnX,EAAA+Y,WAKA,IAJA5B,GAAA,OAAAhZ,IACAA,EAAA,IAAA6B,EAAAgZ,aAAA7a,GAEAA,EAAA+Y,EAAA/Y,EAAAgZ,EAAA9qB,EAAA4iB,WACA5iB,EAAA4iB,WAAA9Q,EACA,MAAAA,EAEA,IAAA8a,IAAA9B,GAAAhZ,EAAA,OAAA+a,EAAAlZ,EAAAkZ,MAEA,OADAA,GAAA,KAAAA,GAAA,MAAAA,EAAA,OAAAA,GACAlZ,EAAAmZ,WAAA,MAAAnZ,EAAAoZ,OAAAF,EAAAD,EAAA9a,GAAAxV,KAAA,KAEA8vB,IAEA5+B,GAAA4+B,aAKA,SAAA7+B,EAAAC,EAAAC,GAEA,YACA,SAAAoC,GAAAH,GACA,OAAAE,KAAAF,GAAAlC,EAAAsC,eAAAF,KAAApC,EAAAoC,GAAAF,EAAAE,IAGAC,EAAApC,EAAA,MAKA,SAAAF,EAAAC,EAAAC,GAEA,YAEA,IAAAiR,GAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,GAWAu/B,EAAA,WACA,QAAAA,KACA,GAAA33B,GAAAlG,IACAA,MAAA89B,WACA99B,KAAA+zB,eACA/zB,KAAA+9B,wBACA/9B,KAAA8sB,KAAA,WA6EA,QAAAkR,GAAAC,GACA,MAAAA,GAAAjlB,IAAAtN,MAAA,KAAA1J,OAGA,QAAAk8B,GAAAr+B,GAEA,IADA,GAAAib,GAAAjb,EAAAyZ,SAAAC,SAAA4kB,EAAA,IACAA,GAAArjB,EAAAvS,QACAuS,IAAAvS,MACA,OAAA41B,GApFA,GAAAC,GAAAl4B,EAAA43B,QAAA/5B,IAAA,SAAAs6B,GAAkE,OAAAA,EAAArlB,IAAAqlB,KAAyBp5B,OAAAsK,EAAAhK,eAwD3FsH,EAAA,SAAAoxB,GAA8C,gBAAA5kB,GAE9C,GAAA4kB,EAAAK,QAAAjlB,EAAAC,SAAAglB,MACA,QAEA,IAAAC,GAAAllB,EAAAC,SACAklB,EAAAD,EAAA/kB,YAAA9N,MAAA,KACA+yB,EAAAR,EAAAjlB,IAAAtN,MAAA,IAGA,KAAA6D,EAAApH,OAAAq2B,EAAAC,EAAA91B,MAAA,EAAA61B,EAAAx8B,SACA,QAGA,IAAA08B,GAAA,EAAAF,EAAAx8B,QAAA4D,OACA+4B,EAAAF,EAAA91B,MAAA,EAAA+1B,GAAAvxB,KAAA,KACAyxB,EAAAR,EAAAO,GAAA5lB,eACA,OAAAwlB,GAAA9kB,wBAAAmlB,KAAAp9B,QAcAq9B,EAAAn7B,EAAAqF,MAAA,SAAA+1B,EAAAC,EAAA9W,EAAAC,GAAqF,MAAA6W,IAAAD,EAAA7W,GAAA6W,EAAA5W,MACrF8W,EAAA,SAAAf,GACA,GAAAgB,GAAA/4B,EAAA6tB,YAAAxyB,OAAAsL,EAAAoxB,GAGA,OAFAgB,GAAAj9B,OAAA,GACAi9B,EAAA3f,KAAAuf,EAAAX,QACAD,EAAAgB,EAAA,KAEAC,EAAA,SAAAtpB,GACA,GAAAqoB,GAAAroB,EAAA,GAAAyD,EAAAzD,EAAA,EAGA1P,GAAA43B,QAAAj1B,QAAAo1B,SACAA,EAAAkB,cAAA9lB,GAEAnT,GAAA43B,QAAAxe,KAAAuf,EAAAb,EAAA,IAAAj6B,IAAAi7B,GAAAv9B,QAAAy9B,IAgHA,MA7GArB,GAAAp1B,UAAA22B,YAAA,SAAAtkB,GACA,MAAA9a,MAAAq/B,aAAAvkB,GAAA9a,KAAAq/B,cAGAxB,EAAAp1B,UAAA62B,kBAAA,SAAAC,EAAAx/B,GACAC,KAAA+9B,qBAAAwB,GAAAx/B,GAEA89B,EAAAp1B,UAAAurB,iBAAA,SAAA1f,EAAAkrB,GACA,GAAAC,GAAAz/B,KAAA+9B,qBAAAyB,EAAAlB,MACA,KAAAmB,EACA,SAAA56B,OAAA,2DAAA26B,EAAAlB,MACA,IAAAoB,GAAAD,EAAAnrB,EAAAkrB,EACA,OAAAr7B,GAAAC,QAAAs7B,UAOA7B,EAAAp1B,UAAAmkB,qBAAA,SAAAvT,GACA9H,EAAAmG,MAAAqF,sBAAA,cAAA1D,GACA9J,EAAAzG,WAAA9I,KAAA+zB,YAAA1a,IAGAwkB,EAAAp1B,UAAAokB,mBAAA,SAAAxT,GACA9H,EAAAmG,MAAAqF,sBAAA,iBAAA1D,GACArZ,KAAA+zB,YAAAjxB,KAAAuW,IAYAwkB,EAAAp1B,UAAAk3B,eAAA,SAAA1B,GACA1sB,EAAAmG,MAAAuF,4BAAA,iBAAAghB,EACA,IAAAH,GAAA99B,KAAA89B,QACA8B,EAAA,SAAAvB,GAA0C,MAAAA,GAAArlB,MAAAilB,EAAAjlB,IAK1C,OAJA8kB,GAAAv8B,OAAAq+B,GAAA59B,QACAuP,EAAAmG,MAAAuF,4BAAA,+BAAAghB,GACAH,EAAAh7B,KAAAm7B,GACAj+B,KAAA8sB,OACA,WACA,GAAAxnB,GAAAw4B,EAAAj1B,QAAAo1B,EACA,OAAA34B,IAAA,MACAiM,GAAAmG,MAAAuF,4BAAA,uCAAAghB,IAGA1sB,EAAAmG,MAAAuF,4BAAA,mBAAAghB,OACA1uB,GAAAzG,WAAAg1B,GAAAG,MASAJ,EAAAp1B,UAAAo3B,UAAA,WACA,MAAA7/B,MAAA89B,QAAA/5B,IAAAL,EAAAM,KAAA,SAOA65B,EAAAp1B,UAAAq3B,OAAA,WACA,MAAA9/B,MAAA89B,QAAAv8B,OAAAmC,EAAAM,KAAA,YAAAD,IAAAL,EAAAM,KAAA,UAUA65B,EAAAkC,sBAAA,SAAAjlB,EAAAklB,GACA,SAAAA,IAAsCA,EAAA,GAItC,IAAAC,GAAAD,EAAAt0B,MAAA,KACAw0B,EAAAD,EAAA,eACAE,EAAAh8B,EAAAuB,SAAAu6B,EAAA,IAAAA,EAAA,OAGAG,EAAA,wBAAAxZ,KAAAsZ,EACAE,KAEAD,EAAAC,EAAA,GACAF,EAAAE,EAAA,IAEA,MAAAF,EAAAtd,OAAA,KACAsd,IAAA7xB,OAAA,GACA8xB,EAAA,GAGA,IAAAE,GAAA,iBACA,IAAAA,EAAAzZ,KAAAuZ,GAAA,CACA,GAAAG,GAAAH,EAAAz0B,MAAA,KAAAzG,OAAA,SAAAq7B,EAAA/7B,GAAuF,MAAA+7B,GAAA/3B,QAAwBuS,EAC/GqlB,GAAAG,EAAA9+B,KAEA,OAAiB0+B,aAAAC,wBAEjBtC,IAEAx/B,GAAAw/B,eAKA,SAAAz/B,EAAAC,EAAAC,GAEA,YAEA,IAAAiiC,GAAAjiC,EAAA,IACA0yB,EAAA1yB,EAAA,GACAiR,EAAAjR,EAAA,GAOAkiC,EAAA,WACA,QAAAA,GAAAC,GACA,GAAAv6B,GAAAlG,IAMAA,MAAA2T,OAAA,GAAA4sB,GAAAvW,YAMAhqB,KAAAyrB,kBAAA,GAAAuF,GAAA3jB,SAAA,GAMArN,KAAA8yB,sBAAA,GAAA9B,GAAA3jB,SAAA,EACA,IAAAqzB,GAAA,SAAAlT,GACAtnB,EAAA4Q,WAAA0W,EACAtnB,EAAAulB,kBAAAje,QAAAggB,EACA,IAAAmT,GAAA,WACAz6B,EAAA4sB,sBAAAtlB,QAAAggB,GACAtnB,EAAAikB,SAAAqD,EAAAja,MACArN,EAAA4H,QAAA5H,EAAAikB,SAAA3W,KACAjE,EAAArH,KAAAslB,EAAA7Z,SAAAzN,EAAAyN,QAEA6Z,GAAAtM,aAAsCyf,GAAsBnjB,SAAA,KAC5D,IAAAojB,GAAA,WAAuD16B,EAAA4Q,aAAA0W,IACvDtnB,EAAA4Q,WAAA,MACA0W,GAAApb,QAAAzB,KAAAiwB,KAEAH,GAAA7f,aAAsC,eAAA8f,IAEtC,MAAAF,KAEAniC,GAAAmiC,mBAKA,SAAApiC,EAAAC,EAAAC,GAEA,YAEA,IAAAuiC,GAAAviC,EAAA,IACAwiC,EAAAxiC,EAAA,IACAyiC,EAAAziC,EAAA,IACA0iC,EAAA1iC,EAAA,IACA2yB,EAAA3yB,EAAA,IACA2iC,EAAA3iC,EAAA,IACA4iC,EAAA5iC,EAAA,IACA6iC,EAAA7iC,EAAA,IACA8iC,EAAA9iC,EAAA,IAUA0C,EAAA,WACA,QAAAA,KACAhB,KAAAqhC,YAAA,GAAAJ,GAAApD,YACA79B,KAAAygC,kBAAA,GAAAxP,GAAA+G,kBAAAh4B,KAAAqhC,aACArhC,KAAA+qB,QAAA,GAAAqW,GAAAZ,gBAAAxgC,KAAAygC,mBACAzgC,KAAAuwB,kBAAA,GAAAsQ,GAAA1F,kBACAn7B,KAAAwwB,kBAAA,GAAAsQ,GAAAzE,kBAAAr8B,KAAAuwB,kBAAAvwB,KAAA+qB,QAAApX,QACA3T,KAAAshC,UAAA,GAAAN,GAAA/D,UAAAj9B,KAAAwwB,mBACAxwB,KAAAmiB,cAAA,GAAA+e,GAAA5Q,cAAAtwB,KAAAuwB,kBAAAvwB,KAAAwwB,mBAEAxwB,KAAAuxB,cAAA,GAAAwP,GAAA7e,cAAAliB,KAAAmiB,eACAniB,KAAAuhC,aAAA,GAAAJ,GAAA7P,aAAAtxB,KAAAqhC,YAAArhC,KAAAshC,UAAAthC,KAAAygC,kBAAAzgC,KAAAmiB,cAAAniB,KAAAuxB,cAAAvxB,KAAA+qB,SACA/qB,KAAAqhC,YAAAjC,YAAAp/B,KAAAmiB,cAAAriB,QACAE,KAAA+qB,QAAAZ,SAAAnqB,KAAAmiB,cAAAriB,OACAE,KAAA+qB,QAAAjd,QAAA9N,KAAA+qB,QAAAZ,SAAA3W,KAEA,MAAAxS,KAEA3C,GAAA2C,YAKA,SAAA5C,EAAAC,EAAAC,GAYA,YA0GA,SAAAkjC,GAAAC,GACA,GAAAn1B,GAAA2D,EAAA7D,SAAAE,UACAo1B,EAAAp1B,EAAAkiB,IAAA,eACAmT,EAAAr1B,EAAAs1B,WACA,KACA,GAAAC,EAMA,OALAv1B,GAAAs1B,YAAA,SAAAE,GACAx1B,EAAAs1B,YAAAD,EACAE,EAAAv1B,EAAA2hB,SAAA6T,IAEAJ,EAAAD,GAA4CM,YAC5CF,EAEA,QACAv1B,EAAAs1B,YAAAD,GAKA,QAAAK,GAAA11B,EAAAD,GACA4D,EAAA7D,SAAAE,YACA2D,EAAA7D,SAAAC,KAMA,QAAA41B,GAAAC,GAiBA,QAAA9G,GAAAe,EAAAgG,EAAAC,EAAAC,EAAAC,EAAAC,GAkBA,MAhBAF,GAAAG,IAAA,kCAAAzG,GAAkE,MAAA0G,GAAAhhC,QAAA,SAAA6F,GAA4C,MAAAA,GAAAy0B,OAE9G9rB,EAAA7D,SAAAI,eAAA+wB,UAAA,WACA,GAAAA,GAAA2E,EAAA3E,WAEA,OADAA,GAAAp5B,EAAAoG,SAAAgzB,KAAAzjB,QAAAyjB,EACAA,GAAA6E,EAAAM,SAEAzyB,EAAA7D,SAAAK,SAAA+hB,IAAA,SAAA7L,GACA,MAAA2f,GAAA9T,IAAA7L,GAAoCggB,MAAAJ,EAAAK,SAAkCC,OAAA,eAAwBlyB,KAAAjN,EAAAM,KAAA,UAG9FuL,EAAAtO,cAAAk7B,EAAAlsB,EAAA7D,SAAAG,SAAA4vB,GAAA,yCAEA5sB,EAAAtO,cAAAk7B,EAAAlsB,EAAA7D,SAAAI,eAAA2vB,GAAA,2BAEA5sB,EAAAtO,cAAAkhC,EAAAlyB,EAAA7D,SAAAI,eAAA21B,GAAA,aACAW,EAjCAA,EAAA,GAAA/hC,GAAAC,SAEA8hC,EAAA3gB,cAAAE,UAAA,QAAA0gB,EAAAC,iBACAF,EAAA3gB,cAAAE,UAAA,UAAA4gB,EAAAC,mBACAJ,EAAAzB,YAAA/B,kBAAA,MAAAyD,EAAAI,sBAEA5zB,EAAAtO,cAAAihC,EAAAjyB,EAAA7D,SAAAI,eAAA01B,GAAA,cAEA,IAAAO,KACAxyB,GAAA7D,SAAAG,SAAA6wB,SAAA,SAAAn5B,GAEA,MADAw+B,GAAA3/B,KAAAmB,GACA,WAA6B,MAAAsL,GAAAzG,WAAA25B,GAAAx+B,KAE7BjE,KAAAo7B,OACAA,EAAAtN,SAAA,yEAuDA,QAAAsV,KAOA,MANAN,GAAAtS,kBAAA,gBAIA,MAHAsS,GAAAxB,UAAAzV,QAAA,GACA7rB,KAAAu8B,mBACAuG,EAAAxB,UAAApE,SACA4F,EAAAxB,WAEAwB,EAAAtS,kBAMA,QAAA6S,KAMA,MALAP,GAAAvR,cAAA,gBAGA,MADAuR,GAAA3gB,cAAAsO,WAAAV,UAAA+S,EAAAvB,cACAuB,EAAAvB,cAEAuB,EAAAvR,cASA,QAAA+R,KAEA,QAAAC,GAAA/V,GACA,GAAAgW,GAAA,SAAAjF,GAQA,QAAAkF,MAPA,GAAAnvB,GAAA/E,EAAA9K,KAAA+oB,EAAAnb,cAAAlR,GAAAuC,EAAA+H,OAAA,QAAA8yB,EAAAjlB,SAAAC,UAEA,KAAAjF,EACA,MAAArE,GAAA7D,SAAAC,GAAAiQ,MACA,IAAAonB,GAAApvB,EAAAR,eACA6vB,EAAAnC,EAAAjD,EAAAqF,YACA3M,EAAAyM,EAAA3vB,gBAIA,OAFA0vB,GAAA3V,QAAA6V,EAAApiC,OAAA,SAAAsiC,GAAmF,MAAA5M,GAAAt2B,eAAAkjC,KAEnFH,EAAA9hB,YAAA6hB,GACA9yB,KAAA,WAAoC,MAAA4tB,GAAAhd,OAAAhS,EAAAxL,IAAAkzB,EAAA,SAAAjjB,GAA8D,MAAAA,GAAAC,UAElG6vB,EAAAtW,EAAA3Y,MAAA,YAAAtT,OAAA,SAAAg9B,GAAkF,QAAAA,EAAAqF,aAA0B7/B,IAAAy/B,EAC5G,OAAAvzB,GAAA7D,SAAAC,GAAAvF,IAAAg9B,GAAAnzB,KAAApB,EAAAnH,MAIA,MArBAm7B,GAAAzV,SAAA,gBAmBAgV,EAAArC,kBAAAxf,YAAyCsiB,GACzCT,EAAArC,kBAAA,gBAAqD,MAAAqC,GAAArC,mBACrDqC,EAAArC,kBAYA,QAAAsD,GAAA1B,GACAA,EAAA2B,OAAA,WAAoC1yB,EAAAoG,MAAAkC,uBAzQpC,GAAA7Y,GAAAzC,EAAA,IACA2R,EAAA3R,EAAA,GACAiR,EAAAjR,EAAA,GACAoF,EAAApF,EAAA,GACA6F,EAAA7F,EAAA,GACAiT,EAAAjT,EAAA,IACAoT,EAAApT,EAAA,IACAqT,EAAArT,EAAA,IACAgT,EAAAhT,EAAA,IACAykC,EAAAzkC,EAAA,IACA2lC,EAAA3lC,EAAA,IACA2kC,EAAA3kC,EAAA,IAEA4lC,EAAAt8B,QAAAxJ,OAAA,wBAYAwJ,SAAAxJ,OAAA,0CAaAwJ,QAAAxJ,OAAA,uCAeAwJ,QAAAxJ,OAAA,8EAqCAwJ,QAAAxJ,OAAA,uEACAwJ,QAAAxJ,OAAA,kCA8BAC,EAAAmjC,qBACAQ,EAAAlU,SAAA,kBAKAoW,EAAAntB,IAAAirB,EACA,IAAAc,GAAA,IACAb,GAAAnU,SAAA,oBAwCA,IAAAqW,GAAA,WAAmC,OAOnCzuB,QAAA,SAAA0uB,EAAA7iB,EAAAhZ,GACA,SAAAgZ,IAAiCA,KACjC,IAAA8iB,GAAA,GAAA9yB,GAAA+D,KAAA,GAAA3D,GAAA8c,OAAgE9a,aAChEW,EAAA,GAAA/C,GAAA+D,KAAA,GAAA3D,GAAA8c,OAA0D9a,aAC1DmH,EAAA,GAAApJ,GAAAijB,gBAAA0P,EAAA/vB,GACAwG,GAAAvG,eAAA7C,EAAA5B,WAAA0E,gBAAA4vB,GAAA9vB,EAAAhB,MACA,IAAAgxB,GAAA,SAAAC,GACA,GAAAC,GAAA,SAAAC,GAA8C,MAAA/yB,GAAA5B,WAAA0E,gBAAAjF,EAAAxL,IAAA0gC,EAAA,SAAAC,GAAoF,kBAAqB,MAAAA,OAGvJ,OAFA5pB,GAAAvG,eAAAiwB,EAAAD,GAAAF,EAAA/wB,OACAwH,EAAAvG,eAAAiwB,EAAAjjB,GAAAjN,EAAAhB,OACAwH,EAAA2S,cAEA,OAAAllB,KAAAoI,KAAA2zB,WAOA18B,SAAAxJ,OAAA,qBAAAumC,SAAA,cAAA1C,GAEAr6B,QAAAxJ,OAAA,kBAAA2Y,KAAA,uBAAAkrB,OAEAr6B,QAAAxJ,OAAA,kBAAAumC,SAAA,uDAAsG,MAAA7B,GAAAvS,qBACtG3oB,QAAAxJ,OAAA,kBAAA2Y,KAAA,8BAAAulB,OAWA10B,QAAAxJ,OAAA,oBAAAumC,SAAA,oCAAAvB,IACAx7B,QAAAxJ,OAAA,oBAAA2Y,KAAA,sBAAA+T,OAWAljB,QAAAxJ,OAAA,mBAAAumC,SAAA,gCAAAtB,IACAz7B,QAAAxJ,OAAA,mBAAA2Y,KAAA,kBAAA7B,OAEAtN,QAAAxJ,OAAA,mBAAA2B,QAAA,uCAAAkiC,GACA,MAAAA,GAAAlX,QAAApX,UA2BA/L,QAAAxJ,OAAA,mBAAAumC,SAAA,sCAAArB,IAEA17B,QAAAxJ,OAAA,kBAAA2B,QAAA,6CAA2F,UAAAkkC,GAAAW,mBAE3Fh9B,QAAAxJ,OAAA,aAAA2B,QAAA,mBAA2D,MAAA+iC,GAAAzB,cAE3Dz5B,QAAAxJ,OAAA,aAAA2B,QAAA,WAAAokC,GAEAv8B,QAAAxJ,OAAA,aAAAymC,QAAA,oBAA4D,MAAAvzB,GAAAoG,QAC5DqsB,EAAAjW,SAAA,cAIAzvB,EAAA0lC,eACAn8B,QAAAxJ,OAAA,aAAA2Y,IAAAgtB,IAKA,SAAA3lC,EAAAC,EAAAC,GAEA,YAkBA,SAAA0kC,GAAA1vB,GACA,GAAAwxB,IAAA,8DAAAC,GAAA,8DAAAC,GAAA,wBAAAC,EAAAH,EAAA3iC,OAAA4iC,GAAAG,EAAAF,EAAA7iC,OAAA8iC,GACApwB,KAAmBswB,EAAA7xB,EAAAuB,QAAgCuwB,SAAA71B,EAAAlN,KAAAiR,EAAA4xB,GAuCnD,OAtCA31B,GAAA9N,QAAA0jC,EAAA,SAAAtlC,EAAA2B,GAMA,GAJAA,KAAA,WAEA2C,EAAAuB,SAAA7F,KACAA,GAAuBwlC,UAAAxlC,IACvBe,OAAAU,KAAAzB,GAAAmC,OAAA,CAGA,GAAAnC,EAAAwlC,UAAA,CACA,GAAAJ,EAAAlhC,IAAA,SAAAvB,GAAiD,MAAA2B,GAAAgG,UAAAtK,EAAA2C,MAA8CyC,OAAAsK,EAAAjG,UAAA,GAC/F,SAAAzE,OAAA,mBAAAmgC,EAAA73B,KAAA,eAAA83B,EAAA93B,KAAA,6BAAAmG,EAAA9R,KAAA,IAGA3B,GAAAylC,kBAAA,qBAAAh5B,GACA,GAAAi5B,GAAA,SAAA/iC,GAAsD,MAAA3C,GAAA2lC,UAAA3lC,EAAA2lC,SAAAhjC,OACtDk3B,EAAA9xB,QAAA69B,QAAAC,OAAA,UACAC,EAAA,SAAAzsB,GACA,GAAA0sB,GAAA11B,EAAA3B,YAAA2K,EAAA1X,MACAqkC,EAAAN,EAAArsB,EAAA1X,KACA,aAAA0X,EAAA9I,KACAw1B,EAAA,OAAoDlM,EAAA,YAAAmM,EAAA,MACpDD,EAAA,KAAAlM,EAAA,YAAAmM,EAAA,KAEAC,EAAAC,EAAAz5B,EAAAzM,EAAAwlC,WAAAthC,IAAA4hC,GAAAx4B,KAAA,KACA64B,EAAA91B,EAAA3B,YAAA1O,EAAAwlC,UACA,WAAAW,EAAA,IAAAF,EAAA,MAAAE,EAAA,MAGAnmC,EAAAomC,UAAApmC,EAAAomC,WAAA,WACApmC,EAAAy+B,MAAA,MACAz+B,EAAA0Z,SAAAjG,EACAzT,EAAAqmC,MAAA1kC,CACA,IAAAilB,GAAAwa,EAAApD,YAAAkC,sBAAAlgC,EAAA0Z,SAAA1Z,EAAAqmC,MACArmC,GAAA2Z,YAAAiN,EAAAyZ,WACArgC,EAAA4Z,qBAAAgN,EAAA0Z,oBACAtrB,EAAArT,GAAA3B,KAEAgV,EAiBA,QAAAkxB,GAAAz5B,EAAA9K,GACA,GAAA2kC,GAAA75B,EAAAkiB,IAAAhtB,EAAA,YACA,KAAA2kC,MAAAnkC,OACA,SAAA6C,OAAA,mCAAArD,EAAA,IACA,OAAA2kC,GAAApiC,IAAAqiC,GAAAnhC,OAAAsK,EAAAhG,YA/EA,GAAAgG,GAAAjR,EAAA,GACA4R,EAAA5R,EAAA,GACA2iC,EAAA3iC,EAAA,IACA6F,EAAA7F,EAAA,GACA2R,EAAA3R,EAAA,GACAgT,EAAAhT,EAAA,IACA2lC,EAAA3lC,EAAA,GACAD,GAAA8kC,qBAAA,SAAA7uB,EAAAmY,GAAuD,UAAA4Z,GAAA/xB,EAAAmY,IAqDvDpuB,EAAA2kC,iBAGA,IAAAsD,GAAA,SAAAC,GAA6C,MAAA3lC,QAAAU,KAAAilC,OAC7CxiC,IAAA,SAAAvB,GAA0B,OAAAA,EAAA,mBAAAokB,KAAA2f,EAAA/jC,OAC1BjB,OAAA,SAAAge,GAA+B,MAAApb,GAAAgG,UAAAoV,IAAApb,EAAAgG,UAAAoV,EAAA,MAC/Bxb,IAAA,SAAAwb,GAA4B,OAAU/d,KAAA+d,EAAA,OAAAA,EAAA,GAAAnP,KAAAmP,EAAA,UAGtC6mB,EAAA,SAAAhe,GACA,MACAke,GADAniC,EAAAoG,SAAA6d,EAAAoe,kBACApe,EAAAoe,iBACApe,EAAAqe,QASAJ,EAAA,WACA,QAAAA,GAAA/xB,EAAAgF,GACAtZ,KAAAsU,OACAtU,KAAAsZ,WACAtZ,KAAAK,QAAA,EAwCA,MAtCAgmC,GAAA59B,UAAAikB,KAAA,WACA,GAAAxmB,GAAAlG,KACAqM,EAAA4D,EAAA7D,SAAAC,EACA,KAAArM,KAAA0mC,cACA,SAAA7hC,OAAA,4CAAA7E,KAAAsZ,SAAAE,YAAA,IAAAxZ,KAAAsZ,SAAAG,qBAAA,IACA,IAAAktB,GAAA3mC,KAAAsU,KAAAR,eACAH,EAAA3T,KAAAsU,KAAA2B,YACAyhB,GACAjrB,SAAAJ,EAAAiQ,KAAAtc,KAAA4mC,YAAAjzB,EAAA,GAAAswB,GAAAW,gBAAA+B,IACA/C,WAAAv3B,EAAAiQ,KAAAtc,KAAA6mC,cAAAF,IAEA,OAAAt6B,GAAAvF,IAAA4wB,GAAA/mB,KAAA,SAAAoR,GACAzQ,EAAAoG,MAAAqF,sBAAA,SAAA7W,GACAA,EAAA09B,WAAA7hB,EAAA6hB,WACA19B,EAAAuG,SAAAsV,EAAAtV,YAQA45B,EAAA59B,UAAAi+B,YAAA,WACA,SAAA1mC,KAAAsZ,SAAA7M,UAAAzM,KAAAsZ,SAAAwtB,aAAA9mC,KAAAsZ,SAAAgsB,mBAEAe,EAAA59B,UAAAm+B,YAAA,SAAAjzB,EAAAozB,EAAAJ,GACA,MAAAI,GAAA/iB,WAAAhkB,KAAAsZ,SAAA3F,EAAAgzB,EAAA/kB,YAAAlgB,KAAAilC,KAOAN,EAAA59B,UAAAo+B,cAAA,SAAAF,GAEA,GAAAhC,GAAA3kC,KAAAsZ,SAAA0tB,kBACA,OAAA7iC,GAAA0F,aAAA86B,GAAAgC,EAAA/kB,YAAA+iB,MAAuF3kC,KAAAsZ,SAAAsqB,YAEvFyC,IAEAhoC,GAAAgoC,iBAKA,SAAAjoC,EAAAC,EAAAC,GAEA,YAEA,IAAA6F,GAAA7F,EAAA,GACA2R,EAAA3R,EAAA,GAIAsmC,EAAA,WACA,QAAAA,MAiEA,MAjDAA,GAAAn8B,UAAAub,WAAA,SAAAnkB,EAAA8T,EAAAszB,GACA,MAAA9iC,GAAAgG,UAAAtK,EAAA4M,UAAAzM,KAAAoN,WAAAvN,EAAA4M,SAAAkH,GACAxP,EAAAgG,UAAAtK,EAAAinC,aAAA9mC,KAAAknC,QAAArnC,EAAAinC,YAAAnzB,GACAxP,EAAAgG,UAAAtK,EAAAylC,kBAAAtlC,KAAAmnC,aAAAtnC,EAAAylC,iBAAA3xB,EAAAszB,GACA,MAYArC,EAAAn8B,UAAA2E,WAAA,SAAAX,EAAAkH,GACA,MAAAxP,GAAAW,WAAA2H,KAAAkH,GAAAlH,GAYAm4B,EAAAn8B,UAAAy+B,QAAA,SAAAvkB,EAAAhP,GAGA,MAFAxP,GAAAW,WAAA6d,KACAA,IAAAhP,IACA,MAAAgP,EACA,KACA1S,EAAA7D,SAAAK,SAAA+hB,IAAA7L,IAWAiiB,EAAAn8B,UAAA0+B,aAAA,SAAAxC,EAAAhxB,EAAAszB,GACA,MAAAA,GAAAtC,IAGAC,IAEAvmC,GAAAumC,mBAKA,SAAAxmC,EAAAC,EAAAC,GAEA,YASA,SAAA4kC,GAAA5vB,GACA,GAAAoC,KAIA,OAHAnG,GAAA9N,QAAA6R,EAAAoC,YAAyC,SAAAqY,EAAAvsB,GACzCkU,EAAAlU,GAAA2C,EAAAuB,SAAAqoB,MAAA,SAAAxpB,GAAsF,MAAAA,KAAYwpB,IAElGrY,EAbA,GAAAnG,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,EAcAD,GAAA6kC,qBAKA,SAAA9kC,EAAAC,EAAAC,GAEA,YAYA,SAAA8oC,GAAA1Y,EAAA5gB,GACA,GAA4CwV,GAA5C+jB,EAAA3Y,EAAAzf,MAAA,oBAIA,IAHAo4B,IACA3Y,EAAA5gB,EAAA,IAAAu5B,EAAA,QACA/jB,EAAAoL,EAAAjgB,QAAA,WAAAQ,MAAA,6BACAqU,GAAA,IAAAA,EAAAthB,OACA,SAAA6C,OAAA,sBAAA6pB,EAAA,IACA,QAAapb,MAAAgQ,EAAA,GAAAgkB,UAAAhkB,EAAA,UAGb,QAAAikB,GAAAC,GACA,GAAAC,GAAAD,EAAAj/B,SAAAm/B,cAAA,WACA5sB,EAAApX,EAAAqE,MAAA,mBAAA0/B,EACA,OAAA3sB,MAAAtZ,KAAAsZ,EAAAlV,OAGA,QAAA+hC,GAAAH,GAEA,GAAAI,GAAA,+BAAAhnC,OAAA6H,UAAAtB,SAAA7G,KAAAknC,EAAAxjC,KAAA,SACA6jC,EAAA,SAAAL,EAAA,GAAAM,QACA,QACAC,KAAAF,EAAA,SAAAD,EAAA,oBACAI,SAAA,MAAAR,EAAAxjC,KAAA,WAAAg3B,cACAiN,WAAAJ,GAIA,QAAAK,GAAAV,EAAAtyB,EAAAizB,EAAA/3B,EAAAtC,GACA,gBAAAs6B,GACA,GAAAC,GAAAD,EAAAE,OAAAF,EAAAC,OAAAhnB,EAAAvT,GACA,MAAAu6B,EAAA,GAAAD,EAAAG,SAAAH,EAAAI,SAAAJ,EAAAK,UAAAjB,EAAAO,KAAA,YAEA,GAAAjxB,GAAAqxB,EAAA,WACAjzB,EAAAsd,GAAAnR,EAAA/N,MAAA+N,EAAA1N,OAAA0N,EAAAxQ,UAEAu3B,GAAAM,gBAEA,IAAAC,GAAAv4B,EAAA43B,WAAA3mB,EAAAiS,KAAA,GACA8U,GAAAM,eAAA,WACAC,KAAA,GACAR,EAAAS,OAAA9xB,MAMA,QAAA+xB,GAAArB,EAAAtyB,GACA,OAAamX,SAAAkb,EAAAC,IAAAtyB,EAAAiV,SAAA7hB,SAAA,GAnDb,GAAAiH,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAoF,EAAApF,EAAA,GAkHAwqC,GAAA,oBACA,SAAA5zB,EAAAizB,GACA,OACAY,SAAA,IACAC,SAAA,qCACAC,KAAA,SAAAxC,EAAAyC,EAAApD,EAAAqD,GACA,GAAAza,GAAA0Y,EAAAtB,EAAAsD,OAAAl0B,EAAApH,QAAAtM,MACA4mB,GAA4B9U,MAAAob,EAAApb,MAAAggB,KAAA,KAAA3f,OAAA,KAAA9C,QAAA,MAC5BT,EAAAu3B,EAAAuB,GACApJ,EAAAqJ,EAAA,IAAAA,EAAA,GACAE,EAAA,IACAjhB,GAAAvX,QAAAtB,EAAAnN,OAAAymC,EAAAK,EAAAh0B,GAAA4wB,EAAAwD,WAAA7C,EAAA8C,MAAAzD,EAAAwD,eACA,IAAAzd,GAAA,SAAA/hB,GACAA,IACAse,EAAAzU,OAAA/L,QAAAM,KAAA4B,IACAse,EAAAkL,KAAApe,EAAAoe,KAAA5E,EAAApb,MAAA8U,EAAAzU,OAAAyU,EAAAvX,SACAw4B,GACAA,IACAvJ,IACAuJ,EAAAvJ,EAAA0J,eAAA9a,EAAApb,MAAA8U,EAAAzU,SACA,OAAAyU,EAAAkL,MACAwS,EAAA2D,KAAAr5B,EAAA23B,KAAA3f,EAAAkL,MAEA5E,GAAA4Y,YACAb,EAAAzC,OAAAtV,EAAA4Y,UAAA,SAAAx9B,GAAiEA,IAAAse,EAAAzU,QACjEkY,EAAA/hB,KAAuC,GACvCse,EAAAzU,OAAA/L,QAAAM,KAAAu+B,EAAA8C,MAAA7a,EAAA4Y,aAEAzb,IACAzb,EAAA63B,WAEAiB,EAAAxnC,KAAA,QAAAwmC,EAAAgB,EAAAh0B,EAAAizB,EAAA/3B,EAAA,WAA+F,MAAAgY,UAqB/FshB,GAAA,oBACA,SAAAx0B,EAAAizB,GACA,OACAY,SAAA,IACAC,SAAA,qCACAC,KAAA,SAAAxC,EAAAyC,EAAApD,EAAAqD,GAOA,QAAAQ,GAAAC,GACAxhB,EAAA9U,MAAAs2B,EAAA,GACAxhB,EAAAzU,OAAAi2B,EAAA,GACAxhB,EAAAvX,QAAA+4B,EAAA,GACAxhB,EAAAkL,KAAApe,EAAAoe,KAAAlL,EAAA9U,MAAA8U,EAAAzU,OAAAyU,EAAAvX,SACAw4B,GACAA,IACAvJ,IACAuJ,EAAAvJ,EAAA0J,eAAAphB,EAAA9U,MAAA8U,EAAAzU,SACAyU,EAAAkL,MACAwS,EAAA2D,KAAAr5B,EAAA23B,KAAA3f,EAAAkL,MAhBA,GAAAljB,GAAAu3B,EAAAuB,GACApJ,EAAAqJ,EAAA,IAAAA,EAAA,GACAS,GAAA9D,EAAA+D,QAAA/D,EAAAgE,eAAA,KAAAhE,EAAAiE,aAAA,MACAC,EAAA,IAAAJ,EAAA7lC,IAAA,SAAA+F,GAA6D,MAAAA,IAAA,SAAwBqD,KAAA,UACrFib,GAA4B9U,MAAA,KAAAK,OAAA,KAAA9C,QAAA,KAAAyiB,KAAA,MAC5B+V,EAAA,IAaA5C,GAAAzC,OAAAgG,EAAAL,GAAA,GACAA,EAAAlD,EAAA8C,MAAAS,IACA55B,EAAA63B,WAEAiB,EAAAxnC,KAAA,QAAAwmC,EAAAgB,EAAAh0B,EAAAizB,EAAA/3B,EAAA,WAA+F,MAAAgY,UAoF/F6hB,GAAA,sDACA,SAAA/0B,EAAA+a,EAAAia,EAAAzsB,GACA,OACAsrB,SAAA,IACAnF,YAAA,iDAAA7B,EAAAoI,EAAAC,EAAAjC,GAmCA,QAAAkC,GAAAl2B,EAAAm2B,EAAAC,GACA,GAAAj3B,GAAA4B,EAAAsZ,IAAAra,EAAAozB,EAAA4C,IACAK,EAAAC,EAAAt2B,EAAAm2B,GACAI,GACAp3B,UAA8C9R,KAAA2S,GAC9CR,OAAA22B,EACAzhB,KAAA2hB,EAIA,OAFAlb,GAAAxsB,KAAA4nC,GACAC,EAAAH,GAAAD,EACA,WACA,GAAAjlC,GAAAgqB,EAAAzmB,QAAA6hC,EACAplC,SACAgqB,EAAAtmB,OAAA1D,EAAA,IAQA,QAAAmlC,GAAAn3B,EAAAK,GACA,IAAAxP,EAAAuB,SAAA4N,GACA,SAAAzO,OAAA,2BAEA,OAAAV,GAAAoG,SAAAoJ,GACAL,EAAA/D,EAAAvH,OAAA2L,IAEAA,EAAAouB,EAAAwH,MAAA51B,GACAxP,EAAAoG,SAAAoJ,GACAL,EAAA/D,EAAAvH,OAAA2L,GAEAL,GAGA,QAAAuY,KACA,OAAA3oB,GAAA,EAAwCA,EAAAosB,EAAAttB,OAAmBkB,IAC3D0nC,EAAAtb,EAAApsB,GAAAoQ,MAAAgc,EAAApsB,GAAAyQ,QACAk3B,EAAAV,EAAAQ,EAAArb,EAAApsB,GAAA2lB,OAGAiiB,EAAAX,EAAAQ,EAAArb,EAAApsB,GAAA2lB,OAEAkiB,EAAAzb,EAAApsB,GAAAoQ,MAAAgc,EAAApsB,GAAAyQ,QACAk3B,EAAAV,EAAAa,GAGAF,EAAAX,EAAAa,GAIA,QAAAH,GAAArD,EAAAyD,GAAuD9C,EAAA,WAAuBX,EAAAqD,SAAAI,KAC9E,QAAAH,GAAAtD,EAAAyD,GAA0DzD,EAAAsD,YAAAG,GAC1D,QAAAL,GAAAt3B,EAAAK,GAAuD,MAAAuB,GAAAM,SAAAlC,EAAA9R,KAAAmS,GACvD,QAAAo3B,GAAAz3B,EAAAK,GAAyD,MAAAuB,GAAAtJ,GAAA0H,EAAA9R,KAAAmS,GAxFzD,GAAwDq3B,GAAA7B,EAAxD7Z,KAAAqb,IAIAK,GAAAd,EAAAE,EAAAc,gBAAA,OAAAnJ,EACA,KACAoH,EAAApH,EAAAwH,MAAAa,EAAAjB,cAEA,MAAAf,IAEAe,KAAAe,EAAAE,EAAAjB,cAAA,OAAApH,GACA59B,EAAAoG,SAAA4+B,IACA55B,EAAA9N,QAAA0nC,EAAA,SAAApa,EAAAwb,GACA,GAAApmC,EAAAuB,SAAAqpB,GAAA,CACA,GAAAL,GAAA0Y,EAAArY,EAAA7Z,EAAApH,QAAAtM,KACA6oC,GAAA3b,EAAApb,MAAAyuB,EAAAwH,MAAA7a,EAAA4Y,WAAAiD,MAKAvqC,KAAAwpC,eAAA,SAAA2B,EAAAjhB,GAGA,KAAA/lB,EAAAoG,SAAA4+B,IAAA7Z,EAAAttB,OAAA,IAGA,GAAAopC,GAAAf,EAAAc,EAAAjhB,EAAAif,EAEA,OADAtd,KACAuf,IAEArJ,EAAAS,IAAA,sBAAA3W,EACA,IAAAwf,IAAA,wBAAA7d,GAA2FA,EAAApb,QAAAzB,KAAAkb,KAC3Fyf,EAAA7tB,EAAAoD,WAA+DwqB,EAC/DtJ,GAAAS,IAAA,WAAA8I,GAwDAzf,QAIAjkB,SAAAxJ,OAAA,mBACAmtC,UAAA,SAAAzC,GACAyC,UAAA,eAAAtB,GACAsB,UAAA,iBAAAtB,GACAsB,UAAA,UAAA7B,IAKA,SAAAtrC,EAAAC,GAGA,YAWA,SAAAmtC,GAAAt2B,GACA,GAAAu2B,GAAA,SAAAn4B,EAAAK,EAAA9C,GACA,MAAAqE,GAAAtJ,GAAA0H,EAAAK,EAAA9C,GAGA,OADA46B,GAAAC,WAAA,EACAD,EAaA,QAAAE,GAAAz2B,GACA,GAAA02B,GAAA,SAAAt4B,EAAAK,EAAA9C,GACA,MAAAqE,GAAAM,SAAAlC,EAAAK,EAAA9C,GAGA,OADA+6B,GAAAF,WAAA,EACAE,EAxBAJ,EAAA1d,SAAA,UAQAzvB,EAAAmtC,iBAUAG,EAAA7d,SAAA,UAQAzvB,EAAAstC,yBACA/jC,QAAAxJ,OAAA,mBACAmD,OAAA,UAAAiqC,GACAjqC,OAAA,kBAAAoqC,IAKA,SAAAvtC,EAAAC,EAAAC,GAGA,YA6QA,SAAAutC,GAAAC,EAAApK,EAAAjkB,EAAAvK,EAAAi1B,GACA,GAAA4D,GAAAroC,EAAAqE,MAAA,yBACAikC,EAAAtoC,EAAAqE,MAAA,sBACAkkC,EAAAvoC,EAAAqE,MAAA,sBACA,QACAghC,SAAA,MACAvrB,cACA+F,QAAA,SAAA2oB,GACA,GAAAC,GAAAD,EAAApvB,MACA,iBAAA2pB,EAAA0D,GACA,GAAAl2B,GAAAk2B,EAAAl2B,KAAA,UACA,IAAAA,EAAA,CAEA,GAAAuQ,GAAAvQ,EAAAm4B,OAAyC9yB,YACzC6wB,GAAArtB,KAAA0H,EAAA/X,UAAA0/B,GACA76B,EAAAoG,MAAAmF,gBAAA5I,EAAAwzB,QAAA0C,EAAArtB,OACA,IAAAmsB,GAAA6C,EAAA3B,EAAAkC,YACAzI,EAAApf,EAAAof,WACA0I,EAAAP,EAAAvnB,GACAyhB,EAAA+F,EAAAxnB,GACAkf,EAAAuI,EAAAznB,GACAjD,EAAAmiB,GAAAn0B,EAAAxL,IAAA2/B,EAAA3vB,iBAAA,SAAAqJ,GAAoG,MAAAA,GAAAnJ,MAEpG,IADAwyB,EAAAR,GAAA1kB,EACAqiB,EAAA,CACA,GAAA2I,GAAA7K,EAAAkC,EAAAr0B,EAAAnN,UAAwFmf,GAAWwgB,OAAA0E,EAAA0D,aACnGmC,KACA7F,EAAA6F,GAAAC,EACA9F,EAAA6F,GAAArG,GAAA1kB,GAMA4oB,EAAAl2B,KAAA,0BAAAs4B,GACApC,EAAAqC,WAAAv4B,KAAA,0BAAAs4B,GACAE,EAAAhvB,EAAA8uB,EAAA9F,EAAAjiB,GAGA,GAAArgB,EAAAuB,SAAA8e,EAAAlL,SAAA+rB,WACA,GAAAqH,GAAAloB,EAAAlL,SAAA+rB,UACAsH,EAAAz8B,EAAA3B,YAAAm+B,GACAE,EAAA,WACA,GAAAC,MAAAlkC,MAAArI,KAAA6pC,EAAA,GAAAqC,UACAjrC,OAAA,SAAAimC,GAAoD,MAAAA,MAAAsF,SAAAtF,EAAAsF,QAAAn+B,gBAAAg+B,GACpD,OAAAE,IAAAjlC,QAAAshC,QAAA2D,GAAA54B,KAAA,IAAAy4B,EAAA,eAEAK,EAAAtG,EAAAzC,OAAA4I,EAAA,SAAAI,GACAA,IAEAP,EAAAhvB,EAAAuvB,EAAAvG,EAAAjiB,GACAuoB,MAGA9D,GAAAxC,OAQA,QAAAgG,GAAAhvB,EAAA8uB,EAAAxK,EAAAvd,IAEArgB,EAAAW,WAAAynC,EAAAU,UAAAzoB,EAAAlL,SAAA+rB,WAAA6H,GACAX,EAAAU,SACA,IAAAE,IAAwBzrC,KAAA6qC,EAExB,IAAApoC,EAAAW,WAAAynC,EAAAa,mBAAA,CAEA,GAAAC,GAAA,SAAA7f,GACA,GAAA8f,GAAA9oB,EAAAlQ,KAAAR,eACAy5B,EAAAD,EAAAv5B,iBAAA,aAAAE,IAGA,IAAAuZ,IAAA+f,GAAA/f,EAAA7Y,UAAA9L,QAAA2b,EAAAlQ,KAAAhB,MAAAE,WAAA,CAEA,GAAAoF,GAAA4U,EAAA7Z,OAAA,MACA+E,EAAA8U,EAAA7Z,OAAA,QACA65B,EAAAhgB,EAAAnb,cAAAlR,GAAA4C,IAAA,SAAAuQ,GAA+E,MAAAA,GAAAyB,cAA2B9Q,OAAAsK,EAAAhG,YAC1GkkC,EAAAjgB,EAAAnb,cAAAnR,KAAA6C,IAAA,SAAAuQ,GAAmF,MAAAA,GAAAyB,cAA2B9Q,OAAAsK,EAAAhG,YAE9GmkC,EAAAF,EAAAjsC,OAAA,SAAAwlB,GACA,GAAAzhB,GAAAmoC,EAAA5kC,QAAAke,EACA,OAAAzhB,UAAAmoC,EAAAnoC,GAAA8K,KAAAjI,OAAAyQ,EAAAmO,EAAA3mB,IAAAsY,EAAAqO,EAAA3mB,MAGA,IAAAstC,EAAA1rC,OAAA,CACA,GAAA2rC,GAAAD,EAAA3pC,IAAA,SAAAQ,GAAuE,MAAAA,GAAAnE,IAEvEmsC,GAAAa,kBAAA79B,EAAAhO,OAAAqX,EAAA,SAAA9O,EAAAtH,GAAqG,MAAAmrC,GAAA9kC,QAAArG,UAA4CgrB,KAGjJuU,GAAAS,IAAA,WAAA/kB,EAAAyD,cAAyD,eAAAmsB,IAAAF,EAEzD,IAAAS,GAAA,SAAAv2B,EAAAmW,GACAnW,EAAAjH,OAAAd,EAAAa,WAAAgB,SACAk8B,EAAA7f,GAEAuU,GAAAS,IAAA,WAAA/kB,EAAA0D,YAAuD,yBAAAysB,IAAAT,GAGvD,GAAAhpC,EAAAW,WAAAynC,EAAAsB,WAAA,CACA,GAAAC,IAAyBn5B,QAAA6P,EAAAlQ,KAAAhB,MAAA9R,KACzBugC,GAAAS,IAAA,WAAA/kB,EAAAmD,SAAAktB,EAAAvB,EAAAsB,UAAAV,KAnXA,GAAA59B,GAAAjR,EAAA,GACA6F,EAAA7F,EAAA,GACAgT,EAAAhT,EAAA,IACAykC,EAAAzkC,EAAA,IACAgR,EAAAhR,EAAA,IACAoF,EAAApF,EAAA,GACA4R,EAAA5R,EAAA,GAkIAyvC,GAAA,uDACA,SAAA76B,EAAA86B,EAAAC,EAAA/D,EAAA79B,GACA,QAAA6hC,GAAApI,EAAAW,GACA,OACA0H,MAAA,SAAAjF,EAAA7nB,EAAApb,GACA2B,QAAA69B,QAAAC,MAAA,EACAsI,EAAAG,MAAAjF,EAAA,KAAA7nB,GAAA1Q,KAAA1K,GAGA+nC,EAAAG,MAAAjF,EAAA,KAAA7nB,EAAApb,IAGAmoC,MAAA,SAAAlF,EAAAjjC,GACA2B,QAAA69B,QAAAC,MAAA,EACAsI,EAAAI,MAAAlF,GAAAv4B,KAAA1K,GAGA+nC,EAAAI,MAAAlF,EAAAjjC,KAKA,QAAAooC,GAAAC,EAAAC,GACA,MAAAD,KAAAC,EAEA,GAAAC,IACApC,MAAoB9yB,UAAYC,SAAArG,EAAAksB,gBAChCqI,YAEA8D,GACApN,MAAA,EACA4K,SAAA,MACA0F,UAAA,EACAjxB,SAAA,IACAkxB,WAAA,UACAnrB,QAAA,SAAA2oB,EAAAyC,EAAAC,GACA,gBAAAnI,EAAA0D,EAAArE,GAcA,QAAA+I,GAAAhvC,KACAA,eAAAkjC,GAAAsD,iBAEAgI,EAAAh1B,EAAAxZ,KAEAyR,EAAAoG,MAAAgF,yBAAAoyB,EAAAjvC,KAAAyZ,UAAAzZ,EAAAyZ,SAAAC,UACAF,EAAAxZ,EACAkvC,EAAAlvC,KASA,QAAAmvC,KAWA,GAVAC,IACA39B,EAAAoG,MAAA8E,iBAAA,yBAAAyyB,EAAAh7B,KAAA,YACAg7B,EAAAlhC,SACAkhC,EAAA,MAEAC,IACA59B,EAAAoG,MAAA8E,iBAAA,mBAAAsyB,GACAI,EAAAC,WACAD,EAAA,MAEAE,EAAA,CACA,GAAAC,GAAAD,EAAAn7B,KAAA,UACA3C,GAAAoG,MAAA8E,iBAAA,cAAA6yB,GACAC,EAAAlB,MAAAgB,EAAA,WACAC,EAAAE,YAAA75B,UACAu5B,EAAA,OAEAA,EAAAG,EACAA,EAAA,MAGA,QAAAL,GAAAlvC,GACA,GAAA+c,GAAA6pB,EAAA+I,MACAl+B,GAAAoG,MAAAiF,wBAAAmyB,EAAAlyB,EACA,IAAA6yB,GAAApjC,EAAA8F,QAAAu9B,EAAArjC,EAAA8F,QACAw9B,GACAvD,KAAAvsC,EACA4nC,QAAAqH,EACAc,WAAAH,EAAAr9B,QACAy9B,WAAAH,EAAAt9B,QACAm9B,YAAAG,GAEAza,EAAA2Z,EAAAhyB,EAAA,SAAAsY,GACAoa,EAAAnB,MAAAjZ,EAAAjhB,KAAA,UAAA07B,GAAAxF,EAAA,WACAsF,EAAA/5B,UACAw5B,GACAA,EAAAY,MAAA,+BACA3rC,EAAAgG,UAAA4lC,QAAAtJ,EAAA8C,MAAAwG,KACA9B,EAAA/Y,KAGA8Z,KAEAI,GAAAna,EACAia,EAAAtyB,EAWAsyB,EAAAY,MAAA,qBAAAjwC,GAAAwZ,GACA61B,EAAA3F,MAAAyG,GAtFA,GAAAf,GAAAG,EAAAF,EAAAe,EAAAD,EAAAlK,EAAAoK,QAAA,GAAAH,EAAAjK,EAAAqK,WAAAb,EAAApB,EAAApI,EAAAW,GAAAptB,EAAAzT,OAAA0kB,EAAA6f,EAAAzC,cAAA,YAAA8G,EAAAhtC,EAAA0oC,EAAApE,EAAA7H,QAAA6H,EAAAtkC,MAAA,IAAAilC,IAAA,WACAqI,GACAxQ,MAAA,MACAl+B,GAAAmrC,EAAApN,QACA38B,OACAwX,IAAAsR,EAAAmd,QAAAzuB,IAAAsR,EAAAmd,QAAAzuB,IAAA,IAAAxX,IACA3B,OAAA,KACAs/B,cAAA0P,EACA91B,sBACA,MAAArV,GAAAqE,MAAA,0BAAAuiB,IAGAhZ,GAAAoG,MAAA8E,iBAAA,UAAAsyB,GAUA3E,EAAAl2B,KAAA,WAA+CwzB,QAAAqH,IAC/CC,IACAkB,EAAA/8B,EAAAysB,eAAAmP,GACArI,EAAAjE,IAAA,sBACAlxB,EAAAoG,MAAA8E,iBAAA,2BAAAsyB,GACAmB,QAgEA,OAAA1E,IAEAM,GAAA/d,SAAA,2DA6DA,IAAAof,GAAA,kBAAAtlC,SAAAxJ,OAAA,sBA+CAwJ,SAAAxJ,OAAA,mBAAAmtC,UAAA,SAAAwC,GACAnmC,QAAAxJ,OAAA,mBAAAmtC,UAAA,SAAAM,IAKA,SAAAztC,EAAAC,GAEA,YAQA,SAAA+xC,KACA,GAAAC,IAAA,CAUArwC,MAAAqwC,gBAAA,WACAA,GAAA,GAgBArwC,KAAAo7B,MAAA,oCAAAkV,EAAAnI,GACA,MAAAkI,GACAC,EAEA,SAAAnG,GACA,MAAAhC,GAAA,WACAgC,EAAA,GAAAoG,kBACkB,SAIlB3oC,QAAAxJ,OAAA,mBAAAumC,SAAA,gBAAAyL,SF8EM,SAAShyC,EAAQC,EAASC,GGvkPhCA,EAAA,GACAF,EAAAC,QAAA,aH8kPM,SAASD,EAAQC;;;;;CI1kPvB,SAAAsJ,EAAAC,GAA4B,YA4E5B,SAAA4oC,GAAAC,EAAAjvC,EAAAkvC,GACA,IAAAD,EACA,KAAAE,IAAA,+BAAiDnvC,GAAA,IAAAkvC,GAAA,WAEjD,OAAAD,GAGA,QAAAG,GAAA5tC,EAAAC,GACA,MAAAD,IAAAC,EACAD,EACAC,GACAmB,EAAApB,SAAAmK,KAAA,MACA/I,EAAAnB,SAAAkK,KAAA,MACAnK,EAAA,IAAAC,GAHAD,EADAC,EADA,GAQA,QAAA4tC,GAAAhgC,GACA,GAAAigC,KAKA,OAJAjgC,OAAA1P,IAAA0P,EAAA3P,QACA4vC,EAAA3vC,GAAA0P,EAAA1P,GACA2vC,EAAA5vC,KAAA2P,EAAA3P,MAEA4vC,EAGA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAjG,GAAA,EAaA,OAZA+F,GAAA5sC,EAAA4sC,GACAA,EACAA,GAAAtrC,EAAAsrC,MAAAhvC,OACAgvC,EAAAtlC,MAAA,UAEAjK,EAAAuvC,EAAA,SAAAG,EAAAjuC,GACAiuC,KAAAnvC,OAAA,IACAipC,GAAA/nC,EAAA,SACA+nC,GAAAiG,EAAAD,EAAAE,EACAA,EAAAF,KAGAhG,EAGA,QAAAmG,GAAAltC,EAAA4F,GACA,GAAAwvB,GAAAp1B,EAAA2E,QAAAiB,EACAA,IAAA,GACA5F,EAAA8E,OAAAswB,EAAA,GAIA,QAAA+X,GAAAnI,GACA,GAAAA,YAAAoI,GACA,OAAApI,EAAAlnC,QACA,OACA,MAAAknC,EAGA,QAIA,GAAAA,EAAA,GAAAqI,WAAAC,EACA,MAAAtI,EAEA,MAEA,SACA,MAAAoI,GAAAG,EAAAvI,IAKA,GAAAA,EAAAqI,WAAAC,EACA,MAAAF,GAAApI,GAIA,QAAAuI,GAAAvI,GACA,IAAAA,EAAA,SAAAA,EACA,QAAAhmC,GAAA,EAAiBA,EAAAgmC,EAAAlnC,OAAoBkB,IAAA,CACrC,GAAAwuC,GAAAxI,EAAAhmC,EACA,IAAAwuC,EAAAH,UAAAC,EACA,MAAAE,IAKA,QAAAC,GAAAC,EAAA1I,EAAA+B,GACAxpC,EAAAynC,EAAA,SAAAwI,GACAE,EAAA/G,SAAA6G,EAAAzG,KAIA,QAAA4G,GAAAD,EAAA1I,EAAA+B,GACAxpC,EAAAynC,EAAA,SAAAwI,GACAE,EAAA9G,YAAA4G,EAAAzG,KAIA,QAAA6G,GAAAF,GACA,gBAAA1I,EAAAr4B,GACAA,EAAAg6B,WACA8G,EAAAC,EAAA1I,EAAAr4B,EAAAg6B,UACAh6B,EAAAg6B,SAAA,MAEAh6B,EAAAi6B,cACA+G,EAAAD,EAAA1I,EAAAr4B,EAAAi6B,aACAj6B,EAAAi6B,YAAA,OAKA,QAAAiH,GAAAlhC,GAEA,GADAA,SACAA,EAAAmhC,WAAA,CACA,GAAAC,GAAAphC,EAAAohC,cAAA7pC,CACAyI,GAAAohC,aAAA,WACAphC,EAAAqhC,qBAAA,EACAD,IACAA,EAAA7pC,GAEAyI,EAAAmhC,YAAA,EAEA,MAAAnhC,GAGA,QAAAshC,GAAAjJ,EAAAr4B,GACAuhC,EAAAlJ,EAAAr4B,GACAwhC,EAAAnJ,EAAAr4B,GAGA,QAAAuhC,GAAAlJ,EAAAr4B,GACAA,EAAA3P,OACAgoC,EAAAoJ,IAAAzhC,EAAA3P,MACA2P,EAAA3P,KAAA,MAIA,QAAAmxC,GAAAnJ,EAAAr4B,GACAA,EAAA1P,KACA+nC,EAAAoJ,IAAAzhC,EAAA1P,IACA0P,EAAA1P,GAAA,MAIA,QAAAoxC,GAAArJ,EAAAsJ,EAAAC,GACA,GAAApxB,GAAAmxB,EAAA3hC,YACAkE,EAAA09B,EAAA5hC,YAEA6hC,GAAArxB,EAAAwpB,UAAA,SAAA91B,EAAA81B,UAAA,IACA8H,GAAAtxB,EAAAypB,aAAA,SAAA/1B,EAAA+1B,aAAA,IACAkG,EAAA4B,EAAA1J,EAAAnB,KAAA,SAAA2K,EAAAC,EAEA59B,GAAA89B,qBACAxxB,EAAAwxB,mBAAAC,EAAA/9B,EAAA89B,mBAAAxxB,EAAAwxB,0BACA99B,GAAA89B,mBAIA,IAAAE,GAAA1xB,EAAA4wB,eAAA7pC,EAAAiZ,EAAA4wB,aAAA,IAwBA,OAtBA7vC,GAAAif,EAAAtM,GAGAg+B,IACA1xB,EAAA4wB,aAAAc,GAGA/B,EAAAnG,SACAxpB,EAAAwpB,SAAAmG,EAAAnG,SAEAxpB,EAAAwpB,SAAA,KAGAmG,EAAAlG,YACAzpB,EAAAypB,YAAAkG,EAAAlG,YAEAzpB,EAAAypB,YAAA,KAGA0H,EAAA3H,SAAAxpB,EAAAwpB,SACA2H,EAAA1H,YAAAzpB,EAAAypB,YAEAzpB,EAGA,QAAAuxB,GAAAI,EAAAN,EAAAC,GAuCA,QAAAM,GAAAjC,GACAtrC,EAAAsrC,KACAA,IAAAtlC,MAAA,KAGA,IAAAlN,KAQA,OAPAiD,GAAAuvC,EAAA,SAAAG,GAGAA,EAAAnvC,SACAxD,EAAA2yC,IAAA,KAGA3yC,EAnDA,GAAA00C,GAAA,EACAC,KAEAC,IACAJ,GAAAC,EAAAD,GAEAN,EAAAO,EAAAP,GACAjxC,EAAAixC,EAAA,SAAA5xC,EAAA0B,GACA4wC,EAAA5wC,GAAA0wC,IAGAP,EAAAM,EAAAN,GACAlxC,EAAAkxC,EAAA,SAAA7xC,EAAA0B,GACA4wC,EAAA5wC,GAAA4wC,EAAA5wC,KAAA0wC,EAAA,KAAAC,GAGA,IAAAnC,IACAnG,SAAA,GACAC,YAAA,GAoCA,OAjCArpC,GAAA2xC,EAAA,SAAAtpC,EAAAqnC,GACA,GAAAntC,GAAAqvC,CACAvpC,KAAAopC,GACAlvC,EAAA,WACAqvC,GAAAL,EAAA7B,IACKrnC,IAAAqpC,IACLnvC,EAAA,cACAqvC,EAAAL,EAAA7B,IAEAkC,IACArC,EAAAhtC,GAAAhC,SACAgvC,EAAAhtC,IAAA,KAEAgtC,EAAAhtC,IAAAmtC,KAoBAH,EAGA,QAAAsC,GAAApK,GACA,MAAAA,aAAAthC,GAAAshC,UAAA,GAAAA,EAGA,QAAAqK,GAAArK,EAAAruB,EAAAhK,GACA,GAAAmgC,GAAA,EACAn2B,KACAm2B,EAAAD,EAAAl2B,EAAA24B,GAAA,IAEA3iC,EAAAg6B,WACAmG,EAAA8B,EAAA9B,EAAAD,EAAAlgC,EAAAg6B,SAAA4I,KAEA5iC,EAAAi6B,cACAkG,EAAA8B,EAAA9B,EAAAD,EAAAlgC,EAAAi6B,YAAA4I,KAEA1C,EAAAhvC,SACA6O,EAAAgiC,mBAAA7B,EACA9H,EAAA2B,SAAAmG,IAIA,QAAA2C,GAAAzK,EAAAr4B,GACAA,EAAAgiC,qBACA3J,EAAA4B,YAAAj6B,EAAAgiC,oBACAhiC,EAAAgiC,mBAAA,MAEAhiC,EAAA85B,gBACAzB,EAAA4B,YAAAj6B,EAAA85B,eACA95B,EAAA85B,cAAA,MAIA,QAAAiJ,GAAAt/B,EAAAu/B,GAIA,GAAA/yC,GAAA+yC,EAAA,IAAAA,EAAA,MAEA,OADAC,GAAAx/B,GAAAy/B,GAAAjzC,KACAizC,GAAAjzC,GAGA,QAAAkzC,GAAA1/B,EAAA2/B,GACA,GAAAnzC,GAAAmzC,EAAA,YACAzxC,EAAA0xC,EAAAC,EAEA,OADAL,GAAAx/B,GAAA9R,EAAA1B,KACA0B,EAAA1B,GAGA,QAAAgzC,GAAAx/B,EAAA8/B,GACA,GAAApwC,GAAAowC,EAAA,GACAtzC,EAAAszC,EAAA,EACA9/B,GAAA+/B,MAAArwC,GAAAlD,EAGA,QAAAgyC,GAAA9vC,EAAAC,GACA,MAAAD,GACAC,EACAD,EAAA,IAAAC,EADAD,EADAC,EAuYA,QAAAqxC,GAAAT,GACA,OAAAU,GAAAV,EAAA,KAGA,QAAAW,GAAAC,EAAAC,GACA,GAAA1wC,GAAA0wC,EAAAC,GAAAZ,EACA,QAAA/vC,EAAAywC,EAAA,KAGA,QAAAG,GAAAC,EAAA3L,EAAA4L,GACA,GAAAhE,GAAAlwC,OAAAsyB,OAAA,MACA6hB,EAAAF,EAAAG,iBAAA9L,MAqBA,OApBAznC,GAAAqzC,EAAA,SAAAG,EAAAC,GACA,GAAAprC,GAAAirC,EAAAE,EACA,IAAAnrC,EAAA,CACA,GAAAtJ,GAAAsJ,EAAA8Y,OAAA,IAGA,MAAApiB,GAAA,MAAAA,MAAA,KACAsJ,EAAAqrC,EAAArrC,IAMA,IAAAA,IACAA,EAAA,MAEAgnC,EAAAoE,GAAAprC,KAIAgnC,EAGA,QAAAqE,GAAA/mC,GACA,GAAAgnC,GAAA,EACAjsC,EAAAiF,EAAA1C,MAAA,UAUA,OATAjK,GAAA0H,EAAA,SAAArI,GAGA,KAAAA,EAAA8hB,OAAA9hB,EAAAkB,OAAA,KACAlB,IAAA+hB,UAAA,EAAA/hB,EAAAkB,OAAA,IAEAlB,EAAAu0C,WAAAv0C,IAAA,EACAs0C,IAAAjwC,KAAAgJ,IAAArN,EAAAs0C,GAAAt0C,IAEAs0C,EAGA,QAAAE,GAAAxrC,GACA,WAAAA,GAAA,MAAAA,EAGA,QAAAyrC,GAAA1B,EAAA2B,GACA,GAAAnB,GAAAoB,EACA30C,EAAA+yC,EAAA,GAMA,OALA2B,GACAnB,GAAAqB,GAEA50C,GAAA,eAEAuzC,EAAAvzC,GAGA,QAAA60C,KACA,GAAAhT,GAAA/hC,OAAAsyB,OAAA,KACA,QACAzD,MAAA,WACAkT,EAAA/hC,OAAAsyB,OAAA,OAGAiL,MAAA,SAAA37B,GACA,GAAAozC,GAAAjT,EAAAngC,EACA,OAAAozC,KAAAC,MAAA,GAGArnB,IAAA,SAAAhsB,GACA,GAAAozC,GAAAjT,EAAAngC,EACA,OAAAozC,MAAA90C,OAGAg1C,IAAA,SAAAtzC,EAAA1B,GACA6hC,EAAAngC,GAGAmgC,EAAAngC,GAAAqzC,QAFAlT,EAAAngC,IAAsBqzC,MAAA,EAAA/0C,WAiBtB,QAAAi1C,GAAAC,EAAA1hC,EAAAwgC,GACArzC,EAAAqzC,EAAA,SAAA9wC,GACAgyC,EAAAhyC,GAAAmG,EAAA6rC,EAAAhyC,IACAgyC,EAAAhyC,GACAsQ,EAAA+/B,MAAA4B,iBAAAjyC,KAn2BA,GA0BAyxC,GAAAS,EAAAhC,EAAAiC,EA1BA/tC,EAAAR,EAAAQ,KACAF,EAAAN,EAAAM,KACA9F,EAAAwF,EAAAxF,OACAkvC,EAAA1pC,EAAAshC,QACAznC,EAAAmG,EAAAnG,QACA2C,EAAAwD,EAAAxD,QACAsB,EAAAkC,EAAAlC,SACA6E,EAAA3C,EAAA2C,SACAL,EAAAtC,EAAAsC,YACAC,EAAAvC,EAAAuC,UACArF,EAAA8C,EAAA9C,WACAsxC,EAAAxuC,EAAAwuC,UAEA5E,EAAA,EAGAiC,EAAA,OACAC,EAAA,UACAF,EAAA,MACA6C,EAAA,UACAC,GAAA,WAEAC,GAAA,aACAC,GAAA,sBAGAC,GAAA,EAWAvsC,GAAAvC,EAAA+uC,kBAAAvsC,EAAAxC,EAAAgvC,wBACAF,GAAA,WACAhB,EAAA,mBACAS,EAAA,sCAEAT,EAAA,aACAS,EAAA,iBAGAhsC,EAAAvC,EAAAivC,iBAAAzsC,EAAAxC,EAAAkvC,uBACAJ,GAAA,WACAvC,EAAA,kBACAiC,EAAA,oCAEAjC,EAAA,YACAiC,EAAA,eAGA,IAAAT,IAAA,WACAoB,GAAA,WACAC,GAAA,QACAC,GAAA,iBACAC,GAAA,iBACA9C,GAAA,YACA+C,GAAA,KAEAvC,GAAAT,EAAA6C,GACAxC,GAAAL,EAAAwB,GACA3B,GAAA0B,EAAAsB,GACAI,GAAA1B,EAAAC,GAMA/E,GAAA/oC,EAAAwvC,SAAA,MAgTAC,IAAA,iBAAAC,GAGA,QAAAC,GAAAC,GAIAhoB,IAAArtB,OAAAq1C,GACAC,IAyBA,QAAAA,KACA,GAAAjoB,EAAAxtB,OAAA,CAGA,OADAyL,GAAA+hB,EAAA9hB,QACAxK,EAAA,EAAmBA,EAAAuK,EAAAzL,OAAkBkB,IACrCuK,EAAAvK,IAGAw0C,IACAJ,EAAA,WACAI,GAAAD,OA1CA,GAAAjoB,GAAAkoB,CA8BA,OApBAloB,GAAA+nB,EAAA/nB,SAUA+nB,EAAAI,eAAA,SAAArwC,GACAowC,OAEAA,EAAAJ,EAAA,WACAI,EAAA,KACApwC,IACAmwC,OAIAF,IAgGAK,IAAA,wBAAA1N,GACA,OACAjB,KAAA,SAAAxC,EAAAyC,EAAApD,GAWA,QAAA+R,GAAA/2C,GACAA,EAAA,OAAAA,GAAA,SAAAA,EACAooC,EAAAj1B,KAAAuiC,GAAA11C,GAZA,GAAAgJ,GAAAg8B,EAAAgS,iBACAlwC,GAAAlC,SAAAoE,IAAA,IAAAA,EAAA9H,OACAknC,EAAAj1B,KAAAuiC,IAAA,IAIAqB,EAAA3N,EAAApgC,GAAA28B,IACAX,EAAAiS,SAAA,oBAAAF,QAWAG,GAAA,eAwNAC,GAAA,IAGAC,GAAA,EACAC,GAAA,IAEAC,IACAC,mBAAAlB,GACAmB,gBAAAvE,GACAwE,mBAAA9C,EAAAqB,GACA0B,kBAAAjE,GACAkE,eAAA9D,GACA+D,wBAAAxE,EAAA+C,IAGA0B,IACAN,mBAAAlB,GACAmB,gBAAAvE,GACAyE,kBAAAjE,GACAkE,eAAA9D,IAgHAiE,IAAA,4BAAAC,GACA,GAAAC,GAAAnD,IACAoD,EAAApD,GAEA31C,MAAAo7B,MAAA,kDACA,6DACA,SAAAyZ,EAAAjD,EAAAoH,EAAA7Q,EACA8Q,EAAA7W,EAAA8W,EAAAC,GAKA,QAAAC,GAAA9kC,EAAA+kC,GACA,GAAAC,GAAA,uBACAjV,EAAA/vB,EAAA+vB,WACAkV,EAAAlV,EAAAiV,KAAAjV,EAAAiV,KAAAE,EACA,OAAAD,GAAA,IAAAjlC,EAAAmlC,aAAA,aAAAJ,EAGA,QAAAK,GAAAplC,EAAA22B,EAAA0O,EAAA7E,GACA,GAAA8E,GAAAd,EAAAtqB,IAAAmrB,EAYA,OAVAC,KACAA,EAAAhF,EAAAC,EAAAvgC,EAAAwgC,GACA,aAAA8E,EAAAlB,0BACAkB,EAAAlB,wBAAA,IAMAI,EAAAhD,IAAA6D,EAAAC,GACAA,EAGA,QAAAC,GAAAvlC,EAAA22B,EAAA0O,EAAA7E,GACA,GAAAgF,EAKA,IAAAhB,EAAA3a,MAAAwb,GAAA,IACAG,EAAAf,EAAAvqB,IAAAmrB,IAEAG,GAAA,CACA,GAAAC,GAAAhJ,EAAA9F,EAAA,WAEA2G,GAAA/G,SAAAv2B,EAAAylC,GAEAD,EAAAlF,EAAAC,EAAAvgC,EAAAwgC,GAGAgF,EAAAtB,kBAAArzC,KAAAgJ,IAAA2rC,EAAAtB,kBAAA,GACAsB,EAAAzB,mBAAAlzC,KAAAgJ,IAAA2rC,EAAAzB,mBAAA,GAEAzG,EAAA9G,YAAAx2B,EAAAylC,GAEAhB,EAAAjD,IAAA6D,EAAAG,GAIA,MAAAA,OAKA,QAAAnC,GAAA1zC,GACA+1C,EAAAl3C,KAAAmB,GACAi1C,EAAAvB,eAAA,WACAmB,EAAArpB,QACAspB,EAAAtpB,OAQA,QAJAwqB,GAAAhB,IAIA/1C,EAAA,EAAuBA,EAAA82C,EAAAh4C,OAAyBkB,IAChD82C,EAAA92C,GAAA+2C,EAEAD,GAAAh4C,OAAA,IAIA,QAAAk4C,GAAA5lC,EAAA22B,EAAA0O,GACA,GAAAC,GAAAF,EAAAplC,EAAA22B,EAAA0O,EAAAvB,IACA+B,EAAAP,EAAAnB,eACA2B,EAAAR,EAAAtB,eAQA,OAPAsB,GAAAS,SAAAF,GAAAC,EACAj1C,KAAAgJ,IAAAgsC,EAAAC,GACAD,GAAAC,EACAR,EAAAU,YAAAn1C,KAAAgJ,IACAyrC,EAAApB,kBAAAoB,EAAAlB,wBACAkB,EAAAvB,oBAEAuB,EAvFA,GAAAW,GAAAzI,EAAAF,GAEA4H,EAAA,EAsDAQ,IAkCA,iBAAA9Q,EAAAsR,GAgQA,QAAAC,KACAC,IAGA,QAAAhD,KACAgD,GAAA,GAGA,QAAAA,GAAAC,GAGA,KAAAC,GAAAC,GAAAC,GAAA,CACAF,GAAA,EACAE,GAAA,EAEAjqC,EAAAkqC,0BACAnJ,EAAA9G,YAAA5B,EAAA2J,IAEAjB,EAAA9G,YAAA5B,EAAAyB,IAEAqJ,EAAA1/B,GAAA,GACAs/B,EAAAt/B,GAAA,GAEA7S,EAAAu5C,GAAA,SAAApF,GAIAthC,EAAA+/B,MAAAuB,EAAA,SAGA2E,EAAArR,EAAAr4B,GACAshC,EAAAjJ,EAAAr4B,GAEAjQ,OAAAU,KAAA25C,GAAAj5C,QACAP,EAAAw5C,EAAA,SAAAn6C,EAAAkD,GACAlD,EAAAwT,EAAA+/B,MAAA6G,YAAAl3C,EAAAlD,GACAwT,EAAA+/B,MAAA8G,eAAAn3C,KASA6M,EAAAuqC,QACAvqC,EAAAuqC,SAGAC,OAAAr5C,QAEAknC,EAAAoS,IAAAD,GAAAluC,KAAA,KAAAouC,EAIA,IAAAC,GAAAtS,EAAAj1B,KAAA+jC,GACAwD,KACArT,EAAAS,OAAA4S,EAAA,GAAAC,OACAvS,EAAAwS,WAAA1D,KAIA2D,IACAA,GAAAC,UAAAjB,IAIA,QAAAkB,GAAAhI,GACAT,GAAA0I,iBACAlI,EAAAt/B,EAAAu/B,GAGAT,GAAA2I,wBACA/H,EAAA1/B,IAAAu/B,GAIA,QAAAmI,KAUA,MATAL,IAAA,GAAA3C,IACAiD,IAAAxB,EACA7R,OAAA8O,IAIAC,EAAAvvC,GACAsyC,KAGAwB,eAAA,EACAnxC,MAAA,WACA,MAAA4wC,KAEAM,IAAAxB,GAIA,QAAAc,GAAA1gC,GACAA,EAAAshC,iBACA,IAAAC,GAAAvhC,EAAAwhC,eAAAxhC,EAIAyhC,EAAAF,EAAAG,kBAAA/yB,KAAAgzB,MAIAC,EAAApH,WAAA+G,EAAAK,YAAAC,QAAAxE,IASA/yC,MAAAgJ,IAAAmuC,EAAAK,GAAA,IAAAC,IAAAH,GAAAnC,KAGAO,GAAA,EACAH,KAIA,QAAA3vC,KAkDA,QAAA8xC,KAGA,IAAAjC,EAAA,CAaA,GAXAiB,GAAA,GAEAp6C,EAAAu5C,GAAA,SAAApF,GACA,GAAApzC,GAAAozC,EAAA,GACA90C,EAAA80C,EAAA,EACAthC,GAAA+/B,MAAA7xC,GAAA1B,IAGAy5C,EAAArR,EAAAr4B,GACA+gC,EAAA/G,SAAA3B,EAAAyB,IAEAyI,GAAA0J,wBAAA,CASA,GARAC,GAAAzoC,EAAA22B,UAAA,IAAA4H,GACA8G,GAAAP,EAAA9kC,EAAAyoC,IAEAnD,GAAAM,EAAA5lC,EAAAyoC,GAAApD,IACAqD,GAAApD,GAAAS,SACAA,GAAAl1C,KAAAgJ,IAAA6uC,GAAA,GACA1C,GAAAV,GAAAU,YAEA,IAAAA,GAEA,WADAI,IAIAtH,IAAA6J,eAAArD,GAAAvB,mBAAA,EACAjF,GAAA8J,cAAAtD,GAAApB,kBAAA,EAkBA,GAfApF,GAAA+J,sBACAH,GAAA,iBAAAnsC,GAAA4jC,OAAAa,EAAAzkC,EAAA4jC,OACAY,WAAAxkC,EAAA4jC,OACAuI,GAEA3C,GAAAl1C,KAAAgJ,IAAA6uC,GAAA,GACApD,GAAAnB,eAAAuE,GACAI,GAAA5I,EAAAwI,IAAA,GACAhC,GAAAl4C,KAAAs6C,IACA9oC,EAAA+/B,MAAA+I,GAAA,IAAAA,GAAA,IAGAR,GAAAvC,GAAApC,GACAoF,GAAA/C,GAAArC,GAEApnC,EAAAysC,OAAA,CACA,GAAAC,GAAAC,EAAA3sC,EAAAysC,MACAlK,IAAA6J,iBACAM,EAAA9H,EAAAuB,GACAgE,GAAAl4C,MAAAy6C,EAAAC,IACAlpC,EAAA+/B,MAAAkJ,GAAAC,GAEApK,GAAA8J,gBACAK,EAAArJ,EAAA8C,GACAgE,GAAAl4C,MAAAy6C,EAAAC,IACAlpC,EAAA+/B,MAAAkJ,GAAAC,GAIA5D,GAAAvB,oBACAgD,GAAAv4C,KAAAozC,GAGA0D,GAAApB,mBACA6C,GAAAv4C,KAAAqzC,GAGAwG,GAAAnzB,KAAAgzB,KACA,IAAAiB,GAAAb,GAAAzE,GAAAkF,GACAK,EAAAf,GAAAc,EAEAE,EAAAzU,EAAAj1B,KAAA+jC,QACA4F,GAAA,CACA,IAAAD,EAAA37C,OAAA,CACA,GAAA67C,GAAAF,EAAA,EACAC,GAAAF,EAAAG,EAAAC,gBACAF,EACAzV,EAAAS,OAAAiV,EAAApC,OAEAkC,EAAA76C,KAAA43C,GAIA,GAAAkD,EAAA,CACA,GAAAnC,GAAAtT,EAAA4V,EAAAN,GAAA,EACAE,GAAA,IACAlC,QACAqC,gBAAAJ,GAEAC,EAAA76C,KAAA43C,GACAxR,EAAAj1B,KAAA+jC,GAAA2F,GAGAtC,GAAAr5C,QACAknC,EAAA8U,GAAA3C,GAAAluC,KAAA,KAAAouC,GAGA1qC,EAAA1P,KACA0P,EAAAotC,eACAlI,EAAAkF,EAAA3mC,EAAA1T,OAAAU,KAAAuP,EAAA1P,KAEAkxC,EAAAnJ,EAAAr4B,KAIA,QAAAktC,KACA,GAAAJ,GAAAzU,EAAAj1B,KAAA+jC,GAKA,IAAA2F,EAAA,CACA,OAAAz6C,GAAA,EAA2BA,EAAAy6C,EAAA37C,OAA2BkB,IACtDy6C,EAAAz6C,IAEAgmC,GAAAwS,WAAA1D,KAxKA,IAAA4C,EAAA,CACA,IAAAtmC,EAAA+vB,WAEA,WADAqW,IAQA,IAAAwD,GAAA,SAAAC,GACA,GAAAtD,EAQWC,GAAAqD,IACXrD,GAAA,EACAJ,SARA,IADAI,GAAAqD,EACAvE,GAAApB,kBAAA,CACA,GAAA13C,GAAAkzC,EAAA1/B,EAAAwmC,EACAA,GACAE,GAAAl4C,KAAAhC,GACAswC,EAAA4J,GAAAl6C,KAWAs9C,EAAAC,GAAA,IACAzE,GAAAvB,oBAAA,IAAAyB,GAAAzB,oBACAuB,GAAApB,mBAAA,IAAAsB,GAAAtB,oBACArzC,KAAAgJ,IAAA2rC,GAAArB,eAAAqB,GAAAxB,gBACA8F,GACAjW,EAAA0U,EACA13C,KAAAm5C,MAAAF,EAAAC,GAAApG,KACA,GAEA4E,IAIA0B,GAAAC,OAAA,WACAN,GAAA,IAGAK,GAAAE,MAAA,WACAP,GAAA,KAraA,GAAArtC,GAAA2pC,KACA3pC,GAAAmhC,aACAnhC,EAAAkhC,EAAA7pC,EAAA2I,IAGA,IAAAoqC,MACA3mC,EAAAg/B,EAAApK,EACA,KAAA50B,IACAA,EAAA+vB,aACA8U,EAAAr/B,UACA,MAAAkiC,IAGA,IAGApB,GACAE,EACAD,EACAc,GACA4C,GACAlE,GACAuC,GACAtC,GACA+C,GACAV,GAZA3B,MACAhK,GAAA9H,EAAAnB,KAAA,SACA+I,GAAAD,EAAAhgC,GAWAwqC,KAEA,QAAAxqC,EAAAgjC,WAAAzR,EAAAsc,aAAAtc,EAAAuc,YACA,MAAA3C,IAGA,IAAA4C,IAAA/tC,EAAAgK,OAAAzW,EAAAyM,EAAAgK,OACAhK,EAAAgK,MAAA1N,KAAA,KACA0D,EAAAgK,MAEAgkC,GAAAD,IAAA/tC,EAAAiuC,WACAC,GAAA,GACAC,GAAA,EAEAH,IACAE,GAAAhO,EAAA6N,GAAApL,GAAA,GACOoL,KACPG,GAAAH,IAGA/tC,EAAAg6B,WACAmU,IAAAjO,EAAAlgC,EAAAg6B,SAAA4I,IAGA5iC,EAAAi6B,cACAkU,GAAAh9C,SACAg9C,IAAA,KAEAA,IAAAjO,EAAAlgC,EAAAi6B,YAAA4I,IASA7iC,EAAAouC,mBAAAD,GAAAh9C,QACAu4C,EAAArR,EAAAr4B,EAGA,IAAAgiC,KAAAkM,GAAAC,IAAA7xC,KAAA,KAAA+xC,OACAnC,GAAA/L,GAAA,IAAA6B,GACAlI,GAAAoG,EAAA8B,GAAAwD,GACA8I,GAAArO,GAAA3vC,IAAAP,OAAAU,KAAAwvC,GAAA3vC,IAAAa,OAAA,EACAo9C,IAAAvuC,EAAAwuC,eAAA,IAAAr9C,OAAA,CAKA,KAAAo9C,KACAD,KACAtM,GACA,MAAAmJ,IAGA,IAAArC,IAAAG,EACA,IAAAjpC,EAAAipC,QAAA,GACA,GAAAwF,IAAAjK,WAAAxkC,EAAAipC,QACAA,KACAxB,gBAAAgH,GACA7G,eAAA6G,GACAjH,mBAAA,EACAG,kBAAA,OAGAmB,IAAAP,EAAA9kC,EAAAyoC,IACAjD,GAAAD,EAAAvlC,EAAAu+B,GAAA8G,GAAAhB,GAGA9nC,GAAAkqC,0BACAnJ,EAAA/G,SAAA3B,EAAA2J,GAGA,IAAA2C,GAEA,IAAA3kC,EAAA0uC,gBAAA,CACA,GAAAA,KAAA9J,EAAA5kC,EAAA0uC,gBACAzL,GAAAx/B,EAAAirC,IACAvE,GAAAl4C,KAAAy8C,IAGA,GAAA1uC,EAAAgjC,UAAA,GACA2B,GAAAlhC,EAAA+/B,MAAAoB,GAAAzzC,OAAA,CACA,IAAAw9C,IAAAjK,EAAA1kC,EAAAgjC,SAAA2B,GAGA1B,GAAAx/B,EAAAkrC,IACAxE,GAAAl4C,KAAA08C,IAGA,GAAA3uC,EAAAwuC,cAAA,CACA,GAAAA,KAAAnL,EAAArjC,EAAAwuC,cACAvL,GAAAx/B,EAAA+qC,IACArE,GAAAl4C,KAAAu8C,IAGA,GAAAhB,IAAAvE,GACAjpC,EAAA4uC,cAAA,EACA5uC,EAAA4uC,aACA3G,EAAA3a,MAAAwb,IACA,EAEA+F,GAAA,IAAArB,EAQAqB,MAAA7uC,EAAA8uC,cACA/L,EAAAt/B,EAAA4iC,GAGA,IAAA0C,IAAAM,EAAA5lC,EAAAyoC,GAAApD,IACAqD,GAAApD,GAAAS,QACAA,IAAAl1C,KAAAgJ,IAAA6uC,GAAA,GACA1C,GAAAV,GAAAU,WAEA,IAAAlH,MA6BA,IA5BAA,GAAA6J,eAAArD,GAAAvB,mBAAA,EACAjF,GAAA8J,cAAAtD,GAAApB,kBAAA,EACApF,GAAAwM,iBAAAxM,GAAA6J,gBAAA,OAAArD,GAAArB,mBACAnF,GAAAyM,wBAAAV,KACA/L,GAAA6J,iBAAA7J,GAAAwM,kBACAxM,GAAA8J,gBAAA9J,GAAA6J,gBACA7J,GAAA0M,uBAAAjvC,EAAAgjC,UAAAT,GAAA8J,cACA9J,GAAA2M,qBAAAzK,EAAAzkC,EAAA4jC,SAAArB,GAAAyM,yBAAAzM,GAAA6J,gBACA7J,GAAA+J,oBAAA7H,EAAAzkC,EAAA4jC,QAAArB,GAAA8J,cACA9J,GAAA0J,wBAAAkC,GAAAh9C,OAAA,GAEAoxC,GAAAyM,yBAAAzM,GAAA0M,0BACAxF,GAAAzpC,EAAAgjC,SAAAwB,WAAAxkC,EAAAgjC,UAAAyG,GAEAlH,GAAAyM,0BACAzM,GAAA6J,gBAAA,EACArD,GAAAvB,mBAAAiC,GACA9E,GAAAlhC,EAAA+/B,MAAAoB,EAAAqB,IAAA90C,OAAA,EACAg5C,GAAAl4C,KAAAyyC,EAAA+E,GAAA9E,MAGApC,GAAA0M,yBACA1M,GAAA8J,eAAA,EACAtD,GAAApB,kBAAA8B,GACAU,GAAAl4C,KAAAwxC,EAAAgG,OAIA,IAAAA,KAAAlH,GAAA0J,wBACA,MAAAd,IAGA,UAAAnrC,EAAA4jC,MAAA,CACA,GAAA2I,GACA,kBAAAvsC,GAAA4jC,QACA2I,GAAA/H,WAAAxkC,EAAA4jC,OAEA4F,GAAAl1C,KAAAgJ,IAAAivC,GAAA,IAGAhK,GAAA2M,sBACA/E,GAAAl4C,KAAA0xC,EAAA4I,KAGAhK,GAAA+J,qBACAnC,GAAAl4C,KAAA0xC,EAAA4I,IAAA,IAkCA,MA3BA,OAAAvsC,EAAAgjC,UAAA+F,GAAAvB,mBAAA,IACAjF,GAAA0J,wBAAA1J,GAAA0J,yBAAA4C,IAGA9C,GAAAvC,GAAApC,GACAoF,GAAA/C,GAAArC,GACApnC,EAAA8uC,eACAvM,GAAA0I,gBAAAlC,GAAAvB,mBAAA,EACAjF,GAAA2I,uBAAAnC,GAAApB,kBAAA,GACAsB,GAAArB,eAAA,GACA,IAAAqB,GAAAtB,mBAGA3nC,EAAA3P,OACA2P,EAAAotC,eACAlI,EAAAkF,EAAA3mC,EAAA1T,OAAAU,KAAAuP,EAAA3P,OAEAkxC,EAAAlJ,EAAAr4B,IAGAuiC,GAAA0I,iBAAA1I,GAAA2I,uBACAF,EAAAvB,IACOzpC,EAAA8uC,cACP/L,EAAAt/B,GAAA,IAKA4nC,eAAA,EACAD,IAAAxB,EACA1vC,MAAA,WACA,IAAA6vC,EAiBA,MAfA2D,KACAtC,IAAAxB,EACA7R,OAAA8O,EACA8G,OAAA,KACAC,MAAA,MAGA9C,GAAA,GAAA3C,GAAAuF,IAEA5G,EAAA5sC,GAMA4wC,UAgTAqE,IAAA,+BAAAC,GASA,QAAAC,GAAA5rC,GACA,MAAAA,GAAA+vB,YAAA,KAAA/vB,EAAA+vB,WAAAkN,SATA0O,EAAAE,QAAAr9C,KAAA,qBAEA,IAAAs9C,GAAA,kBACAC,EAAA,YAEAC,EAAA,gBACAC,EAAA,cAMAvgD,MAAAo7B,MAAA,8FACA,SAAAolB,EAAAne,EAAA2W,EAAAyH,EAAAre,EAAAwP,EAAA8O,GA0BA,QAAAC,GAAA3P,GAEA,MAAAA,GAAAviC,QAAA,kBAGA,QAAAmyC,GAAA59C,EAAAC,GAGA,MAFAyC,GAAA1C,SAAA0I,MAAA,MACAhG,EAAAzC,SAAAyI,MAAA,MACA1I,EAAAzB,OAAA,SAAAuI,GACA,MAAA7G,GAAA4F,QAAAiB,UACOqD,KAAA,KAGP,QAAA0zC,GAAA7P,EAAA8P,EAAAC,GAiEA,QAAAC,GAAA1gB,GACA,GAAAwQ,MAEAmQ,EAAA3N,EAAAhT,GAAA4gB,uBAgBA,OAZAz/C,IAAA,wCAAAe,GACA,GAAA1B,GAAAmgD,EAAAz+C,EACA,QAAAA,GACA,UACA1B,GAAAqgD,EAAAC,SACA,MACA,YACAtgD,GAAAqgD,EAAAE,WAGAvQ,EAAAtuC,GAAA2C,KAAAm5C,MAAAx9C,GAAA,OAEAgwC,EAGA,QAAAwQ,KACA,GAAAC,GAAAf,EAAAtrB,GACA2V,SAAAyV,EACA7L,OAAA,EACAvzC,KAAA8/C,EAAAF,IAKA,OAAAS,GAAArF,cAAAqF,EAAA,KAGA,QAAAC,GAAAtY,GACA,MAAAA,GAAAnB,KAAA,aAGA,QAAA0Z,KACA,GAAAC,GAAAf,EAAAa,EAAAT,IACArO,EAAAkO,EAAAc,EAAAC,GACAhP,EAAAiO,EAAAe,EAAAD,GAEAH,EAAAf,EAAAtrB,GACA/zB,GAAA6/C,EAAAD,GACAlW,SAAA0V,EAAA,IAAA7N,EACA5H,YAAAwV,EAAA,IAAA3N,EACA8B,OAAA,GAKA,OAAA8M,GAAArF,cAAAqF,EAAA,KAGA,QAAAtF,KACA/mB,EAAAnnB,SACA+yC,EAAAhW,YAAAsV,GACAW,EAAAjW,YAAAsV,GA1HA,GAAAlrB,GAAAoc,EAAAgC,EAAAwN,GAAAc,WAAA,IACAD,EAAAhB,EAAAa,EAAAtsB,GAEA4rB,GAAAjW,SAAAuV,GACAW,EAAAlW,SAAAuV,GAEAlrB,EAAA2V,SAAAwV,GAEAwB,EAAA/9B,OAAAoR,EAEA,IAAA4sB,GAAAC,EAAAT,GAMA,KAAAS,IACAD,EAAAL,KACAK,GACA,MAAA7F,IAIA,IAAA+F,GAAAD,GAAAD,CAEA,QACA/2C,MAAA,WA8BA,QAAA0vC,KACAwH,GACAA,EAAAhG,MA/BA,GAAAN,GAEAsG,EAAAD,EAAAj3C,OAyBA,OAxBAk3C,GAAAC,KAAA,WAEA,MADAD,GAAA,MACAH,IACAA,EAAAL,MAEAQ,EAAAH,EAAA/2C,QACAk3C,EAAAC,KAAA,WACAD,EAAA,KACAhG,IACAN,EAAAC,aAEAqG,IAIAhG,QACAN,GAAAC,cAGAD,EAAA,GAAA3C,IACAiD,IAAAxB,EACA7R,OAAA6R,MA2EA,QAAA0H,GAAAjhD,EAAAC,EAAA6vC,EAAAoR,GACA,GAAAC,GAAAC,EAAAphD,EAAAkH,GACAm6C,EAAAD,EAAAnhD,EAAAiH,GAEAo6C,IAWA,IAVA/gD,EAAA2gD,EAAA,SAAA9hB,GACA,GAAAmiB,GAAAniB,EAAA,IACAoiB,EAAApiB,EAAA,MACAihB,EAAAV,EAAA7P,EAAAyR,EAAAC,EACAnB,IACAiB,EAAA1/C,KAAAy+C,KAKAc,GAAAE,GAAA,IAAAC,EAAAxgD,OAEA,OACA+I,MAAA,WA0BA,QAAA0vC,KACAh5C,EAAAkhD,EAAA,SAAAhH,GACAA,EAAAM,QA3BA,GAAA0G,KAEAN,IACAM,EAAA7/C,KAAAu/C,EAAAt3C,SAGAw3C,GACAI,EAAA7/C,KAAAy/C,EAAAx3C,SAGAtJ,EAAA+gD,EAAA,SAAAI,GACAD,EAAA7/C,KAAA8/C,EAAA73C,UAGA,IAAA4wC,GAAA,GAAA3C,IACAiD,IAAAxB,EACA7R,OAAA6R,GAOA,OAJAzB,GAAAlyC,IAAA67C,EAAA,SAAAE,GACAlH,EAAAC,SAAAiH,KAGAlH,IAWA,QAAA2G,GAAAQ,GACA,GAAA5Z,GAAA4Z,EAAA5Z,QACAr4B,EAAAiyC,EAAAjyC,WAEAiyC,GAAAhE,aACAjuC,EAAAgK,MAAAioC,EAAAjoC,MACAhK,EAAAiuC,YAAA,EACAjuC,EAAAouC,mBAAA,EAKA,UAAA6D,EAAAjoC,QACAhK,EAAAuqC,OAAAvqC,EAAAohC,eAOAphC,EAAAgiC,qBACAhiC,EAAAgK,MAAAi4B,EAAAjiC,EAAAgK,MAAAhK,EAAAgiC,oBAGA,IAAA0O,GAAAf,EAAAtX,EAAAr4B,EAMA,OAAA0wC,GAAArF,cAAAqF,EAAA,KAtPA,IAAAnf,EAAAsc,aAAAtc,EAAAuc,YAAA,MAAAv2C,EAEA,IAAA+4C,GAAAT,EAAA,GAAAqC,KACAptB,EAAA2d,EAAAmN,GAEAoB,EAAAvQ,EAIA4O,EAAAvqB,IAAAwrB,EAAA6B,SAAArtB,KAAAwrB,EAGArP,GAAAF,EAEA,iBAAAkR,GACA,MAAAA,GAAA5hD,MAAA4hD,EAAA3hD,GACAghD,EAAAW,EAAA5hD,KACA4hD,EAAA3hD,GACA2hD,EAAA9R,QACA8R,EAAAV,SACAE,EAAAQ,QA2OAG,IAAA,4BAAApK,GACA74C,KAAAo7B,MAAA,yCACA,SAAA9uB,EAAA0sC,EAAApH,GAqQA,QAAAsR,GAAAlS,GACAA,EAAA5sC,EAAA4sC,OAAAtlC,MAAA,IAEA,QADAmB,MAAAs2C,KACAjgD,EAAA,EAAmBA,EAAA8tC,EAAAhvC,OAAoBkB,IAAA,CACvC,GAAAiuC,GAAAH,EAAA9tC,GACAkgD,EAAAvK,EAAAwK,uBAAAlS,EACAiS,KAAAD,EAAAhS,KACAtkC,EAAA/J,KAAAwJ,EAAAkiB,IAAA40B,IACAD,EAAAhS,IAAA,GAGA,MAAAtkC,GA9QA,GAAA0tC,GAAAzI,EAAAF,EAEA,iBAAA1I,EAAAruB,EAAAm2B,EAAAngC,GAkDA,QAAAyyC,KACAzyC,EAAAohC,eACAsI,EAAArR,EAAAr4B,GAGA,QAAA6pC,KACAE,GAAA,EACA0I,IACAnR,EAAAjJ,EAAAr4B,GAyEA,QAAA0yC,GAAAj8C,EAAA4hC,EAAAruB,EAAAhK,EAAAuqC,GACA,GAAA1yC,EACA,QAAAmS,GACA,cACAnS,GAAAwgC,EAAAr4B,EAAA3P,KAAA2P,EAAA1P,GAAAi6C,EACA,MAEA,gBACA1yC,GAAAwgC,EAAAsa,EAAAC,EAAArI,EACA,MAEA,gBACA1yC,GAAAwgC,EAAAsa,EAAApI,EACA,MAEA,mBACA1yC,GAAAwgC,EAAAua,EAAArI,EACA,MAEA,SACA1yC,GAAAwgC,EAAAkS,GAIA1yC,EAAA5F,KAAA+N,EAEA,IAAA/P,GAAAwG,EAAApF,MAAAoF,EAAAoB,EACA,IAAA5H,EAKA,GAJAgE,EAAAhE,EAAAiK,SACAjK,IAAAiK,SAGAjK,YAAAk4C,GACAl4C,EAAAohD,KAAA9G,OACW,IAAAt2C,EAAAhE,GAEX,MAAAA,EAIA,OAAAsH,GAGA,QAAAs7C,GAAAxa,EAAAruB,EAAAhK,EAAA6tC,EAAApzC,GACA,GAAAq4C,KAqCA,OApCAliD,GAAAi9C,EAAA,SAAAkF,GACA,GAAAhB,GAAAgB,EAAAt4C,EACAs3C,IAGAe,EAAA7gD,KAAA,WACA,GAAA64C,GACAkI,EAEAC,GAAA,EACAC,EAAA,SAAApJ,GACAmJ,IACAA,GAAA,GACAD,GAAAz7C,GAAAuyC,GACAgB,EAAAC,UAAAjB,IAkBA,OAdAgB,GAAA,GAAA3C,IACAiD,IAAA,WACA8H,KAEAnb,OAAA,WACAmb,GAAA,MAIAF,EAAAN,EAAAX,EAAA1Z,EAAAruB,EAAAhK,EAAA,SAAAxM,GACA,GAAA2/C,GAAA3/C,KAAA,CACA0/C,GAAAC,KAGArI,MAIAgI,EAGA,QAAAM,GAAA/a,EAAAruB,EAAAhK,EAAA6tC,EAAApzC,GACA,GAAAq4C,GAAAD,EAAAxa,EAAAruB,EAAAhK,EAAA6tC,EAAApzC,EACA,QAAAq4C,EAAA3hD,OAAA,CACA,GAAAgB,GAAAC,CACA,oBAAAqI,GACAtI,EAAA0gD,EAAAxa,EAAA,cAAAr4B,EAAA6tC,EAAA,qBACAz7C,EAAAygD,EAAAxa,EAAA,WAAAr4B,EAAA6tC,EAAA,mBACW,aAAApzC,IACXtI,EAAA0gD,EAAAxa,EAAA,cAAAr4B,EAAA6tC,EAAA,eACAz7C,EAAAygD,EAAAxa,EAAA,WAAAr4B,EAAA6tC,EAAA,aAGA17C,IACA2gD,IAAAxhD,OAAAa,IAEAC,IACA0gD,IAAAxhD,OAAAc,IAIA,OAAA0gD,EAAA3hD,OAGA,gBAAAiC,GACA,GAAAigD,KASA,OARAP,GAAA3hD,QACAP,EAAAkiD,EAAA,SAAAQ,GACAD,EAAAphD,KAAAqhD,OAIAD,EAAAliD,OAAAg3C,EAAAlyC,IAAAo9C,EAAAjgD,OAEA,SAAAyM,GACAjP,EAAAyiD,EAAA,SAAAvI,GACAjrC,EAAAirC,EAAA/S,SAAA+S,EAAAM,UAzPA,GAAArB,IAAA,CAKA,KAAA74C,UAAAC,QAAAuI,EAAAymC,KACAngC,EAAAmgC,EACAA,EAAA,MAGAngC,EAAAkhC,EAAAlhC,GACAmgC,IACAA,EAAA9H,EAAAnB,KAAA,aACAl3B,EAAAg6B,WACAmG,GAAA,IAAAngC,EAAAg6B,UAEAh6B,EAAAi6B,cACAkG,GAAA,IAAAngC,EAAAi6B,aAIA,IAQAsZ,GAAAC,EARAb,EAAA3yC,EAAAg6B,SACA4Y,EAAA5yC,EAAAi6B,YAMA4T,EAAAwE,EAAAlS,EAEA,IAAA0N,EAAA18C,OAAA,CACA,GAAAsiD,GAAAC,CACA,UAAA1pC,GACA0pC,EAAA,QACAD,EAAA,eAEAC,EAAA,SAAA1pC,EAAA+H,OAAA,GAAAoY,cAAAngB,EAAAxM,OAAA,GACAi2C,EAAAzpC,GAGA,UAAAA,GAAA,SAAAA,IACAupC,EAAAH,EAAA/a,EAAAruB,EAAAhK,EAAA6tC,EAAA6F,IAEAF,EAAAJ,EAAA/a,EAAAruB,EAAAhK,EAAA6tC,EAAA4F,GAIA,GAAAF,GAAAC,EAAA,CAaA,GAAA1I,EAEA,QACAO,eAAA,EACAD,IAAA,WAQA,MAPAN,GACAA,EAAAM,OAEAvB,IACAiB,EAAA,GAAA3C,GACA2C,EAAAC,UAAA,IAEAD,GAEA5wC,MAAA,WA0CA,QAAAy5C,GAAA5sC,GACA8iC,EAAA9iC,GACA+jC,EAAAC,SAAAhkC,GAGA,QAAA6sC,GAAAT,GACApJ,KACA8J,GAAAt8C,GAAA47C,GACAQ,EAAAR,IAjDA,GAAArI,EACA,MAAAA,EAGAA,GAAA,GAAA3C,EACA,IAAA0L,GACA1sC,IAiCA,OA/BAosC,IACApsC,EAAAlV,KAAA,SAAAwE,GACAo9C,EAAAN,EAAA98C,KAIA0Q,EAAAhW,OACAgW,EAAAlV,KAAA,SAAAwE,GACAg8C,IACAh8C,GAAA,KAGAg8C,IAGAe,GACArsC,EAAAlV,KAAA,SAAAwE,GACAo9C,EAAAL,EAAA/8C,KAIAq0C,EAAAgJ,SACA1I,IAAA,WACAwI,KAEA7b,OAAA,WACA6b,GAAA,MAIAzL,EAAAhhC,QAAAwsC,GACA7I,UA8JAiJ,IAAA,+BAAA3E,GACAA,EAAAE,QAAAr9C,KAAA,qBACA9C,KAAAo7B,MAAA,yCAAAypB,EAAA7L,GA+CA,QAAA8L,GAAAhC,GAEA,GAAA5Z,GAAA4Z,EAAA5Z,QACAruB,EAAAioC,EAAAjoC,MACAhK,EAAAiyC,EAAAjyC,QACAmgC,EAAA8R,EAAA9R,OACA,OAAA6T,GAAA3b,EAAAruB,EAAAm2B,EAAAngC,GApDA,gBAAAiyC,GACA,GAAAA,EAAA5hD,MAAA4hD,EAAA3hD,GAAA,CACA,GAAAkhD,GAAAyC,EAAAhC,EAAA5hD,MACAqhD,EAAAuC,EAAAhC,EAAA3hD,GACA,KAAAkhD,IAAAE,EAAA,MAEA,QACAx3C,MAAA,WAoBA,QAAAg6C,KACA,kBACAtjD,EAAAkhD,EAAA,SAAAhH,GAEAA,EAAAM,SAKA,QAAAiG,GAAAW,GACAlH,EAAAC,SAAAiH,GA7BA,GAAAF,KAEAN,IACAM,EAAA7/C,KAAAu/C,EAAAt3C,SAGAw3C,GACAI,EAAA7/C,KAAAy/C,EAAAx3C,SAGAiuC,EAAAlyC,IAAA67C,EAAAT,EAEA,IAAAvG,GAAA,GAAA3C,IACAiD,IAAA8I,IACAnc,OAAAmc,KAGA,OAAApJ,KAiBA,MAAAmJ,GAAAhC,QAeAkC,GAAA,kBACAC,GAAA,gBACAC,IAAA,4BAAArM,GAWA,QAAAsM,GAAAC,GACA,IAAAA,EACA,WAGA,IAAA9jD,GAAA8jD,EAAA15C,MAAA25C,GACAthD,EAAAnD,OAAAsyB,OAAA,KAKA,OAHAzxB,GAAAH,EAAA,SAAAkB,GACAuB,EAAAvB,IAAA,IAEAuB,EAGA,QAAAuhD,GAAAC,EAAAC,GACA,GAAAD,GAAAC,EAAA,CACA,GAAAC,GAAAN,EAAAK,EACA,OAAAD,GAAA75C,MAAA25C,GAAAK,KAAA,SAAAza,GACA,MAAAwa,GAAAxa,MAKA,QAAA0a,GAAAC,EAAA1c,EAAA+Y,EAAA4D,GACA,MAAAhqB,GAAA+pB,GAAAF,KAAA,SAAAp+C,GACA,MAAAA,GAAA4hC,EAAA+Y,EAAA4D,KAIA,QAAAC,GAAAlD,EAAAn4C,GACA,GAAAzH,IAAA4/C,EAAA/X,UAAA,IAAA7oC,OAAA,EACAiB,GAAA2/C,EAAA9X,aAAA,IAAA9oC,OAAA,CACA,OAAAyI,GAAAzH,GAAAC,EAAAD,GAAAC,EA1CA,GAAA8iD,GAAA,EACAC,EAAA,EACAX,EAAA,IAEAxpB,EAAA77B,KAAA67B,OACAoqB,QACArd,UACAz7B,QAsCA0uB,GAAA1uB,KAAArK,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAEA,OAAAxP,EAAAqM,YAAAgH,EAAArT,KAGA5W,EAAAoqB,KAAAnjD,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAGA,OAAAxP,EAAAqM,aAAAgH,EAAArT,KAGA5W,EAAAoqB,KAAAnjD,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAGA,eAAAA,EAAApnC,OAAA43B,EAAAqM,aAGAjjB,EAAAoqB,KAAAnjD,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAEA,MAAAA,GAAAnD,YAAAmD,EAAA3uC,QAAA0yC,IAAAvT,EAAAqM,aAGAjjB,EAAA+M,OAAA9lC,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAEA,MAAAA,GAAAnD,YAAArM,EAAAqM,aAGAjjB,EAAA+M,OAAA9lC,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAGA,MAAAA,GAAA3uC,QAAA0yC,GAAAvT,EAAAqM,aAGAjjB,EAAA+M,OAAA9lC,KAAA,SAAAomC,EAAAuJ,EAAAwP,GAIA,GAAAA,EAAAnD,WAAA,QAEA,IAAAoH,GAAAzT,EAAA5H,SACAsb,EAAA1T,EAAA3H,YACAsb,EAAAnE,EAAApX,SACAwb,EAAApE,EAAAnX,WAGA,SAAA5gC,EAAAg8C,IAAAh8C,EAAAi8C,IAAAj8C,EAAAk8C,IAAAl8C,EAAAm8C,MAIAf,EAAAY,EAAAG,IAAAf,EAAAa,EAAAC,MAGApmD,KAAAo7B,MAAA,4DACA,8EACA,SAAAkc,EAAAjV,EAAAoe,EAAAC,EAAA4F,EACAC,EAAAvN,EAAAwN,EAAA5U,EAAAqH,GAMA,QAAAwN,KACA,GAAAC,IAAA,CACA,iBAAAp/C,GAKAo/C,EACAp/C,IAEA+6B,EAAAskB,aAAA,WACAD,GAAA,EACAp/C,OAgDA,QAAAs/C,GAAA1d,EAAA0Z,GACA,MAAArQ,GAAArJ,EAAA0Z,MAUA,QAAAiE,GAAAt+C,EAAA2gC,EAAAruB,GACA,GAAAxG,GAAAi/B,EAAApK,GACA4d,EAAAxT,EAAA/qC,GAEAsE,KACAk6C,EAAAC,EAAAnsC,EAWA,OAVAksC,IACAtlD,EAAAslD,EAAA,SAAAnR,GACAoN,GAAA1iD,KAAAs1C,EAAAthC,KAAAD,GACAxH,EAAA/J,KAAA8yC,EAAA3xC,UACW,UAAA4W,GAAAmoC,GAAA1iD,KAAAs1C,EAAAthC,KAAAwyC,IACXj6C,EAAA/J,KAAA8yC,EAAA3xC,YAKA4I,EAGA,QAAAo6C,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAA5V,EAAA0V,EACA,OAAAD,GAAA3lD,OAAA,SAAAq0C,GACA,GAAA0R,GAAA1R,EAAAthC,OAAA+yC,KACAD,GAAAxR,EAAA3xC,WAAAmjD,EACA,QAAAE,IAIA,QAAAC,GAAAC,EAAAte,GACA,UAAAse,GAAAte,EAAA,GAAA7E,YAGA2J,GAAAsN,IAAApS,GA6FA,QAAAue,GAAAve,EAAAruB,EAAA2/B,GA0PA,QAAAkN,GAAA/L,EAAA9gC,EAAA2sC,EAAAvzC,GACA0zC,EAAA,WACA,GAAAC,GAAAf,EAAAt+C,EAAA2gC,EAAAruB,EACA+sC,GAAA5lD,OAKAs1C,EAAA,WACA71C,EAAAmmD,EAAA,SAAA3jD,GACAA,EAAAilC,EAAAse,EAAAvzC,KAEAszC,EAAAC,EAAAte,KAGAqe,EAAAC,EAAAte,KAGAyS,EAAAkM,SAAAhtC,EAAA2sC,EAAAvzC,GAGA,QAAAymC,GAAAhqC,GACAijC,EAAAzK,EAAAr4B,GACA0pC,GAAArR,EAAAr4B,GACAshC,EAAAjJ,EAAAr4B,GACAA,EAAAohC,eACA0J,EAAAC,UAAAlrC,GAhRA,GAEA4D,GAAA/L,EAFAsI,EAAA3I,EAAAsyC,EAGAtR,GAAAmI,EAAAnI,GACAA,IACA50B,EAAAg/B,EAAApK,GACA3gC,EAAA2gC,EAAA3gC,UAGAsI,EAAAkhC,EAAAlhC,EAIA,IAAA8qC,GAAA,GAAA3C,GAGA2O,EAAAlB,GA6BA,IA3BAriD,EAAAyM,EAAAg6B,YACAh6B,EAAAg6B,SAAAh6B,EAAAg6B,SAAA19B,KAAA,MAGA0D,EAAAg6B,WAAAnlC,EAAAmL,EAAAg6B,YACAh6B,EAAAg6B,SAAA,MAGAzmC,EAAAyM,EAAAi6B,eACAj6B,EAAAi6B,YAAAj6B,EAAAi6B,YAAA39B,KAAA,MAGA0D,EAAAi6B,cAAAplC,EAAAmL,EAAAi6B,eACAj6B,EAAAi6B,YAAA,MAGAj6B,EAAA3P,OAAAqJ,EAAAsG,EAAA3P,QACA2P,EAAA3P,KAAA,MAGA2P,EAAA1P,KAAAoJ,EAAAsG,EAAA1P,MACA0P,EAAA1P,GAAA,OAMAmT,EAEA,MADAomC,KACAiB,CAGA,IAAA1Q,IAAA32B,EAAA22B,UAAAp6B,EAAAg6B,SAAAh6B,EAAAi6B,aAAA39B,KAAA,IACA,KAAA26C,GAAA7c,GAEA,MADAyP,KACAiB,CAGA,IAAAkD,IAAA,wBAAAh2C,QAAAgS,IAAA,EAEAktC,EAAArH,EAAA,GAAAsH,OAOAC,GAAAC,GAAAH,GAAAI,EAAA35B,IAAAla,GACA8zC,GAAAH,GAAAI,EAAA75B,IAAAla,OACAg0C,IAAAF,EAAA90C,KAQA,IAJA20C,GAAAK,GAAAF,EAAA90C,OAAAyyC,IACAkC,GAAAM,EAAArf,EAAA3gC,EAAAsS,IAGAotC,EAKA,MAHAF,IAAAL,EAAA/L,EAAA9gC,EAAA,SACA6/B,IACAqN,GAAAL,EAAA/L,EAAA9gC,EAAA,SACA8gC,CAGAkD,IACA2J,EAAAtf,EAGA,IAAAuJ,IACAqM,WAAAD,EACA3V,UACAruB,QACAgwB,SAAAh6B,EAAAg6B,SACAC,YAAAj6B,EAAAi6B,YACA4P,QACA7pC,UACA8qC,SAGA,IAAA2M,EAAA,CACA,GAAAG,GAAA9C,EAAA,OAAAzc,EAAAuJ,EAAA2V,EACA,IAAAK,EACA,MAAAL,GAAA90C,QAAA0yC,GACAtL,IACAiB,IAEApJ,EAAArJ,EAAAkf,EAAA3V,GACA2V,EAAAzM,OAGA,IAAA+M,GAAA/C,EAAA,SAAAzc,EAAAuJ,EAAA2V,EACA,IAAAM,EACA,GAAAN,EAAA90C,QAAA0yC,EAIAoC,EAAAzM,OAAAM,UACW,KAAAmM,EAAAtJ,WASX,MAFAvM,GAAArJ,EAAAkf,EAAA3V,GAEA2V,EAAAzM,MALAyM,GAAA1N,YAOS,CAIT,GAAAiO,GAAAhD,EAAA,OAAAzc,EAAAuJ,EAAA2V,EACA,IAAAO,EAAA,CACA,GAAAP,EAAA90C,QAAA0yC,EAUA,MAPAzS,GAAArK,EAAA2V,EAAAhkC,EAAA,KAAAhK,GAEAgK,EAAA43B,EAAA53B,MAAAutC,EAAAvtC,MACAhK,EAAA0hC,EAAArJ,EAAAkf,EAAA3V,GAIA2V,EAAAzM,MATAiL,GAAA1d,EAAAuJ,SAgBAmU,GAAA1d,EAAAuJ,EAMA,IAAAmW,GAAAnW,EAAAqM,UAOA,IANA8J,IAEAA,EAAA,YAAAnW,EAAA53B,OAAAja,OAAAU,KAAAmxC,EAAA5hC,QAAA1P,QAAyGa,OAAA,GACzG8jD,EAAArT,KAGAmW,EAGA,MAFAlO,KACAmO,EAAA3f,GACAyS,CAIA,IAAAmN,IAAAV,EAAAU,SAAA,IA0EA,OAzEArW,GAAAqW,UAEAC,EAAA7f,EAAA6c,EAAAtT,GAEApQ,EAAAskB,aAAA,WACA,GAAA7D,GAAAuF,EAAA75B,IAAAla,GACA00C,GAAAlG,CACAA,QAKA,IAAAmG,GAAA/f,EAAA3gC,aAIAqgD,EAAAK,EAAAjnD,OAAA,IACA,YAAA8gD,EAAAjoC,OACAioC,EAAAhE,YACAgH,EAAAhD,GAIA,IAAAkG,GAAAlG,EAAAgG,cAAAF,EAuBA,MAnBAI,KACAzO,GAAArR,EAAAr4B,GACAshC,EAAAjJ,EAAAr4B,KAKAm4C,GAAAnK,GAAAiE,EAAAjoC,aACAhK,EAAAohC,eACA0J,EAAAM,YAMA2M,GACAC,EAAA3f,GAQAruB,IAAAioC,EAAAhE,YAAAgH,EAAAhD,GAAA,GACA,WACAA,EAAAjoC,MAEAkuC,EAAA7f,EAAA8c,EACA,IAAAkD,GAAA3C,EAAArd,EAAAruB,EAAAioC,EAAAjyC,QAIA8qC,GAAAgJ,QAAAuE,GACAxB,EAAA/L,EAAA9gC,EAAA,YAEAquC,EAAAhH,KAAA,SAAAW,GACAnI,GAAAmI,EACA,IAAAC,GAAAuF,EAAA75B,IAAAla,EACAwuC,MAAAgG,aACAD,EAAAvV,EAAApK,IAEAwe,EAAA/L,EAAA9gC,EAAA,gBAIA8gC,EAgCA,QAAA6M,GAAAtf,GACA,GAAA50B,GAAAg/B,EAAApK,GACAsD,EAAAl4B,EAAA60C,iBAAA,IAAAnE,GAAA,IACAvjD,GAAA+qC,EAAA,SAAA4c,GACA,GAAA91C,GAAA2G,SAAAmvC,EAAA3P,aAAAuL,KACAlC,EAAAuF,EAAA75B,IAAA46B,EACA,IAAAtG,EACA,OAAAxvC,GACA,IAAA0yC,GACAlD,EAAAnH,OAAAM,KAEA,KAAA8J,GACAsC,EAAAt6C,OAAAq7C,MAOA,QAAAP,GAAA3f,GACA,GAAA50B,GAAAg/B,EAAApK,EACA50B,GAAA+0C,gBAAArE,IACAqD,EAAAt6C,OAAAuG,GAGA,QAAAg1C,GAAAC,EAAAC,GACA,MAAAlW,GAAAiW,KAAAjW,EAAAkW,GAUA,QAAAjB,GAAArf,EAAA+f,EAAApuC,GACA,GAIA4uC,GAJAC,EAAApY,EAAAoP,EAAA,GAAAqC,MACA4G,EAAAL,EAAApgB,EAAAwgB,IAAA,SAAAxgB,EAAA,GAAApB,SACA8hB,EAAAN,EAAApgB,EAAAuX,GACAoJ,GAAA,EAEAC,EAAA3B,EAAA35B,IAAA8kB,EAAApK,IAEA6gB,EAAAzY,EAAAr9B,KAAAi1B,EAAA,GAAA+b,GAOA,KANA8E,IACAd,EAAAc,GAGAd,EAAA3V,EAAA2V,GAEAA,IACAW,IAGAA,EAAAN,EAAAL,EAAAxI,IAGAwI,EAAA1X,WAAAC,IAPA,CAYA,GAAAwY,GAAA3B,EAAA75B,IAAAy6B,MAIA,KAAAY,EAAA,CACA,GAAAI,GAAA9B,EAAA35B,IAAAy6B,EAEA,IAAAgB,KAAA,GAAAH,KAAA,GAGAA,GAAA,CAEA,OACWG,KAAA,IACXH,GAAA,GAEAD,EAAAG,EAAAlL,WAGA,GAAA50C,EAAAu/C,SAAA,GACA,GAAA3oD,GAAAwwC,EAAAr9B,KAAAg1C,EAAAzS,GACArsC,GAAArJ,KACA2oD,EAAA3oD,GAKA,GAAA+oD,GAAAJ,KAAA,OAQA,IANAE,IAGAA,EAAAL,EAAAL,EAAAS,IAGAC,GAAAC,EAGA,KAaAX,GAVAW,KAEAG,EAAAzY,EAAAr9B,KAAAg1C,EAAAhE,KAQAgE,EAAA5kB,WALAiP,EAAAyW,GAQA,GAAAG,KAAAL,GAAAJ,IAAAK,KAAA,CACA,OAAAI,IAAAN,GAAAD,EAGA,QAAAZ,GAAA7f,EAAA51B,EAAA02C,GACAA,QACAA,EAAA12C,OAEA,IAAAgB,GAAAg/B,EAAApK,EACA50B,GAAA61C,aAAAnF,GAAA1xC,EAEA,IAAA82C,GAAA/B,EAAA75B,IAAAla,GACA+1C,EAAAD,EACAhoD,EAAAgoD,EAAAJ,GACAA,CACA3B,GAAAvS,IAAAxhC,EAAA+1C,GApmBA,GAAAhC,GAAA,GAAA/B,GACA6B,EAAA,GAAA7B,GACA4B,EAAA,KAwBAoC,EAAAjoB,EAAA2B,OACA,WAAkB,WAAAwiB,EAAA+D,sBAClB,SAAAC,GACAA,IACAF,IASAjoB,EAAAskB,aAAA,WACAtkB,EAAAskB,aAAA,WAGA,OAAAuB,IACAA,GAAA,UAOAlB,KAIAyD,GAAA5R,EAAA4R,kBACA3C,GAAA2C,GAEA,SAAAxf,GACA,MAAAwf,IAAAtxB,KAAA8R,IAFA,WAA4B,UAK5BsP,GAAAzI,EAAAF,GAOAoR,GAAAr7C,EAAA2N,KAAA7M,UAAAu6C,UAAA,SAAAvS,GAEA,MAAAzwC,QAAAywC,MAAA,GAAAzwC,KAAA0qD,wBAAAja,KAwCAzC,IACAgQ,GAAA,SAAAnjC,EAAA8vC,EAAA1mD,GACA,GAAAqQ,GAAAm9B,EAAAkZ,EACA3D,GAAAnsC,GAAAmsC,EAAAnsC,OACAmsC,EAAAnsC,GAAA/X,MACAwR,OACArQ,aAIAqtC,EAAAqZ,GAAA3M,GAAA,sBACA,GAAA8E,GAAAuF,EAAA75B,IAAAla,EAEAwuC,IAIA9U,GAAAsN,IAAAzgC,EAAA8vC,EAAA1mD,MAKAq3C,IAAA,SAAAzgC,EAAA8vC,EAAA1mD,GACA,OAAAlC,UAAAC,QAAA4F,EAAAlC,SAAA3D,UAAA,KASA,GAAAglD,GAAAC,EAAAnsC,EACAksC,KAEAC,EAAAnsC,GAAA,IAAA9Y,UAAAC,OACA,KACAilD,EAAAF,EAAA4D,EAAA1mD,QAdA,CACA0mD,EAAA5oD,UAAA,EACA,QAAA6oD,KAAA5D,GACAA,EAAA4D,GAAA3D,EAAAD,EAAA4D,GAAAD,KAcAE,IAAA,SAAA3hB,EAAA+f,GACAzY,EAAA4F,EAAAlN,GAAA,4BACAsH,EAAA4F,EAAA6S,GAAA,kCACA/f,EAAAj1B,KAAAgxC,GAAAgE,IAGAnmD,KAAA,SAAAomC,EAAAruB,EAAAhK,EAAAohC,GAGA,MAFAphC,SACAA,EAAAohC,eACAwV,EAAAve,EAAAruB,EAAAhK,IAQAiJ,QAAA,SAAAovB,EAAAjgB,GACA,GAAA6hC,GAAA/oD,UAAAC,MAEA,QAAA8oD,EAEA7hC,IAAAi/B,MACS,CACT,GAAA6C,GAAA3U,EAAAlN,EAEA,IAAA6hB,EAGW,CACX,GAAAz2C,GAAAg/B,EAAApK,GACA8hB,EAAA7C,EAAA35B,IAAAla,EAEA,KAAAw2C,EAEA7hC,GAAA+hC,EAGA7C,EAAArS,IAAAxhC,GAAA2U,OAVAA,GAAAi/B,IAAAhf,EAeA,MAAAjgB,IAIA,OAAA+kB,QAmaAid,IAAA,4BAAApS,GAOA,QAAAqS,GAAAhiB,EAAAyS,GACAzS,EAAAj1B,KAAAk3C,EAAAxP,GAGA,QAAAyP,GAAAliB,GACAA,EAAAwS,WAAAyP,GAGA,QAAAE,GAAAniB,GACA,MAAAA,GAAAj1B,KAAAk3C,GAfA,GAAAG,GAAA,iBAEAnL,EAAAngD,KAAAmgD,WAEAgL,EAAA,mBAcAnrD,MAAAo7B,MAAA,mFACA,SAAAwW,EAAAvP,EAAA/1B,EAAA0sC,EAAAsN,EAAApN,GAKA,QAAAqS,GAAA7M,GAqBA,QAAA8M,GAAA5V,GACA,GAAAA,EAAA6V,UAAA,MAAA7V,EACAA,GAAA6V,WAAA,CAEA,IAAAC,GAAA9V,EAAA+V,QACAtnB,EAAAqnB,EAAArnB,UACAunB,GAAA9V,IAAA4V,EAAA9V,EAGA,KADA,GAAAiW,GACAxnB,GAAA,CAEA,GADAwnB,EAAAD,EAAAp9B,IAAA6V,GACA,CACAwnB,EAAAJ,YACAI,EAAAL,EAAAK,GAEA,OAEAxnB,eAIA,OADAwnB,GAAAC,GAAAtf,SAAA1pC,KAAA8yC,GACAA,EAGA,QAAAlsC,GAAAoiD,GACA,GAEA5oD,GAFAmB,KACAmrB,IAGA,KAAAtsB,EAAA,EAAmBA,EAAA4oD,EAAAtf,SAAAxqC,OAA0BkB,IAC7CssB,EAAA1sB,KAAAgpD,EAAAtf,SAAAtpC,GAGA,IAAA6oD,GAAAv8B,EAAAxtB,OACAgqD,EAAA,EACAC,IAEA,KAAA/oD,EAAA,EAAmBA,EAAAssB,EAAAxtB,OAAkBkB,IAAA,CACrC,GAAA0yC,GAAApmB,EAAAtsB,EACA6oD,IAAA,IACAA,EAAAC,EACAA,EAAA,EACA3nD,EAAAvB,KAAAmpD,GACAA,MAEAA,EAAAnpD,KAAA8yC,EAAAtuC,IACAsuC,EAAApJ,SAAA/qC,QAAA,SAAAyqD,GACAF,IACAx8B,EAAA1sB,KAAAopD,KAEAH,IAOA,MAJAE,GAAAjqD,QACAqC,EAAAvB,KAAAmpD,GAGA5nD,EA7EA,GACAnB,GADA4oD,GAAkBtf,aAClBof,EAAA,GAAAtF,EAIA,KAAApjD,EAAA,EAAiBA,EAAAw7C,EAAA18C,OAAuBkB,IAAA,CACxC,GAAA0/C,GAAAlE,EAAAx7C,EACA0oD,GAAA9V,IAAA8M,EAAA+I,QAAAjN,EAAAx7C,IACAyoD,QAAA/I,EAAA+I,QACArkD,GAAAs7C,EAAAt7C,GACAklC,cAIA,IAAAtpC,EAAA,EAAiBA,EAAAw7C,EAAA18C,OAAuBkB,IACxCsoD,EAAA9M,EAAAx7C,GAGA,OAAAwG,GAAAoiD,GAtBA,GAAAK,MACA5R,EAAAzI,EAAAF,EAqFA,iBAAA1I,EAAAruB,EAAAhK,GAqHA,QAAAu7C,GAAA93C,GACA,GAAA+3C,GAAA,IAAAf,EAAA,IACA79C,EAAA6G,EAAAg4C,aAAAhB,IACAh3C,GACAA,EAAA60C,iBAAAkD,GACAjK,IAOA,OANA3gD,GAAAgM,EAAA,SAAA6G,GACA,GAAAyzB,GAAAzzB,EAAAmlC,aAAA6R,EACAvjB,MAAA/lC,QACAogD,EAAAt/C,KAAAwR,KAGA8tC,EAGA,QAAAmK,GAAA7N,GACA,GAAA8N,MACAC,IACAhrD,GAAAi9C,EAAA,SAAAkE,EAAAtpB,GACA,GAAA4P,GAAA0Z,EAAA1Z,QACA50B,EAAAg/B,EAAApK,GACAruB,EAAA+nC,EAAA/nC,MACA6xC,GAAA,gBAAA7jD,QAAAgS,IAAA,EACA8xC,EAAA/J,EAAA9D,WAAAsN,EAAA93C,KAEA,IAAAq4C,EAAA3qD,OAAA,CACA,GAAA4qD,GAAAF,EAAA,WAEAjrD,GAAAkrD,EAAA,SAAArsB,GACA,GAAA99B,GAAA89B,EAAAmZ,aAAA6R,EACAmB,GAAAjqD,GAAAiqD,EAAAjqD,OACAiqD,EAAAjqD,GAAAoqD,IACAC,YAAAvzB,EACA4P,QAAAoI,EAAAhR,UAIAksB,GAAA1pD,KAAA8/C,IAIA,IAAAkK,MACAC,IAqDA,OApDAtrD,GAAAgrD,EAAA,SAAA9I,EAAAnhD,GACA,GAAAtB,GAAAyiD,EAAAziD,KACAC,EAAAwiD,EAAAxiD,EAEA,KAAAD,IAAAC,EAAA,CAGA,GAAAm4B,GAAAp4B,IAAA2rD,YAAA1rD,EAAA0rD,YACAG,EAAA1zB,EAAAnyB,UAKA,aAJA2lD,EAAAE,KACAF,EAAAE,IAAA,EACAR,EAAA1pD,KAAA47C,EAAAplB,MAKA,GAAA+oB,GAAA3D,EAAAx9C,EAAA2rD,aACAtK,EAAA7D,EAAAv9C,EAAA0rD,aACAI,EAAA/rD,EAAA2rD,YAAA1lD,UACA,KAAA4lD,EAAAE,GAAA,CACA,GAAArjB,GAAAmjB,EAAAE,IACAnO,YAAA,EACAoO,YAAA,WACA7K,EAAA6K,cACA3K,EAAA2K,eAEAxS,MAAA,WACA2H,EAAA3H,QACA6H,EAAA7H,SAEA1J,QAAAmc,EAAA9K,EAAArR,QAAAuR,EAAAvR,SACA9vC,KAAAmhD,EACAlhD,GAAAohD,EACAH,WAMAxY,GAAAoH,QAAAhvC,OACAwqD,EAAA1pD,KAAA8mC,IAEA4iB,EAAA1pD,KAAAu/C,GACAmK,EAAA1pD,KAAAy/C,IAIAwK,EAAAE,GAAA7K,QAAAt/C,MACAsqD,IAAAlsD,EAAAgoC,QAAAmkB,KAAAlsD,EAAA+nC,YAIAsjB,EAGA,QAAAW,GAAAnqD,EAAAC,GACAD,IAAA0I,MAAA,KACAzI,IAAAyI,MAAA,IAGA,QAFAmB,MAEA3J,EAAA,EAAuBA,EAAAF,EAAAhB,OAAckB,IAAA,CACrC,GAAAoqD,GAAAtqD,EAAAE,EACA,YAAAoqD,EAAAzqC,UAAA,KAEA,OAAA2H,GAAA,EAAyBA,EAAAvnB,EAAAjB,OAAcwoB,IACvC,GAAA8iC,IAAArqD,EAAAunB,GAAA,CACA3d,EAAA/J,KAAAwqD,EACA,QAKA,MAAAzgD,GAAAM,KAAA,KAGA,QAAAogD,GAAAzK,GAGA,OAAA5/C,GAAAi9C,EAAAn+C,OAAA,EAAwCkB,GAAA,EAAQA,IAAA,CAChD,GAAAsqD,GAAArN,EAAAj9C,GACAnD,EAAAuM,EAAAkiB,IAAAg/B,GACAC,EAAA1tD,EAAA+iD,EACA,IAAA2K,EACA,MAAAA,IAKA,QAAAP,KACAhkB,EAAA2B,SAAA0L,IACAmX,GACA9b,EAAA/G,SAAA3B,EAAAwkB,GAEAC,IACA/b,EAAA9G,YAAA5B,EAAAykB,GACAA,EAAA,MAIA,QAAAC,GAAAhL,EAAAiL,GAQA,QAAAhiC,GAAAqd,GACA,GAAAyS,GAAA0P,EAAAniB,EACAyS,MAAAgJ,QAAAkJ,GATAjL,EAAA1hD,MAAA0hD,EAAAzhD,IACA0qB,EAAA+2B,EAAA1hD,KAAAgoC,SACArd,EAAA+2B,EAAAzhD,GAAA+nC,UAEArd,EAAA+2B,EAAA1Z,SASA,QAAA4kB,KACA,GAAAnS,GAAA0P,EAAAniB,IACAyS,GAAA,UAAA9gC,GAAAhK,EAAAqhC,qBACAyJ,EAAAM,MAIA,QAAAvB,GAAAC,GACAzR,EAAAoS,IAAA,WAAAwS,GACA1C,EAAAliB,GAEAqR,EAAArR,EAAAr4B,GACAshC,EAAAjJ,EAAAr4B,GACAA,EAAAohC,eAEAyb,GACA9b,EAAA9G,YAAA5B,EAAAwkB,GAGAxkB,EAAA4B,YAAAyL,IACAoF,EAAAC,UAAAjB,GApSA9pC,EAAAkhC,EAAAlhC,EACA,IAAAguC,IAAA,wBAAAh2C,QAAAgS,IAAA,EAMA8gC,EAAA,GAAA3C,IACAiD,IAAA,WAAyBvB,KACzB9R,OAAA,WAA4B8R,GAAA,KAG5B,KAAAyF,EAAAn+C,OAEA,MADA04C,KACAiB,CAGAuP,GAAAhiB,EAAAyS,EAEA,IAAA3K,GAAAJ,EAAA1H,EAAAnB,KAAA,SAAA6I,EAAA//B,EAAAg6B,SAAAh6B,EAAAi6B,cACA4iB,EAAA78C,EAAA68C,WACAA,KACA1c,GAAA,IAAA0c,EACA78C,EAAA68C,YAAA,KAGA,IAAAC,EAuBA,OAtBA9O,KACA8O,EAAA,MAAA9yC,EAAAy7B,GACA1E,EAAA/G,SAAA3B,EAAAykB,IAGAxB,EAAArpD,MAGAomC,UACA8H,UACAn2B,QACAikC,WAAAD,EACAhuC,UACAq8C,cACAxS,UAGAxR,EAAA8U,GAAA,WAAA8P,GAKA3B,EAAAnqD,OAAA,EAAA25C,GAEAtZ,EAAAskB,aAAA,WACA,GAAAjI,KACAj9C,GAAA0qD,EAAA,SAAAvW,GAIAyV,EAAAzV,EAAA1M,SACAwV,EAAA57C,KAAA8yC,GAEAA,EAAA8E,UAKAyR,EAAAnqD,OAAA,CAEA,IAAA+rD,GAAAxB,EAAA7N,GACAsP,IAEAvsD,GAAAssD,EAAA,SAAAE,GACAD,EAAAlrD,MACA6oD,QAAArY,EAAA2a,EAAA/sD,KAAA+sD,EAAA/sD,KAAAgoC,QAAA+kB,EAAA/kB,SACA5hC,GAAA,WAIA2mD,EAAAf,aAEA,IAAAgB,GAAAC,EAAAF,EAAAvT,MAIA0T,EAAAH,EAAA7L,QACA6L,EAAA/sD,KAAAgoC,SAAA+kB,EAAA9sD,GAAA+nC,QACA+kB,EAAA/kB,OAEA,IAAAmiB,EAAA+C,GAAA,CACA,GAAAC,GAAAd,EAAAU,EACAI,KACAH,EAAAG,EAAAtjD,OAIA,GAAAmjD,EAEe,CACf,GAAAI,GAAAJ,GACAI,GAAApM,KAAA,SAAAW,GACAsL,GAAAtL,KAEA+K,EAAAK,EAAAK,OANAH,UAeAjV,EAAAqS,EAAAyC,MAGArS,QAgRA4S,IAAA,iCAAAvgB,EAAA3L,GACA,OACA0G,SAAA,IACA2F,WAAA,UACAD,UAAA,EACAjxB,SAAA,IACAyrB,KAAA,SAAAxC,EAAA0D,EAAArE,EAAA0oB,EAAA5f,GACA,GAAA6f,GAAAC,CACAjoB,GAAAkoB,iBAAA7oB,EAAA8oB,eAAA9oB,EAAA,gBAAAhlC,GACA2tD,GACAzgB,EAAAI,MAAAqgB,GAEAC,IACAA,EAAAvf,WACAuf,EAAA,OAEA5tD,GAAA,IAAAA,KACA4tD,EAAAjoB,EAAA+I,OACAZ,EAAA8f,EAAA,SAAAxlB,GACAulB,EAAAvlB,EACA8E,EAAAG,MAAAjF,EAAA,KAAAiB,WA4uBAviC,GAAAxJ,OAAA,gBACAmtC,UAAA,gBAAAgjB,IAEAhjB,UAAA,oBAAAqM,IACA73C,QAAA,iBAAAs3C,IAEA1S,SAAA,iBAAAugB,IACAvgB,SAAA,cAAAsmB,IAEAtmB,SAAA,cAAAiU,IACAjU,SAAA,qBAAAqb,IAEArb,SAAA,cAAAse,IACAte,SAAA,oBAAAigB,KAGCj9C,cAAAC,UJslPK,SAASxJ,EAAQC,EAASC,GKvoXhC,YA8BA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GA5BvFoC,OAAOC,eAAexC,EAAS,cAC9ByC,OAAO,GAHR,IAAAnC,GAAAL,EAAA,GAQIM,EAAYL,EAAuBI,GANvCU,EAAAf,EAAA,GAUIgB,EAAaf,EAAuBc,GATxCwvD,EAAAvwD,EAAA,IAaIwwD,EAAwBvwD,EAAuBswD,GAXnDtvD,EAAAjB,EAAA,IAeIkB,EAASjB,EAAuBgB,GAdpCE,EAAAnB,EAAA,IAkBIoB,EAAWnB,EAAuBkB,GAhBtCE,EAAArB,EAAA,IAoBIsB,EAAYrB,EAAuBoB,EAlBvCf,cAAQR,OAAO,mBAAmBkB,aAAAE,aAAAE,eAChCkkC,WAAW,sBADbkrB,cAEEjvD,OAFFD,cAwBAvB,aApBe,mBLiqXT,SAASD,EAAQC,EAASC,GM/qXhC,YAkBA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAhBvFoC,OAAOC,eAAexC,EAAS,cAC9ByC,OAAO,GAHR,IAAAnC,GAAAL,EAAA,GAQIM,EAAYL,EAAuBI,GANvCowD,EAAAzwD,EAAA,IAUI0wD,EAAsBzwD,EAAuBwwD,GATjDE,EAAA3wD,EAAA,IAaI4wD,EAAqB3wD,EAAuB0wD,EAXhDrwD,cAAQR,OAAO,qBACbymC,QAAQ,mBADVqqB,cAEErqB,QAAQ,oBAFVmqB,cAiBA3wD,aAbe,kBNksXT,SAASD,EAAQC,GO3sXvB,YAQA,SAAS8wD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhH1uD,OAAOC,eAAexC,EAAS,cAC9ByC,OAAO,GAGR,IAAIyuD,GAAe,WAAc,QAASC,GAAiBnuC,EAAQouC,GAAS,IAAK,GAAIvsD,GAAI,EAAGA,EAAIusD,EAAMztD,OAAQkB,IAAK,CAAE,GAAIwsD,GAAaD,EAAMvsD,EAAIwsD,GAAWh+B,WAAag+B,EAAWh+B,aAAc,EAAOg+B,EAAW/9B,cAAe,EAAU,SAAW+9B,KAAYA,EAAWC,UAAW,GAAM/uD,OAAOC,eAAewgB,EAAQquC,EAAWltD,IAAKktD,IAAiB,MAAO,UAAUL,EAAaO,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBH,EAAY5mD,UAAWmnD,GAAiBC,GAAaL,EAAiBH,EAAaQ,GAAqBR,MAH1hBS,EAUc,WARlB,QAAAA,GAAaxtB,EAAOj2B,GAAI8iD,EAAAnvD,KAAA8vD,GACvB9vD,KAAK+vD,SAAW,uBAChB/vD,KAAKsiC,MAAQA,EACbtiC,KAAKqM,GAAKA,EACVrM,KAAK+Z,cACN/Z,KAAKgwD,gBA8GN,MAhGAT,GAAaO,IACZttD,IAAK,gBACL1B,MAAO,WAXP,QAASmvD,GAAgB5rD,GACxBoW,QAAQC,IAAI,sBACZD,QAAQC,IAAIrW,EACZ,IAAM6rD,GAAU,SAAC7rD,GAAD,MAAYA,GAAO4P,KAEnC,OADAjU,MAAK+Z,WAAam2C,EAAQ7rD,GACnBrE,KAAK+Z,WAGb,MAAI/Z,MAAK+Z,WAAW/X,QACnByY,QAAQC,IAAK1a,KAAK+Z,YACX/Z,KAAKqM,GAAGiQ,KAAMtc,KAAK+Z,cAG1BU,QAAQC,IAAK,iBACN1a,KAAKsiC,MAAM9T,IAAKxuB,KAAK+vD,UAAWp/C,KAAMs/C,OAkB9CztD,IAAK,qBACL1B,MAAO,WAdP,MAAOd,MAAKgwD,mBAkBZxtD,IAAK,yBACL1B,MAAO,WAfP,MAAOd,MAAKgwD,gBAAkBhwD,KAAKgwD,gBAAgBxuD,KAAO,MAmB1DgB,IAAK,qBACL1B,MAAO,SAjBWoZ,GAEhB,MADAla,MAAKgwD,gBAAkB91C,EAChBla,KAAKgwD,mBAoBdxtD,IAAK,iBACL1B,MAAO,SAlBQoZ,GACbA,EAAS9Z,GAAKJ,KAAK+Z,WAAW/X,OAC9BhC,KAAK+Z,WAAWjX,KAAKoX,MAqBvB1X,IAAK,iBACL1B,MAAO,SAnBOoZ,GACZi2C,EAAEpiD,OAAO/N,KAAK+Z,WAAY,SAAUvZ,GAClC,MAAOA,GAAEJ,IAAM8Z,EAAS9Z,QAuB5BoC,IAAK,kBACL1B,MAAO,SApBQsvD,GACf,GAAIjiC,GAAW9hB,GAAG8F,QACZk+C,EAAQ,SAACC,GAAD,MAAcA,GAASlwD,KAAO6Z,SAASm2C,EAAY,KAC3DG,EAAe,SAACH,GAAD,MAAgBD,GAAE1rD,KAAK+rD,UAAWH,IACnDI,EAAgBF,EAAaH,EAQ/B,OANIpwD,MAAKwwD,UACPriC,EAASzY,QAAS+6C,GAElBzwD,KAAK0wD,eACH//C,KAAM,iBAAMwd,GAASzY,QAAS+6C,KAE3BtiC,EAAS/b,WA4BlB5P,IAAK,oBACL1B,MAAO,SA1BW6vD,GAClB,GAAIxiC,GAAW9hB,GAAG8F,QACZy+C,EAAU,SAAC12C,GAAD,MAAcA,GAAS1Y,MAAQmvD,GACzCE,EAAe,iBAAMV,GAAE1rD,KAAKsV,WAAY62C,IAC1CE,EAAgBD,GASpB,OAPI92C,YACFoU,EAASzY,QAASo7C,GAElB9wD,KAAK+wD,gBACJpgD,KAAM,iBAAMwd,GAASzY,QAASo7C,KAG1B3iC,EAAS/b,YAmCV09C,IA7BRA,GAAchiC,SAAW,QAAS,MAkClCzvB,aAhCeyxD,GPivXT,SAAS1xD,EAAQC,GQ90XvB,YAQA,SAAS8wD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhH1uD,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAGT,IAAIyuD,GAAe,WAAc,QAASC,GAAiBnuC,EAAQouC,GAAS,IAAK,GAAIvsD,GAAI,EAAGA,EAAIusD,EAAMztD,OAAQkB,IAAK,CAAE,GAAIwsD,GAAaD,EAAMvsD,EAAIwsD,GAAWh+B,WAAag+B,EAAWh+B,aAAc,EAAOg+B,EAAW/9B,cAAe,EAAU,SAAW+9B,KAAYA,EAAWC,UAAW,GAAM/uD,OAAOC,eAAewgB,EAAQquC,EAAWltD,IAAKktD,IAAiB,MAAO,UAAUL,EAAaO,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBH,EAAY5mD,UAAWmnD,GAAiBC,GAAaL,EAAiBH,EAAaQ,GAAqBR,MAN1hB2B,EAUa,WARjB,QAAAA,GAAa1uB,EAAOj2B,GAAI8iD,EAAAnvD,KAAAgxD,GACvBhxD,KAAK+vD,SAAU,sBACf/vD,KAAKsiC,MAAQA,EACbtiC,KAAKqM,GAAKA,EACVrM,KAAKwwD,aAoFN,MAtEAjB,GAAayB,IACXxuD,IAAK,eACL1B,MAAO,WAXT,GAAMovD,GAAU,SAAC7rD,GAAD,MAAYA,GAAO4P,MAC7Bg9C,EAAiB,SAAC5sD,GACvB,GAAImsD,GAAYN,EAAQ7rD,EACrB,OAAOmsD,GAIX,OAAIxwD,MAAKwwD,UACDxwD,KAAKqM,GAAGiQ,KAAKtc,KAAKwwD,WAGjBxwD,KAAKsiC,MAAM9T,IAAKxuB,KAAK+vD,UAC1Bp/C,KAAKsgD,MAiBPzuD,IAAK,kBACL1B,MAAO,SAdMsvD,GACf,GAAIjiC,GAAW9hB,GAAG8F,QACZk+C,EAAQ,SAACC,GAAD,MAAcA,GAASlwD,KAAO6Z,SAASm2C,EAAY,KAC3DG,EAAe,iBAAMJ,GAAE1rD,KAAK+rD,UAAWH,IACzCI,EAAgBF,GAQlB,OANIvwD,MAAKwwD,UACPriC,EAASzY,QAAS+6C,GAElBzwD,KAAK0wD,eACH//C,KAAM,iBAAMwd,GAASzY,QAAS+6C,KAE3BtiC,EAAS/b,WAsBhB5P,IAAK,iBACL1B,MAAO,SApBMwvD,GACd,GAAMlwD,GAAKJ,KAAKwwD,UAAUxuD,MACzBhC,MAAKwwD,UAAU1tD,MAAO1C,UAuBtBoC,IAAK,iBACL1B,MAAO,SArBMwvD,GACb,GAAIh3B,GAAQ62B,EAAEe,UAAUlxD,KAAKwwD,UAAW,SAAUvtD,GAChD,MAAOA,GAAE7C,IAAMkwD,EAASlwD,IAE1BJ,MAAKwwD,UAAUl3B,GAASg3B,KAwBxB9tD,IAAK,iBACL1B,MAAO,SAtBMwvD,GACbH,EAAEpiD,OAAO/N,KAAKwwD,UAAW,SAAUvtD,GACjC,MAAOA,GAAE7C,IAAMkwD,EAASlwD,QA0B1BoC,IAAK,0BACL1B,MAAO,SAvBcoZ,GACtBi2C,EAAE5uD,OAAOivD,UAAW,SAAUvtD,GAC5B,MAAOA,GAAEiX,UAAYA,QA4BjB82C,IAtBTA,GAAaljC,SAAW,QAAS,MA2BjCzvB,aAzBe2yD,GR62XT,SAAS5yD,EAAQC,GSn7XvB,YAMA,SAAS8wD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAJhH1uD,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAKT,IARMqwD,GACL,QAAAA,GAAalhC,EAAcmhC,EAAcC,GAAgB,GAAAnrD,GAAAlG,IAAAmvD,GAAAnvD,KAAAmxD,GAExDE,EAAcC,qBAERrhC,EAAa/V,UACfm3C,EAAcE,kBAAkBthC,EAAa/V,UAC3CvJ,KAAM,SAACuJ,GAAD,MAAcm3C,GAAcC,mBAAmBp3C,KAGzDk3C,EAAaV,eACV//C,KAAM,SAACtM,GAAD,MAAY6B,GAAKsqD,UAAYnsD,IAEtCrE,KAAKwxD,mBAAqBH,EAAcG,mBACxCxxD,KAAKyxD,uBAAyBJ,EAAcI,uBAC5CzxD,KAAK0xD,mBAAqB,SAACtB,GAAD,MAAgBngC,GAAamgC,YAAcA,GACrEpwD,KAAK2xD,eAAiBP,EAAaO,eAIvCR,GAAcrjC,SAAY,eAAgB,mBAAoB,qBAe9DzvB,aAbe8yD,GTs8XT,SAAS/yD,EAAQC,EAASC,GU59XhC,YA0BA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAxBvFoC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAAnC,GAAAL,EAAA,GAQIM,EAAYL,EAAuBI,GAPvCE,EAAAP,EAAA,GAWIQ,EAAoBP,EAAuBM,GAT/CQ,EAAAf,EAAA,GAaIgB,EAAaf,EAAuBc,GAZxCuyD,EAAAtzD,EAAA,IAgBIuzD,EAAmBtzD,EAAuBqzD,GAf9CjyD,EAAArB,EAAA,IAmBIsB,EAAYrB,EAAuBoB,EAhBvCf,cAAQR,OAAO,wBAAwBU,aAAAQ,eACrCskC,WAAY,iBADdiuB,cAEGhyD,OAFHD,cAsBAvB,aAlBe,wBVo/XT,SAASD,EAAQC,GWhgYvB,YAMA,SAAS8wD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAJhH1uD,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAKT,IARMgxD,GAEL,QAAAA,GAAaV,EAAcnhC,EAAc/a,GAItC,QAAS68C,KACP78C,EAAOsd,GAAG,8BACRtY,SAAU+V,EAAa/V,WAI3B,QAAS83C,GAAa1B,GAChBA,GACFtwD,KAAKiyD,WAAY,EACjBjyD,KAAKswD,SAAWA,EAChBtwD,KAAKkyD,eAAiBtqD,QAAQM,KAAKlI,KAAKswD,WAGxCyB,IAIJ,QAASI,KACPnyD,KAAKswD,SAAW1oD,QAAQM,KAAKlI,KAAKkyD,gBAClC1B,UAAU2B,eAAenyD,KAAKkyD,gBAC9BH,IAGF,QAASK,KACPpyD,KAAKiyD,WAAY,EACjBF,IA7B6C,GAAA7rD,GAAAlG,IAAAmvD,GAAAnvD,KAAA8xD,GAEjD9xD,KAAKiyD,WAAY,EA8Bfb,EAAaiB,gBAAgBpiC,EAAamgC,YACxCz/C,KAAMqhD,GAERhyD,KAAKsyD,cAAgB,iBAAMpsD,GAAK+rD,WAAa/rD,EAAK+rD,WAClDjyD,KAAKoyD,cAAgBA,EACrBpyD,KAAKmyD,eAAiBA,EAM1BL,GAAShkC,SAAW,mBAAoB,eAAgB,UAQxDzvB,aANeyzD,GX4gYT,SAAS1zD,EAAQC,EAASC,GY3jYhC,YAUA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GANvF,QAAS+zD,GAASC,GAChBA,EAAel/C,MAAM,mCACnBqP,IAAK;AACL9N,OAAS49C,+BAAiC7uB,aAAYn3B,SAAAimD,aAAUpmB,mBALpE1rC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAA6xD,GAAAr0D,EAAA,IAQIo0D,EAAYn0D,EAAuBo0D,GAPjC/uB,EAAa,iBACb0I,EAAe,OASrBimB,GAAQzkC,SAAW,kBAanBzvB,aAXek0D,GZ4kYT,SAASn0D,EAAQC,GazlYvBD,EAAAC,QAAA,+rBb+lYM,SAASD,EAAQC,EAASC,Gc/lYhC,YA0BA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAxBvFoC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAAnC,GAAAL,EAAA,GAQIM,EAAYL,EAAuBI,GAPvCE,EAAAP,EAAA,GAWIQ,EAAoBP,EAAuBM,GAT/CQ,EAAAf,EAAA,GAaIgB,EAAaf,EAAuBc,GAZxCuzD,EAAAt0D,EAAA,IAgBIu0D,EAAqBt0D,EAAuBq0D,GAfhDjzD,EAAArB,EAAA,IAmBIsB,EAAYrB,EAAuBoB,EAhBvCf,cAAQR,OAAO,wBAAwBU,aAAAQ,eACrCskC,WAAY,mBADdivB,cAEGhzD,OAFHD,cAsBAvB,aAlBe,wBdunYT,SAASD,EAAQC,GenoYvB,cforYM,SAASD,EAAQC,EAASC,GgBprYhC,YAUA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GANvF,QAAS+zD,GAASC,GAChBA,EAAel/C,MAAM,qCACnBqP,IAAK,oBACL9N,OAAS49C,+BAAiC7uB,aAAYn3B,SAAAqmD,aAAUxmB,mBALpE1rC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAAiyD,GAAAz0D,EAAA,IAQIw0D,EAAcv0D,EAAuBw0D,GAPnCnvB,EAAa,mBACb0I,EAAe,OASrBimB,GAAQzkC,SAAW,kBAanBzvB,aAXek0D,GhBqsYT,SAASn0D,EAAQC,GiBltYvBD,EAAAC,QAAA,k0BjBwtYM,SAASD,EAAQC,EAASC,GkBxtYhC,YAUA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GANvF,QAAS+zD,GAASC,GAChBA,EAAel/C,MAAM,8BACnBqP,IAAK,uBACL9N,OAASm+C,cAAgBpvB,aAAYn3B,SAAAwmD,aAAU3mB,mBALnD1rC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAAoyD,GAAA50D,EAAA,IAQI20D,EAAiB10D,EAAuB20D,GAPtCtvB,EAAc,sBACd0I,EAAe,OAUrBimB,GAAQzkC,SAAW,kBAYnBzvB,aAVek0D,GlBwuYT,SAASn0D,EAAQC,GmBtvYvBD,EAAAC,QAAA,k3BnB4vYM,SAASD,EAAQC,EAASC,GoB5vYhC,YAsBA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GApBvFoC,OAAOC,eAAexC,EAAS,cAC9ByC,OAAO,GAHR,IAAAnC,GAAAL,EAAA,GAQIM,EAAYL,EAAuBI,GANvCU,EAAAf,EAAA,GAUIgB,EAAaf,EAAuBc,GATxC8zD,EAAA70D,EAAA,IAaI80D,EAAyB70D,EAAuB40D,GAXpDxzD,EAAArB,EAAA,IAeIsB,EAAYrB,EAAuBoB,EAbvCf,cAAQR,OAAO,oBAAoBkB,eACjCskC,WAAW,uBADbwvB,cAEEvzD,OAFFD,cAmBAvB,aAfe,oBpBixYT,SAASD,EAAQC,GqB5xYvB,YAMA,SAAS8wD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAJhH1uD,OAAOC,eAAexC,EAAS,cAC9ByC,OAAO,GAKR,IARMuyD,GAEL,QAAAA,GAAchC,GAAgB,GAAAnrD,GAAAlG,IAAAmvD,GAAAnvD,KAAAqzD,GAE7BrzD,KAAKyxD,uBAAyBJ,EAAcI,uBAE5CJ,EAAcN,gBACZpgD,KAAM,SAACtM,GAAD,MAAY6B,GAAK6T,WAAa1V,IAEtCrE,KAAKszD,kBAAoB,SAACp5C,GAAD,MAAcA,GAAS1Y,OAAS0E,EAAKurD,0BAOhE4B,GAAevlC,SAAY,qBAU3BzvB,aAReg1D,GrB0yYT,SAASj1D,EAAQC,EAASC,GsB5zYhC,YAcA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAPvF,QAAS+zD,GAASC,GAChBA,EACGl/C,MAAM,oBACLqP,IAAK,IACL9N,OACE0+C,eACE3vB,WAAY4vB,EACZ/mD,SAAAgnD,aACAnnB,aAAc,SAEhB0mB,cACEpvB,WAAY8vB,EACZjnD,SAAAwmD,aACA3mB,aAAc,YAlBxB1rC,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAA6yD,GAAAr1D,EAAA,IAQIm1D,EAAkBl1D,EAAuBo1D,GAL7CT,EAAA50D,EAAA,IASI20D,EAAiB10D,EAAuB20D,GAXtCM,EAAiB,uBAGjBE,EAAiB,qBAsBvBnB,GAAQzkC,SAAW,kBAcnBzvB,aAZek0D,GtB80YT,SAASn0D,EAAQC,GuB12YvBD,EAAAC,QAAA,8YvBg3YM,SAASD,EAAQC,GwBh3YvB,YAGA,SAASk0D,GAAUC,EAAgBjjC,GACjCijC,EAAel/C,MAAM,SAAWqP,MAAKiO,eACtCrB,EAAmBiN,UAAU,KAH9B57B,OAAOC,eAAexC,EAAS,cAC7ByC,OAAO,GAHT,IAAM6hB,GAAM,GACNiO,GAAW,CAOjB2hC,GAAQzkC,SAAW,iBAAkB,sBAOrCzvB,aALek0D","file":"js/app.9724907e62399a3bd84f.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularUiRouter = __webpack_require__(5);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _angularAnimate = __webpack_require__(6);\n\t\n\tvar _angularAnimate2 = _interopRequireDefault(_angularAnimate);\n\t\n\tvar _bookmarks = __webpack_require__(8);\n\t\n\tvar _bookmarks2 = _interopRequireDefault(_bookmarks);\n\t\n\tvar _categories = __webpack_require__(23);\n\t\n\tvar _categories2 = _interopRequireDefault(_categories);\n\t\n\tvar _services = __webpack_require__(9);\n\t\n\tvar _services2 = _interopRequireDefault(_services);\n\t\n\tvar _edit = __webpack_require__(13);\n\t\n\tvar _edit2 = _interopRequireDefault(_edit);\n\t\n\tvar _create = __webpack_require__(17);\n\t\n\tvar _create2 = _interopRequireDefault(_create);\n\t\n\tvar _routing = __webpack_require__(27);\n\t\n\tvar _routing2 = _interopRequireDefault(_routing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('Eggly', [_angularAnimate2.default, _angularUiRouter2.default, _services2.default, _categories2.default, _bookmarks2.default, _edit2.default, _create2.default]).config(_routing2.default);\n\t\n\t// JS App\n\t// Styles\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */\n1,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * State-based routing for AngularJS\n\t * @version v1.0.0-alpha.5\n\t * @link http://angular-ui.github.com/ui-router\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"angular-ui-router\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"angular-ui-router\"] = factory();\n\t\telse\n\t\t\troot[\"angular-ui-router\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/**\n\t\t * Main entry point for angular 1.x build\n\t\t * @module ng1\n\t\t */\n\t\t/** for typedoc */\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t__export(__webpack_require__(1));\n\t\t__export(__webpack_require__(53));\n\t\t__export(__webpack_require__(54));\n\t\t__export(__webpack_require__(56));\n\t\t__webpack_require__(57);\n\t\t__webpack_require__(58);\n\t\t__webpack_require__(59);\n\t\t__webpack_require__(60);\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.default = \"ui.router\";\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module common */ /** */\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t__export(__webpack_require__(2));\n\t\t__export(__webpack_require__(20));\n\t\t__export(__webpack_require__(44));\n\t\t__export(__webpack_require__(40));\n\t\t__export(__webpack_require__(17));\n\t\t__export(__webpack_require__(13));\n\t\t__export(__webpack_require__(45));\n\t\t__export(__webpack_require__(49));\n\t\t__export(__webpack_require__(51));\n\t\tvar router_1 = __webpack_require__(52);\n\t\texports.UIRouter = router_1.UIRouter;\n\t\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module common */ /** for typedoc */\n\t\t__export(__webpack_require__(3));\n\t\t__export(__webpack_require__(6));\n\t\t__export(__webpack_require__(7));\n\t\t__export(__webpack_require__(5));\n\t\t__export(__webpack_require__(4));\n\t\t__export(__webpack_require__(8));\n\t\t__export(__webpack_require__(9));\n\t\t__export(__webpack_require__(12));\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/**\n\t\t * Random utility functions used in the UI-Router code\n\t\t *\n\t\t * @preferred @module common\n\t\t */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar w = typeof window === 'undefined' ? {} : window;\n\t\tvar angular = w.angular || {};\n\t\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\t\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\t\texports.copy = angular.copy || _copy;\n\t\texports.forEach = angular.forEach || _forEach;\n\t\texports.extend = angular.extend || _extend;\n\t\texports.equals = angular.equals || _equals;\n\t\texports.identity = function (x) { return x; };\n\t\texports.noop = function () { return undefined; };\n\t\texports.abstractKey = 'abstract';\n\t\t/**\n\t\t * Binds and copies functions onto an object\n\t\t *\n\t\t * Takes functions from the 'from' object, binds those functions to the _this object, and puts the bound functions\n\t\t * on the 'to' object.\n\t\t *\n\t\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * class Foo {\n\t\t *   constructor(data) {\n\t\t *     // Binds all functions from Foo.prototype to 'this',\n\t\t *     // then copies them to 'this'\n\t\t *     bindFunctions(Foo.prototype, this, this);\n\t\t *     this.data = data;\n\t\t *   }\n\t\t *\n\t\t *   log() {\n\t\t *     console.log(this.data);\n\t\t *   }\n\t\t * }\n\t\t *\n\t\t * let myFoo = new Foo([1,2,3]);\n\t\t * var logit = myFoo.log;\n\t\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t\t * ```\n\t\t *\n\t\t * This example creates a bound version of a service function, and copies it to another object\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * var SomeService = {\n\t\t *   this.data = [3, 4, 5];\n\t\t *   this.log = function() {\n\t\t *     console.log(this.data);\n\t\t *   }\n\t\t * }\n\t\t *\n\t\t * // Constructor fn\n\t\t * function OtherThing() {\n\t\t *   // Binds all functions from SomeService to SomeService,\n\t\t *   // then copies them to 'this'\n\t\t *   bindFunctions(SomeService, this, SomeService);\n\t\t * }\n\t\t *\n\t\t * let myOtherThing = new OtherThing();\n\t\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t\t * ```\n\t\t *\n\t\t * @param from The object which contains the functions to be bound\n\t\t * @param to The object which will receive the bound functions\n\t\t * @param bindTo The object which the functions will be bound to\n\t\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t\t */\n\t\tfunction bindFunctions(from, to, bindTo, fnNames) {\n\t\t    if (fnNames === void 0) { fnNames = Object.keys(from); }\n\t\t    return fnNames.filter(function (name) { return typeof from[name] === 'function'; })\n\t\t        .forEach(function (name) { return to[name] = from[name].bind(bindTo); });\n\t\t}\n\t\texports.bindFunctions = bindFunctions;\n\t\t/**\n\t\t * prototypal inheritance helper.\n\t\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t\t */\n\t\texports.inherit = function (parent, extra) {\n\t\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t\t};\n\t\t/**\n\t\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t\t * This is similar to es6 rest parameters.\n\t\t *\n\t\t * Optionally, the argument at index idx may itself already be an array.\n\t\t *\n\t\t * For example,\n\t\t * given either:\n\t\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t\t * or:\n\t\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t\t * then:\n\t\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t\t *\n\t\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t\t *\n\t\t * given:\n\t\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t\t * then:\n\t\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t\t */\n\t\tvar restArgs = function (args, idx) {\n\t\t    if (idx === void 0) { idx = 0; }\n\t\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t\t};\n\t\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\t\tvar inArray = function (array, obj) { return array.indexOf(obj) !== -1; };\n\t\t/** Given an array, and an item, if the item is found in the array, it removes it (in-place).  The same array is returned */\n\t\texports.removeFrom = hof_1.curry(function (array, obj) {\n\t\t    var idx = array.indexOf(obj);\n\t\t    if (idx >= 0)\n\t\t        array.splice(idx, 1);\n\t\t    return array;\n\t\t});\n\t\t/**\n\t\t * Applies a set of defaults to an options object.  The options object is filtered\n\t\t * to only those properties of the objects in the defaultsList.\n\t\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t\t */\n\t\tfunction defaults(opts) {\n\t\t    if (opts === void 0) { opts = {}; }\n\t\t    var defaultsList = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        defaultsList[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t\t}\n\t\texports.defaults = defaults;\n\t\t/**\n\t\t * Merges properties from the list of objects to the destination object.\n\t\t * If a property already exists in the destination object, then it is not overwritten.\n\t\t */\n\t\tfunction merge(dst) {\n\t\t    var objs = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        objs[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    exports.forEach(objs, function (obj) {\n\t\t        exports.forEach(obj, function (value, key) {\n\t\t            if (!dst.hasOwnProperty(key))\n\t\t                dst[key] = value;\n\t\t        });\n\t\t    });\n\t\t    return dst;\n\t\t}\n\t\texports.merge = merge;\n\t\t/** Reduce function that merges each element of the list into a single object, using extend */\n\t\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t\t/**\n\t\t * Finds the common ancestor path between two states.\n\t\t *\n\t\t * @param {Object} first The first state.\n\t\t * @param {Object} second The second state.\n\t\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t\t */\n\t\tfunction ancestors(first, second) {\n\t\t    var path = [];\n\t\t    for (var n in first.path) {\n\t\t        if (first.path[n] !== second.path[n])\n\t\t            break;\n\t\t        path.push(first.path[n]);\n\t\t    }\n\t\t    return path;\n\t\t}\n\t\texports.ancestors = ancestors;\n\t\t/**\n\t\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t\t *\n\t\t * @param {Object} a The first object.\n\t\t * @param {Object} b The second object.\n\t\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t\t *                     it defaults to the list of keys in `a`.\n\t\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t\t */\n\t\tfunction equalForKeys(a, b, keys) {\n\t\t    if (keys === void 0) { keys = Object.keys(a); }\n\t\t    for (var i = 0; i < keys.length; i++) {\n\t\t        var k = keys[i];\n\t\t        if (a[k] != b[k])\n\t\t            return false; // Not '===', values aren't necessarily normalized\n\t\t    }\n\t\t    return true;\n\t\t}\n\t\texports.equalForKeys = equalForKeys;\n\t\tfunction pickOmitImpl(predicate, obj) {\n\t\t    var objCopy = {}, keys = restArgs(arguments, 2);\n\t\t    for (var key in obj) {\n\t\t        if (predicate(keys, key))\n\t\t            objCopy[key] = obj[key];\n\t\t    }\n\t\t    return objCopy;\n\t\t}\n\t\t/** Return a copy of the object only containing the whitelisted properties. */\n\t\tfunction pick(obj) { return pickOmitImpl.apply(null, [inArray].concat(restArgs(arguments))); }\n\t\texports.pick = pick;\n\t\t/** Return a copy of the object omitting the blacklisted properties. */\n\t\tfunction omit(obj) { return pickOmitImpl.apply(null, [hof_1.not(inArray)].concat(restArgs(arguments))); }\n\t\texports.omit = omit;\n\t\t/**\n\t\t * Maps an array, or object to a property (by name)\n\t\t */\n\t\tfunction pluck(collection, propName) {\n\t\t    return map(collection, hof_1.prop(propName));\n\t\t}\n\t\texports.pluck = pluck;\n\t\t/** Filters an Array or an Object's properties based on a predicate */\n\t\tfunction filter(collection, callback) {\n\t\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t\t    exports.forEach(collection, function (item, i) {\n\t\t        if (callback(item, i))\n\t\t            accept(item, i);\n\t\t    });\n\t\t    return result;\n\t\t}\n\t\texports.filter = filter;\n\t\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\t\tfunction find(collection, callback) {\n\t\t    var result;\n\t\t    exports.forEach(collection, function (item, i) {\n\t\t        if (result)\n\t\t            return;\n\t\t        if (callback(item, i))\n\t\t            result = item;\n\t\t    });\n\t\t    return result;\n\t\t}\n\t\texports.find = find;\n\t\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\t\texports.mapObj = map;\n\t\t/** Maps an array or object properties using a callback function */\n\t\tfunction map(collection, callback) {\n\t\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t\t    return result;\n\t\t}\n\t\texports.map = map;\n\t\t/**\n\t\t * Given an object, return its enumerable property values\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let foo = { a: 1, b: 2, c: 3 }\n\t\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t\t * ```\n\t\t */\n\t\texports.values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };\n\t\t/**\n\t\t * Reduce function that returns true if all of the values are truthy.\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let vals = [ 1, true, {}, \"hello world\"];\n\t\t * vals.reduce(allTrueR, true); // true\n\t\t *\n\t\t * vals.push(0);\n\t\t * vals.reduce(allTrueR, true); // false\n\t\t * ```\n\t\t */\n\t\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t\t/**\n\t\t * Reduce function that returns true if any of the values are truthy.\n\t\t *\n\t\t *  * @example\n\t\t * ```\n\t\t *\n\t\t * let vals = [ 0, null, undefined ];\n\t\t * vals.reduce(anyTrueR, true); // false\n\t\t *\n\t\t * vals.push(\"hello world\");\n\t\t * vals.reduce(anyTrueR, true); // true\n\t\t * ```\n\t\t */\n\t\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t\t/**\n\t\t * Reduce function which un-nests a single level of arrays\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t\t * ```\n\t\t */\n\t\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t\t/**\n\t\t * Reduce function which recursively un-nests all arrays\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t\t * ```\n\t\t */\n\t\texports.flattenR = function (memo, elem) { return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem); };\n\t\t/** Reduce function that pushes an object to an array, then returns the array.  Mostly just for [[flattenR]] */\n\t\tfunction pushR(arr, obj) { arr.push(obj); return arr; }\n\t\t/**\n\t\t * Return a new array with a single level of arrays unnested.\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t\t * ```\n\t\t */\n\t\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t\t/**\n\t\t * Return a completely flattened version of an array.\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t\t * ```\n\t\t */\n\t\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t\t/**\n\t\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t\t *\n\t\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t\t * ```\n\t\t */\n\t\tfunction assertPredicate(predicate, errMsg) {\n\t\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t\t    return function (obj) {\n\t\t        if (!predicate(obj)) {\n\t\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t\t        }\n\t\t        return true;\n\t\t    };\n\t\t}\n\t\texports.assertPredicate = assertPredicate;\n\t\t/**\n\t\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t\t * ```\n\t\t */\n\t\texports.pairs = function (object) { return Object.keys(object).map(function (key) { return [key, object[key]]; }); };\n\t\t/**\n\t\t * Given two or more parallel arrays, returns an array of tuples where\n\t\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * let foo = [ 0, 2, 4, 6 ];\n\t\t * let bar = [ 1, 3, 5, 7 ];\n\t\t * let baz = [ 10, 30, 50, 70 ];\n\t\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t\t * ```\n\t\t */\n\t\tfunction arrayTuples() {\n\t\t    var arrayArgs = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        arrayArgs[_i - 0] = arguments[_i];\n\t\t    }\n\t\t    if (arrayArgs.length === 0)\n\t\t        return [];\n\t\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t\t}\n\t\texports.arrayTuples = arrayTuples;\n\t\t/**\n\t\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t\t *\n\t\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t\t *\n\t\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t\t *\n\t\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t\t *\n\t\t * // Or, more simply:\n\t\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t\t * ```\n\t\t */\n\t\tfunction applyPairs(memo, keyValTuple) {\n\t\t    var key, value;\n\t\t    if (predicates_1.isArray(keyValTuple))\n\t\t        key = keyValTuple[0], value = keyValTuple[1];\n\t\t    if (!predicates_1.isString(key))\n\t\t        throw new Error(\"invalid parameters to applyPairs\");\n\t\t    memo[key] = value;\n\t\t    return memo;\n\t\t}\n\t\texports.applyPairs = applyPairs;\n\t\t/** Get the last element of an array */\n\t\tfunction tail(arr) {\n\t\t    return arr.length && arr[arr.length - 1] || undefined;\n\t\t}\n\t\texports.tail = tail;\n\t\t/**\n\t\t * shallow copy from src to dest\n\t\t *\n\t\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t\t * ui-router uses `copy` only to make copies of state parameters.\n\t\t */\n\t\tfunction _copy(src, dest) {\n\t\t    if (dest)\n\t\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t\t    if (!dest)\n\t\t        dest = {};\n\t\t    return exports.extend(dest, src);\n\t\t}\n\t\tfunction _forEach(obj, cb, _this) {\n\t\t    if (predicates_1.isArray(obj))\n\t\t        return obj.forEach(cb, _this);\n\t\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t\t}\n\t\tfunction _copyProps(to, from) { Object.keys(from).forEach(function (key) { return to[key] = from[key]; }); return to; }\n\t\tfunction _extend(toObj, rest) {\n\t\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t\t}\n\t\tfunction _equals(o1, o2) {\n\t\t    if (o1 === o2)\n\t\t        return true;\n\t\t    if (o1 === null || o2 === null)\n\t\t        return false;\n\t\t    if (o1 !== o1 && o2 !== o2)\n\t\t        return true; // NaN === NaN\n\t\t    var t1 = typeof o1, t2 = typeof o2;\n\t\t    if (t1 !== t2 || t1 !== 'object')\n\t\t        return false;\n\t\t    var tup = [o1, o2];\n\t\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t\t        return _arraysEq(o1, o2);\n\t\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t\t        return o1.getTime() === o2.getTime();\n\t\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t\t        return o1.toString() === o2.toString();\n\t\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t\t        return true; // meh\n\t\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t\t        return false;\n\t\t    var key, keys = {};\n\t\t    for (key in o1) {\n\t\t        if (!_equals(o1[key], o2[key]))\n\t\t            return false;\n\t\t        keys[key] = true;\n\t\t    }\n\t\t    for (key in o2) {\n\t\t        if (!keys[key])\n\t\t            return false;\n\t\t    }\n\t\t    return true;\n\t\t}\n\t\tfunction _arraysEq(a1, a2) {\n\t\t    if (a1.length !== a2.length)\n\t\t        return false;\n\t\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t\t}\n\t\t//\n\t\t//const _addToGroup = (result, keyFn) => (item) =>\n\t\t//  (result[keyFn(item)] = result[keyFn(item)] || []).push(item) && result;\n\t\t//const groupBy = (array, keyFn) => array.reduce((memo, item) => _addToGroup(memo, keyFn), {});\n\t\t//\n\t\t//\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** Predicates @module common_predicates */ /** */\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar toStr = Object.prototype.toString;\n\t\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\t\texports.isUndefined = tis('undefined');\n\t\texports.isDefined = hof_1.not(exports.isUndefined);\n\t\texports.isNull = function (o) { return o === null; };\n\t\texports.isFunction = tis('function');\n\t\texports.isNumber = tis('number');\n\t\texports.isString = tis('string');\n\t\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\t\texports.isArray = Array.isArray;\n\t\texports.isDate = function (x) { return toStr.call(x) === '[object Date]'; };\n\t\texports.isRegExp = function (x) { return toStr.call(x) === '[object RegExp]'; };\n\t\t/**\n\t\t * Predicate which checks if a value is injectable\n\t\t *\n\t\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t\t */\n\t\tfunction isInjectable(val) {\n\t\t    if (exports.isArray(val) && val.length) {\n\t\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t\t    }\n\t\t    return exports.isFunction(val);\n\t\t}\n\t\texports.isInjectable = isInjectable;\n\t\t/**\n\t\t * Predicate which checks if a value looks like a Promise\n\t\t *\n\t\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t\t */\n\t\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t/**\n\t\t * Higher order functions\n\t\t *\n\t\t * @module common_hof\n\t\t */\n\t\t\"use strict\";\n\t\t/**\n\t\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t\t *\n\t\t * Given a function with N parameters, returns a new function that supports partial application.\n\t\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t\t * accept more parameters until all N parameters have been supplied.\n\t\t *\n\t\t *\n\t\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t\t * if an object is found in both arrays.\n\t\t * @example\n\t\t * ```\n\t\t * // returns true if an object is in both of the two arrays\n\t\t * function inBoth(array1, array2, object) {\n\t\t *   return array1.indexOf(object) !== -1 &&\n\t\t *          array2.indexOf(object) !== 1;\n\t\t * }\n\t\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t\t * let foos = [obj1, obj3]\n\t\t * let bars = [obj3, obj4, obj5]\n\t\t *\n\t\t * // A curried \"copy\" of inBoth\n\t\t * let curriedInBoth = curry(inBoth);\n\t\t * // Partially apply both the array1 and array2\n\t\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t\t *\n\t\t * // Supply the final argument; since all arguments are\n\t\t * // supplied, the original inBoth function is then called.\n\t\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t\t *\n\t\t * // Use the inFoosAndBars as a predicate.\n\t\t * // Filter, on each iteration, supplies the final argument\n\t\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t\t *\n\t\t * ```\n\t\t *\n\t\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t\t *\n\t\t * @param fn\n\t\t * @returns {*|function(): (*|any)}\n\t\t */\n\t\tfunction curry(fn) {\n\t\t    var initial_args = [].slice.apply(arguments, [1]);\n\t\t    var func_args_length = fn.length;\n\t\t    function curried(args) {\n\t\t        if (args.length >= func_args_length)\n\t\t            return fn.apply(null, args);\n\t\t        return function () {\n\t\t            return curried(args.concat([].slice.apply(arguments)));\n\t\t        };\n\t\t    }\n\t\t    return curried(initial_args);\n\t\t}\n\t\texports.curry = curry;\n\t\t/**\n\t\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t\t * given: f(x), g(x), h(x)\n\t\t * let composed = compose(f,g,h)\n\t\t * then, composed is: f(g(h(x)))\n\t\t */\n\t\tfunction compose() {\n\t\t    var args = arguments;\n\t\t    var start = args.length - 1;\n\t\t    return function () {\n\t\t        var i = start, result = args[start].apply(this, arguments);\n\t\t        while (i--)\n\t\t            result = args[i].call(this, result);\n\t\t        return result;\n\t\t    };\n\t\t}\n\t\texports.compose = compose;\n\t\t/**\n\t\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t\t * given: f(x), g(x), h(x)\n\t\t * let piped = pipe(f,g,h);\n\t\t * then, piped is: h(g(f(x)))\n\t\t */\n\t\tfunction pipe() {\n\t\t    var funcs = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        funcs[_i - 0] = arguments[_i];\n\t\t    }\n\t\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t\t}\n\t\texports.pipe = pipe;\n\t\t/**\n\t\t * Given a property name, returns a function that returns that property from an object\n\t\t * let obj = { foo: 1, name: \"blarg\" };\n\t\t * let getName = prop(\"name\");\n\t\t * getName(obj) === \"blarg\"\n\t\t */\n\t\texports.prop = function (name) { return function (obj) { return obj && obj[name]; }; };\n\t\t/**\n\t\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t\t * the passed object has a property that matches the value\n\t\t * let obj = { foo: 1, name: \"blarg\" };\n\t\t * let getName = propEq(\"name\", \"blarg\");\n\t\t * getName(obj) === true\n\t\t */\n\t\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t\t/**\n\t\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t\t * let getName = prop(\"nestedObj.name\");\n\t\t * getName(obj) === \"blarg\"\n\t\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t\t * propNotFound(obj) === undefined\n\t\t */\n\t\texports.parse = function (name) { return pipe.apply(null, name.split(\".\").map(exports.prop)); };\n\t\t/**\n\t\t * Given a function that returns a truthy or falsey value, returns a\n\t\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t\t */\n\t\texports.not = function (fn) { return function () {\n\t\t    var args = [];\n\t\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t\t        args[_i - 0] = arguments[_i];\n\t\t    }\n\t\t    return !fn.apply(null, args);\n\t\t}; };\n\t\t/**\n\t\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t\t * if both functions return truthy for the given arguments\n\t\t */\n\t\tfunction and(fn1, fn2) {\n\t\t    return function () {\n\t\t        var args = [];\n\t\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t\t            args[_i - 0] = arguments[_i];\n\t\t        }\n\t\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t\t    };\n\t\t}\n\t\texports.and = and;\n\t\t/**\n\t\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t\t * if at least one of the functions returns truthy for the given arguments\n\t\t */\n\t\tfunction or(fn1, fn2) {\n\t\t    return function () {\n\t\t        var args = [];\n\t\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t\t            args[_i - 0] = arguments[_i];\n\t\t        }\n\t\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t\t    };\n\t\t}\n\t\texports.or = or;\n\t\t/**\n\t\t * Check if all the elements of an array match a predicate function\n\t\t *\n\t\t * @param fn1 a predicate function `fn1`\n\t\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t\t */\n\t\texports.all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };\n\t\texports.any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };\n\t\texports.none = exports.not(exports.any);\n\t\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\t\texports.is = function (ctor) { return function (obj) { return (obj != null && obj.constructor === ctor || obj instanceof ctor); }; };\n\t\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\t\texports.eq = function (val) { return function (other) { return val === other; }; };\n\t\t/** Given a value, returns a function which returns the value */\n\t\texports.val = function (v) { return function () { return v; }; };\n\t\tfunction invoke(fnName, args) {\n\t\t    return function (obj) { return obj[fnName].apply(obj, args); };\n\t\t}\n\t\texports.invoke = invoke;\n\t\t/**\n\t\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t\t *\n\t\t * See http://c2.com/cgi/wiki?PatternMatching\n\t\t *\n\t\t * This is a conditional construct which allows a series of predicates and output functions\n\t\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t\t * returns truthy, then its matching output function (mapping function) is provided with\n\t\t * the input and, then the result is returned.\n\t\t *\n\t\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t\t * of size 2: [ predicate, mapFn ]\n\t\t *\n\t\t * These 2-tuples should be put in an outer array.\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * // Here's a 2-tuple where the first element is the isString predicate\n\t\t * // and the second element is a function that returns a description of the input\n\t\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t\t *\n\t\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t\t *\n\t\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t\t *\n\t\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t\t *\n\t\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t\t *\n\t\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t\t * ```\n\t\t *\n\t\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t\t * with a Predicate and a mapping/output function\n\t\t * @returns {function(any): *}\n\t\t */\n\t\tfunction pattern(struct) {\n\t\t    return function (x) {\n\t\t        for (var i = 0; i < struct.length; i++) {\n\t\t            if (struct[i][0](x))\n\t\t                return struct[i][1](x);\n\t\t        }\n\t\t    };\n\t\t}\n\t\texports.pattern = pattern;\n\t\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports) {\n\t\n\t\t/**\n\t\t * This module is a stub for core services such as Dependency Injection or Browser Location.\n\t\t * Core services may be implemented by a specific framework, such as ng1 or ng2, or be pure javascript.\n\t\t *\n\t\t * @module common\n\t\t */\n\t\t\"use strict\";\n\t\t/** for typedoc */\n\t\t//import {IQService} from \"angular\";\n\t\t//import {IInjectorService} from \"angular\";\n\t\tvar notImplemented = function (fnname) { return function () {\n\t\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded. You should include one of: ['angular1.js']\");\n\t\t}; };\n\t\tvar services = {\n\t\t    $q: undefined,\n\t\t    $injector: undefined,\n\t\t    location: {},\n\t\t    locationConfig: {},\n\t\t    template: {}\n\t\t};\n\t\texports.services = services;\n\t\t[\"replace\", \"url\", \"path\", \"search\", \"hash\", \"onChange\"]\n\t\t    .forEach(function (key) { return services.location[key] = notImplemented(key); });\n\t\t[\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"]\n\t\t    .forEach(function (key) { return services.locationConfig[key] = notImplemented(key); });\n\t\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar Glob = (function () {\n\t\t    function Glob(text) {\n\t\t        this.text = text;\n\t\t        this.glob = text.split('.');\n\t\t    }\n\t\t    Glob.prototype.matches = function (name) {\n\t\t        var segments = name.split('.');\n\t\t        // match single stars\n\t\t        for (var i = 0, l = this.glob.length; i < l; i++) {\n\t\t            if (this.glob[i] === '*')\n\t\t                segments[i] = '*';\n\t\t        }\n\t\t        // match greedy starts\n\t\t        if (this.glob[0] === '**') {\n\t\t            segments = segments.slice(segments.indexOf(this.glob[1]));\n\t\t            segments.unshift('**');\n\t\t        }\n\t\t        // match greedy ends\n\t\t        if (this.glob[this.glob.length - 1] === '**') {\n\t\t            segments.splice(segments.indexOf(this.glob[this.glob.length - 2]) + 1, Number.MAX_VALUE);\n\t\t            segments.push('**');\n\t\t        }\n\t\t        if (this.glob.length != segments.length)\n\t\t            return false;\n\t\t        return segments.join('') === this.glob.join('');\n\t\t    };\n\t\t    Glob.is = function (text) {\n\t\t        return text.indexOf('*') > -1;\n\t\t    };\n\t\t    Glob.fromString = function (text) {\n\t\t        if (!this.is(text))\n\t\t            return null;\n\t\t        return new Glob(text);\n\t\t    };\n\t\t    return Glob;\n\t\t}());\n\t\texports.Glob = Glob;\n\t\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\t/** @module common */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar Queue = (function () {\n\t\t    function Queue(_items, _limit) {\n\t\t        if (_items === void 0) { _items = []; }\n\t\t        if (_limit === void 0) { _limit = null; }\n\t\t        this._items = _items;\n\t\t        this._limit = _limit;\n\t\t    }\n\t\t    Queue.prototype.enqueue = function (item) {\n\t\t        var items = this._items;\n\t\t        items.push(item);\n\t\t        if (this._limit && items.length > this._limit)\n\t\t            items.shift();\n\t\t        return item;\n\t\t    };\n\t\t    Queue.prototype.dequeue = function () {\n\t\t        if (this.size())\n\t\t            return this._items.splice(0, 1)[0];\n\t\t    };\n\t\t    Queue.prototype.clear = function () {\n\t\t        var current = this._items;\n\t\t        this._items = [];\n\t\t        return current;\n\t\t    };\n\t\t    Queue.prototype.size = function () {\n\t\t        return this._items.length;\n\t\t    };\n\t\t    Queue.prototype.remove = function (item) {\n\t\t        var idx = this._items.indexOf(item);\n\t\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t\t    };\n\t\t    Queue.prototype.peekTail = function () {\n\t\t        return this._items[this._items.length - 1];\n\t\t    };\n\t\t    Queue.prototype.peekHead = function () {\n\t\t        if (this.size())\n\t\t            return this._items[0];\n\t\t    };\n\t\t    return Queue;\n\t\t}());\n\t\texports.Queue = Queue;\n\t\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module common_strings */ /** */\n\t\t\"use strict\";\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar transition_1 = __webpack_require__(11);\n\t\tvar resolvable_1 = __webpack_require__(32);\n\t\t/**\n\t\t * Returns a string shortened to a maximum length\n\t\t *\n\t\t * If the string is already less than the `max` length, return the string.\n\t\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t\t *\n\t\t * @param max the maximum length of the string to return\n\t\t * @param str the input string\n\t\t */\n\t\tfunction maxLength(max, str) {\n\t\t    if (str.length <= max)\n\t\t        return str;\n\t\t    return str.substr(0, max - 3) + \"...\";\n\t\t}\n\t\texports.maxLength = maxLength;\n\t\t/**\n\t\t * Returns a string, with spaces added to the end, up to a desired str length\n\t\t *\n\t\t * If the string is already longer than the desired length, return the string.\n\t\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t\t *\n\t\t * @param length the desired length of the string to return\n\t\t * @param str the input string\n\t\t */\n\t\tfunction padString(length, str) {\n\t\t    while (str.length < length)\n\t\t        str += \" \";\n\t\t    return str;\n\t\t}\n\t\texports.padString = padString;\n\t\tfunction kebobString(camelCase) {\n\t\t    return camelCase\n\t\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t\t}\n\t\texports.kebobString = kebobString;\n\t\tfunction _toJson(obj) {\n\t\t    return JSON.stringify(obj);\n\t\t}\n\t\tfunction _fromJson(json) {\n\t\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t\t}\n\t\tfunction promiseToString(p) {\n\t\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t\t}\n\t\tfunction functionToString(fn) {\n\t\t    var fnStr = fnToString(fn);\n\t\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t\t    return namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t\t}\n\t\texports.functionToString = functionToString;\n\t\tfunction fnToString(fn) {\n\t\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t\t    return _fn && _fn.toString() || \"undefined\";\n\t\t}\n\t\texports.fnToString = fnToString;\n\t\tvar isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\t\tvar stringifyPattern = hof_1.pattern([\n\t\t    [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t\t    [predicates_1.isNull, hof_1.val(\"null\")],\n\t\t    [predicates_1.isPromise, promiseToString],\n\t\t    [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t\t    [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t\t    [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t\t    [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t\t    [predicates_1.isInjectable, functionToString],\n\t\t    [hof_1.val(true), common_1.identity]\n\t\t]);\n\t\tfunction stringify(o) {\n\t\t    var seen = [];\n\t\t    function format(val) {\n\t\t        if (predicates_1.isObject(val)) {\n\t\t            if (seen.indexOf(val) !== -1)\n\t\t                return '[circular ref]';\n\t\t            seen.push(val);\n\t\t        }\n\t\t        return stringifyPattern(val);\n\t\t    }\n\t\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t\t}\n\t\texports.stringify = stringify;\n\t\t/** Returns a function that splits a string on a character or substring */\n\t\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t\t    if (!str)\n\t\t        return [\"\", \"\"];\n\t\t    var idx = str.indexOf(char);\n\t\t    if (idx === -1)\n\t\t        return [str, \"\"];\n\t\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t\t}; };\n\t\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module transition */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar strings_1 = __webpack_require__(9);\n\t\t(function (RejectType) {\n\t\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t\t})(exports.RejectType || (exports.RejectType = {}));\n\t\tvar RejectType = exports.RejectType;\n\t\tvar Rejection = (function () {\n\t\t    function Rejection(type, message, detail) {\n\t\t        this.type = type;\n\t\t        this.message = message;\n\t\t        this.detail = detail;\n\t\t    }\n\t\t    Rejection.prototype.toString = function () {\n\t\t        var detailString = function (d) { return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d); };\n\t\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t\t    };\n\t\t    Rejection.prototype.toPromise = function () {\n\t\t        return common_1.extend(coreservices_1.services.$q.reject(this), { _transitionRejection: this });\n\t\t    };\n\t\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t\t    };\n\t\t    /** Returns a TransitionRejection due to transition superseded */\n\t\t    Rejection.superseded = function (detail, options) {\n\t\t        var message = \"The transition has been superseded by a different transition (see detail).\";\n\t\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t\t        if (options && options.redirected) {\n\t\t            rejection.redirected = true;\n\t\t        }\n\t\t        return rejection;\n\t\t    };\n\t\t    /** Returns a TransitionRejection due to redirected transition */\n\t\t    Rejection.redirected = function (detail) {\n\t\t        return Rejection.superseded(detail, { redirected: true });\n\t\t    };\n\t\t    /** Returns a TransitionRejection due to invalid transition */\n\t\t    Rejection.invalid = function (detail) {\n\t\t        var message = \"This transition is invalid (see detail)\";\n\t\t        return new Rejection(RejectType.INVALID, message, detail);\n\t\t    };\n\t\t    /** Returns a TransitionRejection due to ignored transition */\n\t\t    Rejection.ignored = function (detail) {\n\t\t        var message = \"The transition was ignored.\";\n\t\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t\t    };\n\t\t    /** Returns a TransitionRejection due to aborted transition */\n\t\t    Rejection.aborted = function (detail) {\n\t\t        // TODO think about how to encapsulate an Error() object\n\t\t        var message = \"The transition has been aborted.\";\n\t\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t\t    };\n\t\t    return Rejection;\n\t\t}());\n\t\texports.Rejection = Rejection;\n\t\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module transition */ /** for typedoc */\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar module_1 = __webpack_require__(13);\n\t\tvar node_1 = __webpack_require__(39);\n\t\tvar pathFactory_1 = __webpack_require__(38);\n\t\tvar module_2 = __webpack_require__(17);\n\t\tvar module_3 = __webpack_require__(20);\n\t\tvar module_4 = __webpack_require__(40);\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar transitionCount = 0;\n\t\tvar stateSelf = hof_1.prop(\"self\");\n\t\t/**\n\t\t * The representation of a transition between two states.\n\t\t *\n\t\t * Contains all contextual information about the to/from states, parameters, resolves, as well as the\n\t\t * list of states being entered and exited as a result of this transition.\n\t\t */\n\t\tvar Transition = (function () {\n\t\t    /**\n\t\t     * Creates a new Transition object.\n\t\t     *\n\t\t     * If the target state is not valid, an error is thrown.\n\t\t     *\n\t\t     * @param fromPath The path of [[Node]]s from which the transition is leaving.  The last node in the `fromPath`\n\t\t     *        encapsulates the \"from state\".\n\t\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t\t     * @param _transitionService The Transition Service instance\n\t\t     */\n\t\t    function Transition(fromPath, targetState, _transitionService) {\n\t\t        var _this = this;\n\t\t        this._transitionService = _transitionService;\n\t\t        this._deferred = coreservices_1.services.$q.defer();\n\t\t        /**\n\t\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t\t         *\n\t\t         * When the transition is successful, the promise is resolved\n\t\t         * When the transition is unsuccessful, the promise is rejected with the [[TransitionRejection]] or javascript error\n\t\t         */\n\t\t        this.promise = this._deferred.promise;\n\t\t        this.treeChanges = function () { return _this._treeChanges; };\n\t\t        this.isActive = function () { return _this === _this._options.current(); };\n\t\t        if (!targetState.valid()) {\n\t\t            throw new Error(targetState.error());\n\t\t        }\n\t\t        // Makes the Transition instance a hook registry (onStart, etc)\n\t\t        module_1.HookRegistry.mixin(new module_1.HookRegistry(), this);\n\t\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t\t        this.$id = transitionCount++;\n\t\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t\t        toPath = pathFactory_1.PathFactory.applyViewConfigs(_transitionService.$view, toPath);\n\t\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t\t        pathFactory_1.PathFactory.bindTransitionResolve(this._treeChanges, this);\n\t\t    }\n\t\t    Transition.prototype.$from = function () {\n\t\t        return common_1.tail(this._treeChanges.from).state;\n\t\t    };\n\t\t    Transition.prototype.$to = function () {\n\t\t        return common_1.tail(this._treeChanges.to).state;\n\t\t    };\n\t\t    /**\n\t\t     * Returns the \"from state\"\n\t\t     *\n\t\t     * @returns The state object for the Transition's \"from state\".\n\t\t     */\n\t\t    Transition.prototype.from = function () {\n\t\t        return this.$from().self;\n\t\t    };\n\t\t    /**\n\t\t     * Returns the \"to state\"\n\t\t     *\n\t\t     * @returns The state object for the Transition's target state (\"to state\").\n\t\t     */\n\t\t    Transition.prototype.to = function () {\n\t\t        return this.$to().self;\n\t\t    };\n\t\t    /**\n\t\t     * Determines whether two transitions are equivalent.\n\t\t     */\n\t\t    Transition.prototype.is = function (compare) {\n\t\t        if (compare instanceof Transition) {\n\t\t            // TODO: Also compare parameters\n\t\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t\t        }\n\t\t        return !((compare.to && !module_1.matchState(this.$to(), compare.to)) ||\n\t\t            (compare.from && !module_1.matchState(this.$from(), compare.from)));\n\t\t    };\n\t\t    /**\n\t\t     * Gets transition parameter values\n\t\t     *\n\t\t     * @param pathname Pick which treeChanges path to get parameters for:\n\t\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t\t     * @returns transition parameter values for the desired path.\n\t\t     */\n\t\t    Transition.prototype.params = function (pathname) {\n\t\t        if (pathname === void 0) { pathname = \"to\"; }\n\t\t        return this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {});\n\t\t    };\n\t\t    /**\n\t\t     * Get resolved data\n\t\t     *\n\t\t     * @returns an object (key/value pairs) where keys are resolve names and values are any settled resolve data,\n\t\t     *    or `undefined` for pending resolve data\n\t\t     */\n\t\t    Transition.prototype.resolves = function () {\n\t\t        return common_1.map(common_1.tail(this._treeChanges.to).resolveContext.getResolvables(), function (res) { return res.data; });\n\t\t    };\n\t\t    /**\n\t\t     * Adds new resolves to this transition.\n\t\t     *\n\t\t     * @param resolves an [[ResolveDeclarations]] object which describes the new resolves\n\t\t     * @param state the state in the \"to path\" which should receive the new resolves (otherwise, the root state)\n\t\t     */\n\t\t    Transition.prototype.addResolves = function (resolves, state) {\n\t\t        if (state === void 0) { state = \"\"; }\n\t\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t\t        var topath = this._treeChanges.to;\n\t\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t\t        common_1.tail(topath).resolveContext.addResolvables(module_4.Resolvable.makeResolvables(resolves), targetNode.state);\n\t\t    };\n\t\t    /**\n\t\t     * Gets the previous transition, from which this transition was redirected.\n\t\t     *\n\t\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t\t     */\n\t\t    Transition.prototype.previous = function () {\n\t\t        return this._options.previous || null;\n\t\t    };\n\t\t    /**\n\t\t     * Get the transition options\n\t\t     *\n\t\t     * @returns the options for this Transition.\n\t\t     */\n\t\t    Transition.prototype.options = function () {\n\t\t        return this._options;\n\t\t    };\n\t\t    /**\n\t\t     * Gets the states being entered.\n\t\t     *\n\t\t     * @returns an array of states that will be entered during this transition.\n\t\t     */\n\t\t    Transition.prototype.entering = function () {\n\t\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t\t    };\n\t\t    /**\n\t\t     * Gets the states being exited.\n\t\t     *\n\t\t     * @returns an array of states that will be exited during this transition.\n\t\t     */\n\t\t    Transition.prototype.exiting = function () {\n\t\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t\t    };\n\t\t    /**\n\t\t     * Gets the states being retained.\n\t\t     *\n\t\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t\t     *    exited during this Transition\n\t\t     */\n\t\t    Transition.prototype.retained = function () {\n\t\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t\t    };\n\t\t    /**\n\t\t     * Get the [[ViewConfig]]s associated with this Transition\n\t\t     *\n\t\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t\t     *\n\t\t     * @param pathname the name of the path to fetch views for:\n\t\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t\t     *\n\t\t     * @returns a list of ViewConfig objects for the given path.\n\t\t     */\n\t\t    Transition.prototype.views = function (pathname, state) {\n\t\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t\t        var path = this._treeChanges[pathname];\n\t\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.type:Transition#redirect\n\t\t     * @methodOf ui.router.state.type:Transition\n\t\t     *\n\t\t     * @description\n\t\t     * Creates a new transition that is a redirection of the current one. This transition can\n\t\t     * be returned from a `$transitionsProvider` hook, `$state` event, or other method, to\n\t\t     * redirect a transition to a new state and/or set of parameters.\n\t\t     *\n\t\t     * @returns {Transition} Returns a new `Transition` instance.\n\t\t     */\n\t\t    Transition.prototype.redirect = function (targetState) {\n\t\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), { previous: this });\n\t\t        targetState = new module_2.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t\t        var redirectTo = new Transition(this._treeChanges.from, targetState, this._transitionService);\n\t\t        var reloadState = targetState.options().reloadState;\n\t\t        // If the current transition has already resolved any resolvables which are also in the redirected \"to path\", then\n\t\t        // add those resolvables to the redirected transition.  Allows you to define a resolve at a parent level, wait for\n\t\t        // the resolve, then redirect to a child state based on the result, and not have to re-fetch the resolve.\n\t\t        var redirectedPath = this.treeChanges().to;\n\t\t        var copyResolvesFor = node_1.Node.matching(redirectTo.treeChanges().to, redirectedPath)\n\t\t            .filter(function (node) { return !reloadState || !reloadState.includes[node.state.name]; });\n\t\t        var includeResolve = function (resolve, key) { return ['$stateParams', '$transition$'].indexOf(key) === -1; };\n\t\t        copyResolvesFor.forEach(function (node, idx) { return common_1.extend(node.resolves, common_1.filter(redirectedPath[idx].resolves, includeResolve)); });\n\t\t        return redirectTo;\n\t\t    };\n\t\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t\t    Transition.prototype._changedParams = function () {\n\t\t        var _a = this._treeChanges, to = _a.to, from = _a.from;\n\t\t        if (this._options.reload || common_1.tail(to).state !== common_1.tail(from).state)\n\t\t            return undefined;\n\t\t        var nodeSchemas = to.map(function (node) { return node.paramSchema; });\n\t\t        var _b = [to, from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _b[0], fromValues = _b[1];\n\t\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t\t        return tuples.map(function (_a) {\n\t\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t\t            return module_3.Param.changed(schema, toVals, fromVals);\n\t\t        }).reduce(common_1.unnestR, []);\n\t\t    };\n\t\t    /**\n\t\t     * Returns true if the transition is dynamic.\n\t\t     *\n\t\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t\t     *\n\t\t     * @returns true if the Transition is dynamic\n\t\t     */\n\t\t    Transition.prototype.dynamic = function () {\n\t\t        var changes = this._changedParams();\n\t\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t\t    };\n\t\t    /**\n\t\t     * Returns true if the transition is ignored.\n\t\t     *\n\t\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t\t     *\n\t\t     * @returns true if the Transition is ignored.\n\t\t     */\n\t\t    Transition.prototype.ignored = function () {\n\t\t        var changes = this._changedParams();\n\t\t        return !changes ? false : changes.length === 0;\n\t\t    };\n\t\t    /**\n\t\t     * @hidden\n\t\t     */\n\t\t    Transition.prototype.hookBuilder = function () {\n\t\t        return new module_1.HookBuilder(this._transitionService, this, {\n\t\t            transition: this,\n\t\t            current: this._options.current\n\t\t        });\n\t\t    };\n\t\t    /**\n\t\t     * Runs the transition\n\t\t     *\n\t\t     * This method is generally called from the [[StateService.transitionTo]]\n\t\t     *\n\t\t     * @returns a promise for a successful transition.\n\t\t     */\n\t\t    Transition.prototype.run = function () {\n\t\t        var _this = this;\n\t\t        var hookBuilder = this.hookBuilder();\n\t\t        var runSynchronousHooks = module_1.TransitionHook.runSynchronousHooks;\n\t\t        // TODO: nuke these in favor of chaining off the promise, i.e.,\n\t\t        // $transitions.onBefore({}, $transition$ => {$transition$.promise.then()}\n\t\t        var runSuccessHooks = function () { return runSynchronousHooks(hookBuilder.getOnSuccessHooks(), {}, true); };\n\t\t        var runErrorHooks = function ($error$) { return runSynchronousHooks(hookBuilder.getOnErrorHooks(), { $error$: $error$ }, true); };\n\t\t        // Run the success/error hooks *after* the Transition promise is settled.\n\t\t        this.promise.then(runSuccessHooks, runErrorHooks);\n\t\t        var syncResult = runSynchronousHooks(hookBuilder.getOnBeforeHooks());\n\t\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t\t            var rejectReason = syncResult._transitionRejection;\n\t\t            this._deferred.reject(rejectReason);\n\t\t            return this.promise;\n\t\t        }\n\t\t        if (!this.valid()) {\n\t\t            var error = new Error(this.error());\n\t\t            this._deferred.reject(error);\n\t\t            return this.promise;\n\t\t        }\n\t\t        if (this.ignored()) {\n\t\t            trace_1.trace.traceTransitionIgnored(this);\n\t\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t\t            return this.promise;\n\t\t        }\n\t\t        // When the chain is complete, then resolve or reject the deferred\n\t\t        var resolve = function () {\n\t\t            _this.success = true;\n\t\t            _this._deferred.resolve(_this);\n\t\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t\t        };\n\t\t        var reject = function (error) {\n\t\t            _this.success = false;\n\t\t            _this._deferred.reject(error);\n\t\t            trace_1.trace.traceError(error, _this);\n\t\t            return coreservices_1.services.$q.reject(error);\n\t\t        };\n\t\t        trace_1.trace.traceTransitionStart(this);\n\t\t        var chain = hookBuilder.asyncHooks().reduce(function (_chain, step) { return _chain.then(step.invokeHook.bind(step)); }, syncResult);\n\t\t        chain.then(resolve, reject);\n\t\t        return this.promise;\n\t\t    };\n\t\t    /**\n\t\t     * Checks if the Transition is valid\n\t\t     *\n\t\t     * @returns true if the Transition is valid\n\t\t     */\n\t\t    Transition.prototype.valid = function () {\n\t\t        return !this.error();\n\t\t    };\n\t\t    /**\n\t\t     * The reason the Transition is invalid\n\t\t     *\n\t\t     * @returns an error message explaining why the transition is invalid\n\t\t     */\n\t\t    Transition.prototype.error = function () {\n\t\t        var state = this.$to();\n\t\t        if (state.self[common_1.abstractKey])\n\t\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t\t        if (!module_3.Param.validates(state.parameters(), this.params()))\n\t\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t\t    };\n\t\t    /**\n\t\t     * A string representation of the Transition\n\t\t     *\n\t\t     * @returns A string representation of the Transition\n\t\t     */\n\t\t    Transition.prototype.toString = function () {\n\t\t        var fromStateOrName = this.from();\n\t\t        var toStateOrName = this.to();\n\t\t        var avoidEmptyHash = function (params) {\n\t\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t\t        };\n\t\t        // (X) means the to state is invalid.\n\t\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t\t    };\n\t\t    return Transition;\n\t\t}());\n\t\texports.Transition = Transition;\n\t\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/**\n\t\t * UI-Router Transition Tracing\n\t\t *\n\t\t * Enable transition tracing to print transition information to the console, in order to help debug your application.\n\t\t * Tracing logs detailed information about each Transition to your console.\n\t\t *\n\t\t * To enable tracing, import the [[trace]] singleton and enable one or more categories.\n\t\t *\n\t\t * ES6\n\t\t * ```\n\t\t *\n\t\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t\t * ```\n\t\t *\n\t\t * CJS\n\t\t * ```\n\t\t *\n\t\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t\t * ```\n\t\t *\n\t\t * Globals\n\t\t * ```\n\t\t *\n\t\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t\t * trace.enable(); // Trace everything (very verbose)\n\t\t * ```\n\t\t *\n\t\t * @module trace\n\t\t */ /** for typedoc */\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar strings_1 = __webpack_require__(9);\n\t\t/** @hidden */\n\t\tfunction uiViewString(viewData) {\n\t\t    if (!viewData)\n\t\t        return 'ui-view (defunct)';\n\t\t    return \"[ui-view#\" + viewData.id + \" tag in template from '\" + (viewData.creationContext.name || '(root)') + \"' state]: fqn: '\" + viewData.fqn + \"', name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\";\n\t\t}\n\t\t/** @hidden */\n\t\tvar viewConfigString = function (viewConfig) {\n\t\t    return (\"[ViewConfig from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\");\n\t\t};\n\t\t/** @hidden */\n\t\tfunction normalizedCat(input) {\n\t\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t\t}\n\t\t/**\n\t\t * Trace categories\n\t\t *\n\t\t * [[Trace.enable]] or [[Trace.disable]] a category\n\t\t *\n\t\t * `trace.enable(Category.TRANSITION)`\n\t\t *\n\t\t * These can also be provided using a matching string, or position ordinal\n\t\t *\n\t\t * `trace.enable(\"TRANSITION\")`\n\t\t *\n\t\t * `trace.enable(1)`\n\t\t */\n\t\t(function (Category) {\n\t\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t\t    Category[Category[\"INVOKE\"] = 3] = \"INVOKE\";\n\t\t    Category[Category[\"UIVIEW\"] = 4] = \"UIVIEW\";\n\t\t    Category[Category[\"VIEWCONFIG\"] = 5] = \"VIEWCONFIG\";\n\t\t})(exports.Category || (exports.Category = {}));\n\t\tvar Category = exports.Category;\n\t\t/**\n\t\t * Prints UI-Router Transition trace information to the console.\n\t\t */\n\t\tvar Trace = (function () {\n\t\t    function Trace() {\n\t\t        /** @hidden */\n\t\t        this._enabled = {};\n\t\t        this.approximateDigests = 0;\n\t\t    }\n\t\t    /** @hidden */\n\t\t    Trace.prototype._set = function (enabled, categories) {\n\t\t        var _this = this;\n\t\t        if (!categories.length) {\n\t\t            categories = Object.keys(Category)\n\t\t                .filter(function (k) { return isNaN(parseInt(k, 10)); })\n\t\t                .map(function (key) { return Category[key]; });\n\t\t        }\n\t\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t\t    };\n\t\t    /**\n\t\t     * Enables a trace [[Category]]\n\t\t     *\n\t\t     * ```\n\t\t     * trace.enable(\"TRANSITION\");\n\t\t     * ```\n\t\t     *\n\t\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t\t     *        Also takes strings (category name) or ordinal (category position)\n\t\t     */\n\t\t    Trace.prototype.enable = function () {\n\t\t        var categories = [];\n\t\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t\t            categories[_i - 0] = arguments[_i];\n\t\t        }\n\t\t        this._set(true, categories);\n\t\t    };\n\t\t    /**\n\t\t     * Disables a trace [[Category]]\n\t\t     *\n\t\t     * ```\n\t\t     * trace.disable(\"VIEWCONFIG\");\n\t\t     * ```\n\t\t     *\n\t\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t\t     *        Also takes strings (category name) or ordinal (category position)\n\t\t     */\n\t\t    Trace.prototype.disable = function () {\n\t\t        var categories = [];\n\t\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t\t            categories[_i - 0] = arguments[_i];\n\t\t        }\n\t\t        this._set(false, categories);\n\t\t    };\n\t\t    /**\n\t\t     * Retrieves the enabled stateus of a [[Category]]\n\t\t     *\n\t\t     * ```\n\t\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t\t     * ```\n\t\t     *\n\t\t     * @returns boolean true if the category is enabled\n\t\t     */\n\t\t    Trace.prototype.enabled = function (category) {\n\t\t        return !!this._enabled[normalizedCat(category)];\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceTransitionStart = function (transition) {\n\t\t        if (!this.enabled(Category.TRANSITION))\n\t\t            return;\n\t\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": Started  -> \" + transitionStr);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceTransitionIgnored = function (transition) {\n\t\t        if (!this.enabled(Category.TRANSITION))\n\t\t            return;\n\t\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": Ignored  <> \" + transitionStr);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceHookInvocation = function (step, options) {\n\t\t        if (!this.enabled(Category.HOOK))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.fn);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceHookResult = function (hookResult, transitionResult, transitionOptions) {\n\t\t        if (!this.enabled(Category.HOOK))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult), transitionResultStr = strings_1.stringify(transitionResult);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr) + \", transition result: \" + strings_1.maxLength(200, transitionResultStr));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceResolvePath = function (path, options) {\n\t\t        if (!this.enabled(Category.RESOLVE))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, pathStr = path && path.toString(), policyStr = options && options.resolvePolicy;\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Resolving \" + pathStr + \" (\" + policyStr + \")\");\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceResolvePathElement = function (pathElement, resolvablePromises, options) {\n\t\t        if (!this.enabled(Category.RESOLVE))\n\t\t            return;\n\t\t        if (!resolvablePromises.length)\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvablePromisesStr = Object.keys(resolvablePromises).join(\", \"), pathElementStr = pathElement && pathElement.toString(), policyStr = options && options.resolvePolicy;\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Resolve \" + pathElementStr + \" resolvables: [\" + resolvablePromisesStr + \"] (\" + policyStr + \")\");\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceResolveResolvable = function (resolvable, options) {\n\t\t        if (!this.enabled(Category.RESOLVE))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString();\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":               Resolving -> \" + resolvableStr);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceResolvableResolved = function (resolvable, options) {\n\t\t        if (!this.enabled(Category.RESOLVE))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.tracePathElementInvoke = function (node, fn, deps, options) {\n\t\t        if (!this.enabled(Category.INVOKE))\n\t\t            return;\n\t\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, stateName = node && node.state && node.state.toString(), fnName = strings_1.functionToString(fn);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Invoke \" + options.when + \": context: \" + stateName + \" \" + strings_1.maxLength(200, fnName));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceError = function (error, transition) {\n\t\t        if (!this.enabled(Category.TRANSITION))\n\t\t            return;\n\t\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": <- Rejected \" + transitionStr + \", reason: \" + error);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceSuccess = function (finalState, transition) {\n\t\t        if (!this.enabled(Category.TRANSITION))\n\t\t            return;\n\t\t        var tid = transition.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(transition);\n\t\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceUiViewEvent = function (event, viewData, extra) {\n\t\t        if (extra === void 0) { extra = \"\"; }\n\t\t        if (!this.enabled(Category.UIVIEW))\n\t\t            return;\n\t\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceUiViewConfigUpdated = function (viewData, context) {\n\t\t        if (!this.enabled(Category.UIVIEW))\n\t\t            return;\n\t\t        this.traceUiViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceUiViewScopeCreated = function (viewData, newScope) {\n\t\t        if (!this.enabled(Category.UIVIEW))\n\t\t            return;\n\t\t        this.traceUiViewEvent(\"Created scope for\", viewData, \", scope #\" + newScope.$id);\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceUiViewFill = function (viewData, html) {\n\t\t        if (!this.enabled(Category.UIVIEW))\n\t\t            return;\n\t\t        this.traceUiViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t\t        if (!this.enabled(Category.VIEWCONFIG))\n\t\t            return;\n\t\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t\t    };\n\t\t    /** called by ui-router code */\n\t\t    Trace.prototype.traceViewServiceUiViewEvent = function (event, viewData) {\n\t\t        if (!this.enabled(Category.VIEWCONFIG))\n\t\t            return;\n\t\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t\t    };\n\t\t    return Trace;\n\t\t}());\n\t\texports.Trace = Trace;\n\t\t/**\n\t\t * The [[Trace]] singleton\n\t\t *\n\t\t * @example\n\t\t * ```js\n\t\t *\n\t\t * import {trace} from \"angular-ui-router\";\n\t\t * trace.enable(1, 5);\n\t\t * ```\n\t\t */\n\t\tvar trace = new Trace();\n\t\texports.trace = trace;\n\t\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/**\n\t\t * This module contains APIs related to a Transition.\n\t\t *\n\t\t * See [[Transition]], [[$transitions]]\n\t\t *\n\t\t * @module transition\n\t\t * @preferred\n\t\t */\n\t\t/** for typedoc */\n\t\t__export(__webpack_require__(14));\n\t\t__export(__webpack_require__(15));\n\t\t__export(__webpack_require__(10));\n\t\t__export(__webpack_require__(11));\n\t\t__export(__webpack_require__(16));\n\t\t__export(__webpack_require__(43));\n\t\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module transition */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(13);\n\t\t/**\n\t\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t\t *\n\t\t * Hooks (IEventHook) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t\t * myTransition.onEnter(...).  The HookBuilder finds matching IEventHooks (where the match criteria is\n\t\t * determined by the type of hook)\n\t\t *\n\t\t * The HookBuilder also converts IEventHooks objects to TransitionHook objects, which are used to run a Transition.\n\t\t *\n\t\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t\t *\n\t\t */\n\t\tvar HookBuilder = (function () {\n\t\t    function HookBuilder($transitions, transition, baseHookOptions) {\n\t\t        var _this = this;\n\t\t        this.$transitions = $transitions;\n\t\t        this.transition = transition;\n\t\t        this.baseHookOptions = baseHookOptions;\n\t\t        // TODO: These get* methods are returning different cardinalities of hooks\n\t\t        // onBefore/onStart/onFinish/onSuccess/onError returns an array of hooks\n\t\t        // onExit/onRetain/onEnter returns an array of arrays of hooks\n\t\t        this.getOnBeforeHooks = function () { return _this._buildNodeHooks(\"onBefore\", \"to\", tupleSort(), undefined, { async: false }); };\n\t\t        this.getOnStartHooks = function () { return _this._buildNodeHooks(\"onStart\", \"to\", tupleSort()); };\n\t\t        this.getOnExitHooks = function () { return _this._buildNodeHooks(\"onExit\", \"exiting\", tupleSort(true), function (node) { return ({ $state$: node.state }); }); };\n\t\t        this.getOnRetainHooks = function () { return _this._buildNodeHooks(\"onRetain\", \"retained\", tupleSort(), function (node) { return ({ $state$: node.state }); }); };\n\t\t        this.getOnEnterHooks = function () { return _this._buildNodeHooks(\"onEnter\", \"entering\", tupleSort(), function (node) { return ({ $state$: node.state }); }); };\n\t\t        this.getOnFinishHooks = function () { return _this._buildNodeHooks(\"onFinish\", \"to\", tupleSort(), function (node) { return ({ $treeChanges$: _this.treeChanges }); }); };\n\t\t        this.getOnSuccessHooks = function () { return _this._buildNodeHooks(\"onSuccess\", \"to\", tupleSort(), undefined, { async: false, rejectIfSuperseded: false }); };\n\t\t        this.getOnErrorHooks = function () { return _this._buildNodeHooks(\"onError\", \"to\", tupleSort(), undefined, { async: false, rejectIfSuperseded: false }); };\n\t\t        this.treeChanges = transition.treeChanges();\n\t\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t\t        this.transitionOptions = transition.options();\n\t\t    }\n\t\t    HookBuilder.prototype.asyncHooks = function () {\n\t\t        var onStartHooks = this.getOnStartHooks();\n\t\t        var onExitHooks = this.getOnExitHooks();\n\t\t        var onRetainHooks = this.getOnRetainHooks();\n\t\t        var onEnterHooks = this.getOnEnterHooks();\n\t\t        var onFinishHooks = this.getOnFinishHooks();\n\t\t        var asyncHooks = [onStartHooks, onExitHooks, onRetainHooks, onEnterHooks, onFinishHooks];\n\t\t        return asyncHooks.reduce(common_1.unnestR, []).filter(common_1.identity);\n\t\t    };\n\t\t    /**\n\t\t     * Returns an array of newly built TransitionHook objects.\n\t\t     *\n\t\t     * - Finds all IEventHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t\t     * - Finds [[Node]] (or `Node[]`) to use as the TransitionHook context(s)\n\t\t     * - For each of the [[Node]]s, creates a TransitionHook\n\t\t     *\n\t\t     * @param hookType the name of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t\t     * @param matchingNodesProp selects which [[Node]]s from the [[IMatchingNodes]] object to create hooks for.\n\t\t     * @param getLocals a function which accepts a [[Node]] and returns additional locals to provide to the hook as injectables\n\t\t     * @param sortHooksFn a function which compares two HookTuple and returns <1, 0, or >1\n\t\t     * @param options any specific Transition Hook Options\n\t\t     */\n\t\t    HookBuilder.prototype._buildNodeHooks = function (hookType, matchingNodesProp, sortHooksFn, getLocals, options) {\n\t\t        var _this = this;\n\t\t        if (getLocals === void 0) { getLocals = function (node) { return ({}); }; }\n\t\t        // Find all the matching registered hooks for a given hook type\n\t\t        var matchingHooks = this._matchingHooks(hookType, this.treeChanges);\n\t\t        if (!matchingHooks)\n\t\t            return [];\n\t\t        var makeTransitionHooks = function (hook) {\n\t\t            // Fetch the Nodes that caused this hook to match.\n\t\t            var matches = hook.matches(_this.treeChanges);\n\t\t            // Select the Node[] that will be used as TransitionHook context objects\n\t\t            var nodes = matches[matchingNodesProp];\n\t\t            // Return an array of HookTuples\n\t\t            return nodes.map(function (node) {\n\t\t                var _options = common_1.extend({ bind: hook.bind, traceData: { hookType: hookType, context: node } }, _this.baseHookOptions, options);\n\t\t                var transitionHook = new module_1.TransitionHook(hook.callback, getLocals(node), node.resolveContext, _options);\n\t\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t\t            });\n\t\t        };\n\t\t        return matchingHooks.map(makeTransitionHooks)\n\t\t            .reduce(common_1.unnestR, [])\n\t\t            .sort(sortHooksFn)\n\t\t            .map(function (tuple) { return tuple.transitionHook; });\n\t\t    };\n\t\t    /**\n\t\t     * Finds all IEventHooks from:\n\t\t     * - The Transition object instance hook registry\n\t\t     * - The TransitionService ($transitions) global hook registry\n\t\t     *\n\t\t     * which matched:\n\t\t     * - the eventType\n\t\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t\t     *\n\t\t     * @returns an array of matched [[IEventHook]]s\n\t\t     */\n\t\t    HookBuilder.prototype._matchingHooks = function (hookName, treeChanges) {\n\t\t        return [this.transition, this.$transitions] // Instance and Global hook registries\n\t\t            .map(function (reg) { return reg.getHooks(hookName); }) // Get named hooks from registries\n\t\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookName)) // Sanity check\n\t\t            .reduce(common_1.unnestR, []) // Un-nest IEventHook[][] to IEventHook[] array\n\t\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t\t    };\n\t\t    return HookBuilder;\n\t\t}());\n\t\texports.HookBuilder = HookBuilder;\n\t\t/**\n\t\t * A factory for a sort function for HookTuples.\n\t\t *\n\t\t * The sort function first compares the Node depth (how deep in the state tree a node is), then compares\n\t\t * the EventHook priority.\n\t\t *\n\t\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t\t * @returns a tuple sort function\n\t\t */\n\t\tfunction tupleSort(reverseDepthSort) {\n\t\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t\t    return function nodeDepthThenPriority(l, r) {\n\t\t        var factor = reverseDepthSort ? -1 : 1;\n\t\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t\t    };\n\t\t}\n\t\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module transition */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar glob_1 = __webpack_require__(7);\n\t\t/**\n\t\t * Determines if the given state matches the matchCriteria\n\t\t * @param state a State Object to test against\n\t\t * @param criterion\n\t\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t\t *   and returns a positive match if any of the globs match.\n\t\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction matchState(state, criterion) {\n\t\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t\t    function matchGlobs(_state) {\n\t\t        var globStrings = toMatch;\n\t\t        for (var i = 0; i < globStrings.length; i++) {\n\t\t            var glob = glob_1.Glob.fromString(globStrings[i]);\n\t\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t\t                return true;\n\t\t            }\n\t\t        }\n\t\t        return false;\n\t\t    }\n\t\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t\t    return !!matchFn(state);\n\t\t}\n\t\texports.matchState = matchState;\n\t\tvar EventHook = (function () {\n\t\t    function EventHook(matchCriteria, callback, options) {\n\t\t        if (options === void 0) { options = {}; }\n\t\t        this.callback = callback;\n\t\t        this.matchCriteria = common_1.extend({ to: true, from: true, exiting: true, retained: true, entering: true }, matchCriteria);\n\t\t        this.priority = options.priority || 0;\n\t\t        this.bind = options.bind || null;\n\t\t    }\n\t\t    EventHook._matchingNodes = function (nodes, criterion) {\n\t\t        if (criterion === true)\n\t\t            return nodes;\n\t\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t\t        return matching.length ? matching : null;\n\t\t    };\n\t\t    /**\n\t\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t\t     *\n\t\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t\t     * are the matching [[Node]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t\t     */\n\t\t    EventHook.prototype.matches = function (treeChanges) {\n\t\t        var mc = this.matchCriteria, _matchingNodes = EventHook._matchingNodes;\n\t\t        var matches = {\n\t\t            to: _matchingNodes([common_1.tail(treeChanges.to)], mc.to),\n\t\t            from: _matchingNodes([common_1.tail(treeChanges.from)], mc.from),\n\t\t            exiting: _matchingNodes(treeChanges.exiting, mc.exiting),\n\t\t            retained: _matchingNodes(treeChanges.retained, mc.retained),\n\t\t            entering: _matchingNodes(treeChanges.entering, mc.entering),\n\t\t        };\n\t\t        // Check if all the criteria matched the TreeChanges object\n\t\t        var allMatched = [\"to\", \"from\", \"exiting\", \"retained\", \"entering\"]\n\t\t            .map(function (prop) { return matches[prop]; })\n\t\t            .reduce(common_1.allTrueR, true);\n\t\t        return allMatched ? matches : null;\n\t\t    };\n\t\t    return EventHook;\n\t\t}());\n\t\texports.EventHook = EventHook;\n\t\t// Return a registration function of the requested type.\n\t\tfunction makeHookRegistrationFn(hooks, name) {\n\t\t    return function (matchObject, callback, options) {\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var eventHook = new EventHook(matchObject, callback, options);\n\t\t        hooks[name].push(eventHook);\n\t\t        return function deregisterEventHook() {\n\t\t            common_1.removeFrom(hooks[name])(eventHook);\n\t\t        };\n\t\t    };\n\t\t}\n\t\tvar HookRegistry = (function () {\n\t\t    function HookRegistry() {\n\t\t        var _this = this;\n\t\t        this._transitionEvents = {\n\t\t            onBefore: [], onStart: [], onEnter: [], onRetain: [], onExit: [], onFinish: [], onSuccess: [], onError: []\n\t\t        };\n\t\t        this.getHooks = function (name) { return _this._transitionEvents[name]; };\n\t\t        this.onBefore = makeHookRegistrationFn(this._transitionEvents, \"onBefore\");\n\t\t        this.onStart = makeHookRegistrationFn(this._transitionEvents, \"onStart\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onEnter\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from' states,\n\t\t         * when the matched 'to' state is being entered. This function is injected with the entering state's resolves.\n\t\t         *\n\t\t         * This function can be injected with two additional special value:\n\t\t         * - **`$transition$`**: The current transition\n\t\t         * - **`$state$`**: The state being entered\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         */\n\t\t        this.onEnter = makeHookRegistrationFn(this._transitionEvents, \"onEnter\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onRetain\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,\n\t\t         * when the matched 'from' state is already active and is not being exited nor entered.\n\t\t         *\n\t\t         * This function can be injected with two additional special value:\n\t\t         * - **`$transition$`**: The current transition\n\t\t         * - **`$state$`**: The state that is retained\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         */\n\t\t        this.onRetain = makeHookRegistrationFn(this._transitionEvents, \"onRetain\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onExit\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,\n\t\t         * when the matched 'from' state is being exited. This function is in injected with the exiting state's resolves.\n\t\t         *\n\t\t         * This function can be injected with two additional special value:\n\t\t         * - **`$transition$`**: The current transition\n\t\t         * - **`$state$`**: The state being entered\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         */\n\t\t        this.onExit = makeHookRegistrationFn(this._transitionEvents, \"onExit\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onFinish\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked when a transition is finished entering/exiting all states.\n\t\t         *\n\t\t         * This function can be injected with:\n\t\t         * - **`$transition$`**: The current transition\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         */\n\t\t        this.onFinish = makeHookRegistrationFn(this._transitionEvents, \"onFinish\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onSuccess\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked when a transition has successfully completed between the matched\n\t\t         * 'to' and 'from' state is being exited.\n\t\t         * This function is in injected with the 'to' state's resolves (note: `JIT` resolves are not injected).\n\t\t         *\n\t\t         * This function can be injected with two additional special value:\n\t\t         * - **`$transition$`**: The current transition\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.\n\t\t         *   The function's return value is ignored.\n\t\t         */\n\t\t        this.onSuccess = makeHookRegistrationFn(this._transitionEvents, \"onSuccess\");\n\t\t        /**\n\t\t         * @ngdoc function\n\t\t         * @name ui.router.state.$transitionsProvider#onError\n\t\t         * @methodOf ui.router.state.$transitionsProvider\n\t\t         *\n\t\t         * @description\n\t\t         * Registers a function to be injected and invoked when a transition has failed for any reason between the matched\n\t\t         * 'to' and 'from' state. The transition rejection reason is injected as `$error$`.\n\t\t         *\n\t\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t\t         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.\n\t\t         *   The function's return value is ignored.\n\t\t         */\n\t\t        this.onError = makeHookRegistrationFn(this._transitionEvents, \"onError\");\n\t\t    }\n\t\t    HookRegistry.mixin = function (source, target) {\n\t\t        Object.keys(source._transitionEvents).concat([\"getHooks\"]).forEach(function (key) { return target[key] = source[key]; });\n\t\t    };\n\t\t    return HookRegistry;\n\t\t}());\n\t\texports.HookRegistry = HookRegistry;\n\t\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar strings_1 = __webpack_require__(9);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar module_1 = __webpack_require__(17);\n\t\tvar defaultOptions = {\n\t\t    async: true,\n\t\t    rejectIfSuperseded: true,\n\t\t    current: common_1.noop,\n\t\t    transition: null,\n\t\t    traceData: {},\n\t\t    bind: null\n\t\t};\n\t\tvar TransitionHook = (function () {\n\t\t    function TransitionHook(fn, locals, resolveContext, options) {\n\t\t        var _this = this;\n\t\t        this.fn = fn;\n\t\t        this.locals = locals;\n\t\t        this.resolveContext = resolveContext;\n\t\t        this.options = options;\n\t\t        this.isSuperseded = function () { return _this.options.current() !== _this.options.transition; };\n\t\t        this.options = common_1.defaults(options, defaultOptions);\n\t\t    }\n\t\t    TransitionHook.prototype.invokeHook = function (moreLocals) {\n\t\t        var _this = this;\n\t\t        var _a = this, options = _a.options, fn = _a.fn, resolveContext = _a.resolveContext;\n\t\t        var locals = common_1.extend({}, this.locals, moreLocals);\n\t\t        trace_1.trace.traceHookInvocation(this, options);\n\t\t        if (options.rejectIfSuperseded && this.isSuperseded()) {\n\t\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t\t        }\n\t\t        // TODO: Need better integration of returned promises in synchronous code.\n\t\t        if (!options.async) {\n\t\t            var hookResult = resolveContext.invokeNow(fn, locals, options);\n\t\t            return this.handleHookResult(hookResult);\n\t\t        }\n\t\t        return resolveContext.invokeLater(fn, locals, options).then(function (val) { return _this.handleHookResult(val); });\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * This method handles the return value of a Transition Hook.\n\t\t     *\n\t\t     * A hook can return false, a redirect (TargetState), or a promise (which may resolve to false or a redirect)\n\t\t     */\n\t\t    TransitionHook.prototype.handleHookResult = function (hookResult) {\n\t\t        var _this = this;\n\t\t        if (!predicates_1.isDefined(hookResult))\n\t\t            return undefined;\n\t\t        /**\n\t\t         * Handles transition superseded, transition aborted and transition redirect.\n\t\t         */\n\t\t        var mapHookResult = hof_1.pattern([\n\t\t            // Transition is no longer current\n\t\t            [this.isSuperseded, function () { return rejectFactory_1.Rejection.superseded(_this.options.current()).toPromise(); }],\n\t\t            // If the hook returns false, abort the current Transition\n\t\t            [hof_1.eq(false), function () { return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise(); }],\n\t\t            // If the hook returns a Transition, halt the current Transition and redirect to that Transition.\n\t\t            [hof_1.is(module_1.TargetState), function (target) { return rejectFactory_1.Rejection.redirected(target).toPromise(); }],\n\t\t            // A promise was returned, wait for the promise and then chain another hookHandler\n\t\t            [predicates_1.isPromise, function (promise) { return promise.then(_this.handleHookResult.bind(_this)); }]\n\t\t        ]);\n\t\t        var transitionResult = mapHookResult(hookResult);\n\t\t        if (transitionResult)\n\t\t            trace_1.trace.traceHookResult(hookResult, transitionResult, this.options);\n\t\t        return transitionResult;\n\t\t    };\n\t\t    TransitionHook.prototype.toString = function () {\n\t\t        var _a = this, options = _a.options, fn = _a.fn;\n\t\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(fn);\n\t\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t\t    };\n\t\t    /**\n\t\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t\t     *\n\t\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t\t     */\n\t\t    TransitionHook.runSynchronousHooks = function (hooks, locals, swallowExceptions) {\n\t\t        if (locals === void 0) { locals = {}; }\n\t\t        if (swallowExceptions === void 0) { swallowExceptions = false; }\n\t\t        var results = [];\n\t\t        for (var i = 0; i < hooks.length; i++) {\n\t\t            try {\n\t\t                results.push(hooks[i].invokeHook(locals));\n\t\t            }\n\t\t            catch (exception) {\n\t\t                if (!swallowExceptions) {\n\t\t                    return rejectFactory_1.Rejection.aborted(exception).toPromise();\n\t\t                }\n\t\t                console.error(\"Swallowed exception during synchronous hook handler: \" + exception); // TODO: What to do here?\n\t\t            }\n\t\t        }\n\t\t        var rejections = results.filter(rejectFactory_1.Rejection.isTransitionRejectionPromise);\n\t\t        if (rejections.length)\n\t\t            return rejections[0];\n\t\t        return results\n\t\t            .filter(predicates_1.isPromise)\n\t\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t\t    };\n\t\t    return TransitionHook;\n\t\t}());\n\t\texports.TransitionHook = TransitionHook;\n\t\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module state */ /** for typedoc */\n\t\t__export(__webpack_require__(18));\n\t\t__export(__webpack_require__(19));\n\t\t__export(__webpack_require__(26));\n\t\t__export(__webpack_require__(33));\n\t\t__export(__webpack_require__(34));\n\t\t__export(__webpack_require__(35));\n\t\t__export(__webpack_require__(36));\n\t\t__export(__webpack_require__(37));\n\t\t__export(__webpack_require__(27));\n\t\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar common_1 = __webpack_require__(3);\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.state.$stateProvider\n\t\t *\n\t\t * @requires ui.router.router.$urlRouterProvider\n\t\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t\t *\n\t\t * @description\n\t\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t\t * on state.\n\t\t *\n\t\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t\t * navigation. A state describes (via the controller / template / view properties) what\n\t\t * the UI looks like and does at that place.\n\t\t *\n\t\t * States often have things in common, and the primary way of factoring out these\n\t\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t\t * nested states.\n\t\t *\n\t\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t\t */\n\t\tvar StateProvider = (function () {\n\t\t    function StateProvider(stateRegistry) {\n\t\t        this.stateRegistry = stateRegistry;\n\t\t        this.invalidCallbacks = [];\n\t\t        common_1.bindFunctions(StateProvider.prototype, this, this);\n\t\t    }\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$stateProvider#decorator\n\t\t     * @methodOf ui.router.state.$stateProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Allows you to extend (carefully) or override (at your own peril) the\n\t\t     * `stateBuilder` object used internally by `$stateProvider`. This can be used\n\t\t     * to add custom functionality to ui-router, for example inferring templateUrl\n\t\t     * based on the state name.\n\t\t     *\n\t\t     * When passing only a name, it returns the current (original or decorated) builder\n\t\t     * function that matches `name`.\n\t\t     *\n\t\t     * The builder functions that can be decorated are listed below. Though not all\n\t\t     * necessarily have a good use case for decoration, that is up to you to decide.\n\t\t     *\n\t\t     * In addition, users can attach custom decorators, which will generate new\n\t\t     * properties within the state's internal definition. There is currently no clear\n\t\t     * use-case for this beyond accessing internal states (i.e. $state.$current),\n\t\t     * however, expect this to become increasingly relevant as we introduce additional\n\t\t     * meta-programming features.\n\t\t     *\n\t\t     * **Warning**: Decorators should not be interdependent because the order of\n\t\t     * execution of the builder functions in non-deterministic. Builder functions\n\t\t     * should only be dependent on the state definition object and super function.\n\t\t     *\n\t\t     *\n\t\t     * Existing builder functions and current return values:\n\t\t     *\n\t\t     * - **parent** `{object}` - returns the parent state object.\n\t\t     * - **data** `{object}` - returns state data, including any inherited data that is not\n\t\t     *   overridden by own values (if any).\n\t\t     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t\t     *   or `null`.\n\t\t     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n\t\t     *   navigable).\n\t\t     * - **params** `{object}` - returns an array of state params that are ensured to\n\t\t     *   be a super-set of parent's params.\n\t\t     * - **views** `{object}` - returns a views object where each key is an absolute view\n\t\t     *   name (i.e. \"viewName@stateName\") and each value is the config object\n\t\t     *   (template, controller) for the view. Even when you don't use the views object\n\t\t     *   explicitly on a state config, one is still created for you internally.\n\t\t     *   So by decorating this builder function you have access to decorating template\n\t\t     *   and controller properties.\n\t\t     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n\t\t     *   not including any params defined by ancestor states.\n\t\t     * - **path** `{string}` - returns the full path from the root down to this state.\n\t\t     *   Needed for state activation.\n\t\t     * - **includes** `{object}` - returns an object that includes every state that\n\t\t     *   would pass a `$state.includes()` test.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * // Override the internal 'views' builder with a function that takes the state\n\t\t     * // definition, and a reference to the internal function being overridden:\n\t\t     * $stateProvider.decorator('views', function (state, parent) {\n\t\t     *   let result = {},\n\t\t     *       views = parent(state);\n\t\t     *\n\t\t     *   angular.forEach(views, function (config, name) {\n\t\t     *     let autoName = (state.name + '.' + name).replace('.', '/');\n\t\t     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t\t     *     result[name] = config;\n\t\t     *   });\n\t\t     *   return result;\n\t\t     * });\n\t\t     *\n\t\t     * $stateProvider.state('home', {\n\t\t     *   views: {\n\t\t     *     'contact.list': { controller: 'ListController' },\n\t\t     *     'contact.item': { controller: 'ItemController' }\n\t\t     *   }\n\t\t     * });\n\t\t     *\n\t\t     * // ...\n\t\t     *\n\t\t     * $state.go('home');\n\t\t     * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t\t     * // and /partials/home/contact/item.html, respectively.\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string} name The name of the builder function to decorate.\n\t\t     * @param {object} func A function that is responsible for decorating the original\n\t\t     * builder function. The function receives two parameters:\n\t\t     *\n\t\t     *   - `{object}` - state - The state config object.\n\t\t     *   - `{object}` - super - The original builder function.\n\t\t     *\n\t\t     * @return {object} $stateProvider - $stateProvider instance\n\t\t     */\n\t\t    StateProvider.prototype.decorator = function (name, func) {\n\t\t        return this.stateRegistry.decorator(name, func) || this;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$stateProvider#state\n\t\t     * @methodOf ui.router.state.$stateProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Registers a state configuration under a given state name. The stateConfig object\n\t\t     * has the following acceptable properties.\n\t\t     *\n\t\t     * <a id='template'></a>\n\t\t     *\n\t\t     * - **`template`** - {string|function=} - html template as a string or a function that returns\n\t\t     *   an html template as a string which should be used by the uiView directives. This property\n\t\t     *   takes precedence over templateUrl.\n\t\t     *\n\t\t     *   If `template` is a function, it will be called with the following parameters:\n\t\t     *\n\t\t     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t\t     *     applying the current state\n\t\t     *\n\t\t     * <a id='templateUrl'></a>\n\t\t     *\n\t\t     * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html\n\t\t     *   template that should be used by uiView.\n\t\t     *\n\t\t     *   If `templateUrl` is a function, it will be called with the following parameters:\n\t\t     *\n\t\t     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t\t     *     applying the current state\n\t\t     *\n\t\t     * <a id='templateProvider'></a>\n\t\t     *\n\t\t     * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n\t\t     *   string.\n\t\t     *\n\t\t     * <a id='controller'></a>\n\t\t     *\n\t\t     * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly\n\t\t     *   related scope or the name of a registered controller if passed as a string.\n\t\t     *\n\t\t     * <a id='controllerProvider'></a>\n\t\t     *\n\t\t     * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n\t\t     *   the actual controller or string.\n\t\t     *\n\t\t     * <a id='controllerAs'></a>\n\t\t     *\n\t\t     * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be\n\t\t     *   published to scope under the controllerAs name.\n\t\t     *\n\t\t     * <a id='resolve'></a>\n\t\t     *\n\t\t     * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which\n\t\t     *   should be injected into the controller. If any of these dependencies are promises,\n\t\t     *   the router will wait for them all to be resolved or one to be rejected before the\n\t\t     *   controller is instantiated. If all the promises are resolved successfully, the values\n\t\t     *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any\n\t\t     *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n\t\t     *\n\t\t     *   - key - {string}: name of dependency to be injected into controller\n\t\t     *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,\n\t\t     *     it is injected and return value it treated as dependency. If result is a promise, it is\n\t\t     *     resolved before its value is injected into controller.\n\t\t     *\n\t\t     * <a id='url'></a>\n\t\t     *\n\t\t     * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n\t\t     *   transitioned to, the `$stateParams` service will be populated with any\n\t\t     *   parameters that were passed.\n\t\t     *\n\t\t     * <a id='params'></a>\n\t\t     *\n\t\t     * - **`params`** - {object=} - An array of parameter names or regular expressions. Only\n\t\t     *   use this within a state if you are not using url. Otherwise you can specify your\n\t\t     *   parameters within the url. When a state is navigated or transitioned to, the\n\t\t     *   $stateParams service will be populated with any parameters that were passed.\n\t\t     *\n\t\t     * <a id='views'></a>\n\t\t     *\n\t\t     * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n\t\t     *   manually/explicitly.\n\t\t     *\n\t\t     * <a id='abstract'></a>\n\t\t     *\n\t\t     * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,\n\t\t     *   but can provide inherited properties to its common children states.\n\t\t     *\n\t\t     * <a id='onEnter'></a>\n\t\t     *\n\t\t     * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n\t\t     *   to trigger an action or dispatch an event, such as opening a dialog.\n\t\t     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t\t     *\n\t\t     * <a id='onExit'></a>\n\t\t     *\n\t\t     * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n\t\t     *   trigger an action or dispatch an event, such as opening a dialog.\n\t\t     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t\t     *\n\t\t     * <a id='reloadOnSearch'></a>\n\t\t     *\n\t\t     * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state\n\t\t     *   just because a search/query parameter has changed (via $location.search() or $location.hash()).\n\t\t     *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t\t     *\n\t\t     * <a id='data'></a>\n\t\t     *\n\t\t     * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * // Some state name examples\n\t\t     *\n\t\t     * // stateName can be a single top-level name (must be unique).\n\t\t     * $stateProvider.state(\"home\", {});\n\t\t     *\n\t\t     * // Or it can be a nested state name. This state is a child of the\n\t\t     * // above \"home\" state.\n\t\t     * $stateProvider.state(\"home.newest\", {});\n\t\t     *\n\t\t     * // Nest states as deeply as needed.\n\t\t     * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t\t     *\n\t\t     * // state() returns $stateProvider, so you can chain state declarations.\n\t\t     * $stateProvider\n\t\t     *   .state(\"home\", {})\n\t\t     *   .state(\"about\", {})\n\t\t     *   .state(\"contacts\", {});\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t\t     * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t\t     * @param {object} definition State configuration object.\n\t\t     */\n\t\t    StateProvider.prototype.state = function (name, definition) {\n\t\t        if (predicates_1.isObject(name)) {\n\t\t            definition = name;\n\t\t        }\n\t\t        else {\n\t\t            definition.name = name;\n\t\t        }\n\t\t        this.stateRegistry.register(definition);\n\t\t        return this;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$stateProvider#onInvalid\n\t\t     * @methodOf ui.router.state.$stateProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Registers a function to be injected and invoked when transitionTo has been called with an invalid\n\t\t     * state reference parameter\n\t\t     *\n\t\t     * This function can be injected with one some special values:\n\t\t     * - **`$to$`**: TargetState\n\t\t     * - **`$from$`**: TargetState\n\t\t     *\n\t\t     * @param {function} callback\n\t\t     *   The function which will be injected and invoked, when a matching transition is started.\n\t\t     *   The function may optionally return a {TargetState} or a Promise for a TargetState.  If one\n\t\t     *   is returned, it is treated as a redirect.\n\t\t     */\n\t\t    StateProvider.prototype.onInvalid = function (callback) {\n\t\t        this.invalidCallbacks.push(callback);\n\t\t    };\n\t\t    return StateProvider;\n\t\t}());\n\t\texports.StateProvider = StateProvider;\n\t\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar module_1 = __webpack_require__(20);\n\t\tvar parseUrl = function (url) {\n\t\t    if (!predicates_1.isString(url))\n\t\t        return false;\n\t\t    var root = url.charAt(0) === '^';\n\t\t    return { val: root ? url.substring(1) : url, root: root };\n\t\t};\n\t\t/**\n\t\t * @internalapi A internal global service\n\t\t *\n\t\t * StateBuilder is a factory for the internal [[State]] objects.\n\t\t *\n\t\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t\t * [[State]] object, which has an API and is used internally.\n\t\t *\n\t\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t\t * using the [[builder]] method.\n\t\t */\n\t\tvar StateBuilder = (function () {\n\t\t    function StateBuilder(matcher, $urlMatcherFactoryProvider) {\n\t\t        this.matcher = matcher;\n\t\t        var self = this;\n\t\t        var isRoot = function (state) { return state.name === \"\"; };\n\t\t        var root = function () { return matcher.find(\"\"); };\n\t\t        this.builders = {\n\t\t            self: [function (state) {\n\t\t                    state.self.$$state = function () { return state; };\n\t\t                    return state.self;\n\t\t                }],\n\t\t            parent: [function (state) {\n\t\t                    if (isRoot(state))\n\t\t                        return null;\n\t\t                    return matcher.find(self.parentName(state)) || root();\n\t\t                }],\n\t\t            data: [function (state) {\n\t\t                    if (state.parent && state.parent.data) {\n\t\t                        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t\t                    }\n\t\t                    return state.data;\n\t\t                }],\n\t\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t\t            url: [function (state) {\n\t\t                    var stateDec = state;\n\t\t                    var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t\t                    var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t\t                        params: state.params || {},\n\t\t                        paramMap: function (paramConfig, isSearch) {\n\t\t                            if (stateDec.reloadOnSearch === false && isSearch)\n\t\t                                paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t\t                            return paramConfig;\n\t\t                        }\n\t\t                    });\n\t\t                    if (!url)\n\t\t                        return null;\n\t\t                    if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t\t                        throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t\t                    return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t\t                }],\n\t\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t\t            navigable: [function (state) {\n\t\t                    return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t\t                }],\n\t\t            params: [function (state) {\n\t\t                    var makeConfigParam = function (config, id) { return module_1.Param.fromConfig(id, null, config); };\n\t\t                    var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t\t                    var nonUrlParams = common_1.values(common_1.map(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t\t                    return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t\t                }],\n\t\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t\t            // e.g., src/ng1/viewsBuilder.ts\n\t\t            views: [],\n\t\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t\t            path: [function (state) {\n\t\t                    return state.parent ? state.parent.path.concat(state) : [state];\n\t\t                }],\n\t\t            // Speed up $state.includes() as it's used a lot\n\t\t            includes: [function (state) {\n\t\t                    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t\t                    includes[state.name] = true;\n\t\t                    return includes;\n\t\t                }]\n\t\t        };\n\t\t    }\n\t\t    /**\n\t\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t\t     * More than one BuilderFunction can be registered for a given property.\n\t\t     *\n\t\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t\t     *\n\t\t     * @param name The name of the State property being registered for.\n\t\t     * @param fn The BuilderFunction which will be used to build the State property\n\t\t     * @returns a function which deregisters the BuilderFunction\n\t\t     */\n\t\t    StateBuilder.prototype.builder = function (name, fn) {\n\t\t        var builders = this.builders;\n\t\t        var array = builders[name] || [];\n\t\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t\t            return array.length > 1 ? array : array[0];\n\t\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t\t            return;\n\t\t        builders[name] = array;\n\t\t        builders[name].push(fn);\n\t\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t\t    };\n\t\t    /**\n\t\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t\t     * properties and API built.\n\t\t     *\n\t\t     * @param state an uninitialized State object\n\t\t     * @returns the built State object\n\t\t     */\n\t\t    StateBuilder.prototype.build = function (state) {\n\t\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t\t        var parent = this.parentName(state);\n\t\t        if (parent && !matcher.find(parent))\n\t\t            return null;\n\t\t        for (var key in builders) {\n\t\t            if (!builders.hasOwnProperty(key))\n\t\t                continue;\n\t\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t\t            state[key] = chain(state);\n\t\t        }\n\t\t        return state;\n\t\t    };\n\t\t    StateBuilder.prototype.parentName = function (state) {\n\t\t        var name = state.name || \"\";\n\t\t        if (name.indexOf('.') !== -1)\n\t\t            return name.substring(0, name.lastIndexOf('.'));\n\t\t        if (!state.parent)\n\t\t            return \"\";\n\t\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t\t    };\n\t\t    StateBuilder.prototype.name = function (state) {\n\t\t        var name = state.name;\n\t\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t\t            return name;\n\t\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t\t        return parentName ? parentName + \".\" + name : name;\n\t\t    };\n\t\t    return StateBuilder;\n\t\t}());\n\t\texports.StateBuilder = StateBuilder;\n\t\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/**\n\t\t * This module contains code for State Parameters.\n\t\t *\n\t\t * See [[ParamDeclaration]]\n\t\t * @module params\n\t\t * @preferred doc\n\t\t */\n\t\t/** for typedoc */\n\t\t__export(__webpack_require__(21));\n\t\t__export(__webpack_require__(24));\n\t\t__export(__webpack_require__(25));\n\t\t__export(__webpack_require__(23));\n\t\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module params */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar urlMatcherConfig_1 = __webpack_require__(22);\n\t\tvar type_1 = __webpack_require__(23);\n\t\tvar paramTypes_1 = __webpack_require__(24);\n\t\tvar hasOwn = Object.prototype.hasOwnProperty;\n\t\tvar isShorthand = function (cfg) { return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0; };\n\t\t(function (DefType) {\n\t\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t\t})(exports.DefType || (exports.DefType = {}));\n\t\tvar DefType = exports.DefType;\n\t\tfunction unwrapShorthand(cfg) {\n\t\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t\t    return common_1.extend(cfg, {\n\t\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t\t    });\n\t\t}\n\t\tfunction getType(cfg, urlType, location, id) {\n\t\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes_1.paramTypes.type(cfg.type))\n\t\t        return paramTypes_1.paramTypes.type(cfg.type);\n\t\t    if (urlType)\n\t\t        return urlType;\n\t\t    if (!cfg.type)\n\t\t        return (location === DefType.CONFIG ? paramTypes_1.paramTypes.type(\"any\") : paramTypes_1.paramTypes.type(\"string\"));\n\t\t    return cfg.type instanceof type_1.Type ? cfg.type : paramTypes_1.paramTypes.type(cfg.type);\n\t\t}\n\t\t/**\n\t\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t\t */\n\t\tfunction getSquashPolicy(config, isOptional) {\n\t\t    var squash = config.squash;\n\t\t    if (!isOptional || squash === false)\n\t\t        return false;\n\t\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t\t        return urlMatcherConfig_1.matcherConfig.defaultSquashPolicy();\n\t\t    if (squash === true || predicates_1.isString(squash))\n\t\t        return squash;\n\t\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t\t}\n\t\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t\t    var replace, configuredKeys, defaultPolicy = [\n\t\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t\t    ];\n\t\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t\t    if (predicates_1.isString(squash))\n\t\t        replace.push({ from: squash, to: undefined });\n\t\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t\t}\n\t\tvar Param = (function () {\n\t\t    function Param(id, type, config, location) {\n\t\t        config = unwrapShorthand(config);\n\t\t        type = getType(config, type, location, id);\n\t\t        var arrayMode = getArrayMode();\n\t\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t\t        var isOptional = config.value !== undefined;\n\t\t        var dynamic = config.dynamic === true;\n\t\t        var squash = getSquashPolicy(config, isOptional);\n\t\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t\t        function getArrayMode() {\n\t\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t\t        }\n\t\t        common_1.extend(this, { id: id, type: type, location: location, squash: squash, replace: replace, isOptional: isOptional, dynamic: dynamic, config: config, array: arrayMode });\n\t\t    }\n\t\t    Param.prototype.isDefaultValue = function (value) {\n\t\t        return this.isOptional && this.type.equals(this.value(), value);\n\t\t    };\n\t\t    /**\n\t\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t\t     * default value, which may be the result of an injectable function.\n\t\t     */\n\t\t    Param.prototype.value = function (value) {\n\t\t        var _this = this;\n\t\t        /**\n\t\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t\t         */\n\t\t        var $$getDefaultValue = function () {\n\t\t            if (!coreservices_1.services.$injector)\n\t\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of Type (\" + _this.type.name + \")\");\n\t\t            return defaultValue;\n\t\t        };\n\t\t        var $replace = function (val) {\n\t\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t\t            return replacement.length ? replacement[0] : val;\n\t\t        };\n\t\t        value = $replace(value);\n\t\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t\t    };\n\t\t    Param.prototype.isSearch = function () {\n\t\t        return this.location === DefType.SEARCH;\n\t\t    };\n\t\t    Param.prototype.validates = function (value) {\n\t\t        // There was no parameter value, but the param is optional\n\t\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t\t            return true;\n\t\t        // The value was not of the correct Type, and could not be decoded to the correct Type\n\t\t        var normalized = this.type.$normalize(value);\n\t\t        if (!this.type.is(normalized))\n\t\t            return false;\n\t\t        // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t\t        var encoded = this.type.encode(normalized);\n\t\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t\t    };\n\t\t    Param.prototype.toString = function () {\n\t\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t\t    };\n\t\t    /** Creates a new [[Param]] from a CONFIG block */\n\t\t    Param.fromConfig = function (id, type, config) {\n\t\t        return new Param(id, type, config, DefType.CONFIG);\n\t\t    };\n\t\t    /** Creates a new [[Param]] from a url PATH */\n\t\t    Param.fromPath = function (id, type, config) {\n\t\t        return new Param(id, type, config, DefType.PATH);\n\t\t    };\n\t\t    /** Creates a new [[Param]] from a url SEARCH */\n\t\t    Param.fromSearch = function (id, type, config) {\n\t\t        return new Param(id, type, config, DefType.SEARCH);\n\t\t    };\n\t\t    Param.values = function (params, values) {\n\t\t        if (values === void 0) { values = {}; }\n\t\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t\t    };\n\t\t    /**\n\t\t     * Finds [[Param]] objects which have different param values\n\t\t     *\n\t\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t\t     *\n\t\t     * @param params: The list of Param objects to filter\n\t\t     * @param values1: The first set of parameter values\n\t\t     * @param values2: the second set of parameter values\n\t\t     *\n\t\t     * @returns any Param objects whose values were different between values1 and values2\n\t\t     */\n\t\t    Param.changed = function (params, values1, values2) {\n\t\t        if (values1 === void 0) { values1 = {}; }\n\t\t        if (values2 === void 0) { values2 = {}; }\n\t\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t\t    };\n\t\t    /**\n\t\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t\t     *\n\t\t     * @param params The list of [[Param]] objects to check\n\t\t     * @param values1 The first set of param values\n\t\t     * @param values2 The second set of param values\n\t\t     *\n\t\t     * @returns true if the param values in values1 and values2 are equal\n\t\t     */\n\t\t    Param.equals = function (params, values1, values2) {\n\t\t        if (values1 === void 0) { values1 = {}; }\n\t\t        if (values2 === void 0) { values2 = {}; }\n\t\t        return Param.changed(params, values1, values2).length === 0;\n\t\t    };\n\t\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t\t    Param.validates = function (params, values) {\n\t\t        if (values === void 0) { values = {}; }\n\t\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t\t    };\n\t\t    return Param;\n\t\t}());\n\t\texports.Param = Param;\n\t\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module url */ /** for typedoc */\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar MatcherConfig = (function () {\n\t\t    function MatcherConfig() {\n\t\t        this._isCaseInsensitive = false;\n\t\t        this._isStrictMode = true;\n\t\t        this._defaultSquashPolicy = false;\n\t\t    }\n\t\t    MatcherConfig.prototype.caseInsensitive = function (value) {\n\t\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t\t    };\n\t\t    MatcherConfig.prototype.strictMode = function (value) {\n\t\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t\t    };\n\t\t    MatcherConfig.prototype.defaultSquashPolicy = function (value) {\n\t\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t\t    };\n\t\t    return MatcherConfig;\n\t\t}());\n\t\texports.MatcherConfig = MatcherConfig;\n\t\t// TODO: Do not export global instance; create one in UIRouter() constructor\n\t\texports.matcherConfig = new MatcherConfig();\n\t\n\t\n\t/***/ },\n\t/* 23 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module params */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\t/**\n\t\t * Wraps up a `Type` object to handle array values.\n\t\t */\n\t\tfunction ArrayType(type, mode) {\n\t\t    var _this = this;\n\t\t    // Wrap non-array value as array\n\t\t    function arrayWrap(val) { return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []); }\n\t\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t\t    function arrayUnwrap(val) {\n\t\t        switch (val.length) {\n\t\t            case 0: return undefined;\n\t\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t\t            default: return val;\n\t\t        }\n\t\t    }\n\t\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t\t    function arrayHandler(callback, allTruthyMode) {\n\t\t        return function handleArray(val) {\n\t\t            if (predicates_1.isArray(val) && val.length === 0)\n\t\t                return val;\n\t\t            var arr = arrayWrap(val);\n\t\t            var result = common_1.map(arr, callback);\n\t\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t\t        };\n\t\t    }\n\t\t    // Wraps type (.equals) functions to operate on each value of an array\n\t\t    function arrayEqualsHandler(callback) {\n\t\t        return function handleArray(val1, val2) {\n\t\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t\t            if (left.length !== right.length)\n\t\t                return false;\n\t\t            for (var i = 0; i < left.length; i++) {\n\t\t                if (!callback(left[i], right[i]))\n\t\t                    return false;\n\t\t            }\n\t\t            return true;\n\t\t        };\n\t\t    }\n\t\t    ['encode', 'decode', 'equals', '$normalize'].map(function (name) {\n\t\t        _this[name] = (name === 'equals' ? arrayEqualsHandler : arrayHandler)(type[name].bind(type));\n\t\t    });\n\t\t    common_1.extend(this, {\n\t\t        name: type.name,\n\t\t        pattern: type.pattern,\n\t\t        is: arrayHandler(type.is.bind(type), true),\n\t\t        $arrayMode: mode\n\t\t    });\n\t\t}\n\t\t/**\n\t\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t\t * string parameters matched in a URL. Used by [[UrlMatcher]]\n\t\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t\t *\n\t\t * See [[UrlMatcherFactory.type]] for more information on registering custom types.\n\t\t *\n\t\t * @example\n\t\t * ```\n\t\t *\n\t\t * {\n\t\t *   decode: function(val) { return parseInt(val, 10); },\n\t\t *   encode: function(val) { return val && val.toString(); },\n\t\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t\t *   pattern: /\\d+/\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tvar Type = (function () {\n\t\t    /**\n\t\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t\t     *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t\t     * @returns a new Type object\n\t\t     */\n\t\t    function Type(def) {\n\t\t        this.pattern = /.*/;\n\t\t        common_1.extend(this, def);\n\t\t    }\n\t\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t\t    /** @inheritdoc */\n\t\t    Type.prototype.is = function (val, key) { return true; };\n\t\t    /** @inheritdoc */\n\t\t    Type.prototype.encode = function (val, key) { return val; };\n\t\t    /** @inheritdoc */\n\t\t    Type.prototype.decode = function (val, key) { return val; };\n\t\t    /** @inheritdoc */\n\t\t    Type.prototype.equals = function (a, b) { return a == b; };\n\t\t    Type.prototype.$subPattern = function () {\n\t\t        var sub = this.pattern.toString();\n\t\t        return sub.substr(1, sub.length - 2);\n\t\t    };\n\t\t    Type.prototype.toString = function () {\n\t\t        return \"{Type:\" + this.name + \"}\";\n\t\t    };\n\t\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t\t    Type.prototype.$normalize = function (val) {\n\t\t        return this.is(val) ? val : this.decode(val);\n\t\t    };\n\t\t    /**\n\t\t     * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t\t     * e.g.:\n\t\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t\t     * - url: \"/path?queryParam=1&queryParam=2\n\t\t     * - $stateParams.queryParam will be [1, 2]\n\t\t     * if `mode` is \"auto\", then\n\t\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t\t     */\n\t\t    Type.prototype.$asArray = function (mode, isSearch) {\n\t\t        if (!mode)\n\t\t            return this;\n\t\t        if (mode === \"auto\" && !isSearch)\n\t\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t\t        return new ArrayType(this, mode);\n\t\t    };\n\t\t    return Type;\n\t\t}());\n\t\texports.Type = Type;\n\t\n\t\n\t/***/ },\n\t/* 24 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module params */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar type_1 = __webpack_require__(23);\n\t\t// Use tildes to pre-encode slashes.\n\t\t// If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t\t// and bidirectional encoding/decoding fails.\n\t\t// Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t\tfunction valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t\tfunction valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\tvar ParamTypes = (function () {\n\t\t    function ParamTypes() {\n\t\t        this.enqueue = true;\n\t\t        this.typeQueue = [];\n\t\t        this.defaultTypes = {\n\t\t            \"hash\": {\n\t\t                encode: valToString,\n\t\t                decode: valFromString,\n\t\t                is: hof_1.is(String),\n\t\t                pattern: /.*/,\n\t\t                equals: function (a, b) { return a == b; } // allow coersion for null/undefined/\"\"\n\t\t            },\n\t\t            \"string\": {\n\t\t                encode: valToString,\n\t\t                decode: valFromString,\n\t\t                is: hof_1.is(String),\n\t\t                pattern: /[^/]*/\n\t\t            },\n\t\t            \"int\": {\n\t\t                encode: valToString,\n\t\t                decode: function (val) { return parseInt(val, 10); },\n\t\t                is: function (val) { return predicates_1.isDefined(val) && this.decode(val.toString()) === val; },\n\t\t                pattern: /-?\\d+/\n\t\t            },\n\t\t            \"bool\": {\n\t\t                encode: function (val) { return val && 1 || 0; },\n\t\t                decode: function (val) { return parseInt(val, 10) !== 0; },\n\t\t                is: hof_1.is(Boolean),\n\t\t                pattern: /0|1/\n\t\t            },\n\t\t            \"date\": {\n\t\t                encode: function (val) {\n\t\t                    return !this.is(val) ? undefined : [\n\t\t                        val.getFullYear(),\n\t\t                        ('0' + (val.getMonth() + 1)).slice(-2),\n\t\t                        ('0' + val.getDate()).slice(-2)\n\t\t                    ].join(\"-\");\n\t\t                },\n\t\t                decode: function (val) {\n\t\t                    if (this.is(val))\n\t\t                        return val;\n\t\t                    var match = this.capture.exec(val);\n\t\t                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t\t                },\n\t\t                is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t\t                equals: function (l, r) {\n\t\t                    return ['getFullYear', 'getMonth', 'getDate']\n\t\t                        .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t\t                },\n\t\t                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t\t                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t\t            },\n\t\t            \"json\": {\n\t\t                encode: common_1.toJson,\n\t\t                decode: common_1.fromJson,\n\t\t                is: hof_1.is(Object),\n\t\t                equals: common_1.equals,\n\t\t                pattern: /[^/]*/\n\t\t            },\n\t\t            \"any\": {\n\t\t                encode: common_1.identity,\n\t\t                decode: common_1.identity,\n\t\t                equals: common_1.equals,\n\t\t                pattern: /.*/\n\t\t            }\n\t\t        };\n\t\t        // Register default types. Store them in the prototype of this.types.\n\t\t        var makeType = function (definition, name) { return new type_1.Type(common_1.extend({ name: name }, definition)); };\n\t\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t\t    }\n\t\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t\t        if (!predicates_1.isDefined(definition))\n\t\t            return this.types[name];\n\t\t        if (this.types.hasOwnProperty(name))\n\t\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\t        this.types[name] = new type_1.Type(common_1.extend({ name: name }, definition));\n\t\t        if (definitionFn) {\n\t\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t\t            if (!this.enqueue)\n\t\t                this._flushTypeQueue();\n\t\t        }\n\t\t        return this;\n\t\t    };\n\t\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t\t        while (this.typeQueue.length) {\n\t\t            var type = this.typeQueue.shift();\n\t\t            if (type.pattern)\n\t\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t\t        }\n\t\t    };\n\t\t    return ParamTypes;\n\t\t}());\n\t\texports.ParamTypes = ParamTypes;\n\t\texports.paramTypes = new ParamTypes();\n\t\n\t\n\t/***/ },\n\t/* 25 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module params */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar StateParams = (function () {\n\t\t    function StateParams(params) {\n\t\t        if (params === void 0) { params = {}; }\n\t\t        common_1.extend(this, params);\n\t\t    }\n\t\t    /**\n\t\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t\t     * current state and a given destination state.\n\t\t     *\n\t\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t\t     * @param {Object} $current Internal definition of object representing the current state.\n\t\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t\t     */\n\t\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\t        for (var i in parents) {\n\t\t            if (!parents[i] || !parents[i].params)\n\t\t                continue;\n\t\t            parentParams = Object.keys(parents[i].params);\n\t\t            if (!parentParams.length)\n\t\t                continue;\n\t\t            for (var j in parentParams) {\n\t\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t\t                    continue;\n\t\t                inheritList.push(parentParams[j]);\n\t\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t\t            }\n\t\t        }\n\t\t        return common_1.extend({}, inherited, newParams);\n\t\t    };\n\t\t    ;\n\t\t    return StateParams;\n\t\t}());\n\t\texports.StateParams = StateParams;\n\t\n\t\n\t/***/ },\n\t/* 26 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar targetState_1 = __webpack_require__(27);\n\t\tvar viewHooks_1 = __webpack_require__(28);\n\t\tvar enterExitHooks_1 = __webpack_require__(29);\n\t\tvar resolveHooks_1 = __webpack_require__(30);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\t/**\n\t\t * This class:\n\t\t *\n\t\t * * Takes a blank transition object and adds all the hooks necessary for it to behave like a state transition.\n\t\t *\n\t\t * * Runs the transition, returning a chained promise which:\n\t\t *   * transforms the resolved Transition.promise to the final destination state.\n\t\t *   * manages the rejected Transition.promise, checking for Dynamic or Redirected transitions\n\t\t *\n\t\t * * Registers a handler to update global $state data such as \"active transitions\" and \"current state/params\"\n\t\t *\n\t\t * * Registers view hooks, which maintain the list of active view configs and sync with/update the ui-views\n\t\t *\n\t\t * * Registers onEnter/onRetain/onExit hooks which delegate to the state's hooks of the same name, at the appropriate time\n\t\t *\n\t\t * * Registers eager and lazy resolve hooks\n\t\t */\n\t\tvar TransitionManager = (function () {\n\t\t    function TransitionManager(transition, $transitions, $urlRouter, $view, // service\n\t\t        $state, globals) {\n\t\t        this.transition = transition;\n\t\t        this.$transitions = $transitions;\n\t\t        this.$urlRouter = $urlRouter;\n\t\t        this.$view = $view;\n\t\t        this.$state = $state;\n\t\t        this.globals = globals;\n\t\t        this.$q = coreservices_1.services.$q;\n\t\t        this.viewHooks = new viewHooks_1.ViewHooks(transition, $view);\n\t\t        this.enterExitHooks = new enterExitHooks_1.EnterExitHooks(transition);\n\t\t        this.resolveHooks = new resolveHooks_1.ResolveHooks(transition);\n\t\t        this.treeChanges = transition.treeChanges();\n\t\t        this.registerUpdateGlobalState();\n\t\t        this.viewHooks.registerHooks();\n\t\t        this.enterExitHooks.registerHooks();\n\t\t        this.resolveHooks.registerHooks();\n\t\t    }\n\t\t    TransitionManager.prototype.runTransition = function () {\n\t\t        var _this = this;\n\t\t        this.globals.transitionHistory.enqueue(this.transition);\n\t\t        return this.transition.run()\n\t\t            .then(function (trans) { return trans.to(); }) // resolve to the final state (TODO: good? bad?)\n\t\t            .catch(function (error) { return _this.transRejected(error); }); // if rejected, handle dynamic and redirect\n\t\t    };\n\t\t    TransitionManager.prototype.registerUpdateGlobalState = function () {\n\t\t        // After globals.current is updated at priority: 10000\n\t\t        this.transition.onSuccess({}, this.updateUrl.bind(this), { priority: 9999 });\n\t\t    };\n\t\t    TransitionManager.prototype.transRejected = function (error) {\n\t\t        var _a = this, transition = _a.transition, $state = _a.$state, $q = _a.$q;\n\t\t        // Handle redirect and abort\n\t\t        if (error instanceof rejectFactory_1.Rejection) {\n\t\t            if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t\t                this.$urlRouter.update();\n\t\t                return $state.current;\n\t\t            }\n\t\t            if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && error.detail instanceof targetState_1.TargetState) {\n\t\t                return this._redirectMgr(transition.redirect(error.detail)).runTransition();\n\t\t            }\n\t\t            if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t\t                this.$urlRouter.update();\n\t\t            }\n\t\t        }\n\t\t        this.$transitions.defaultErrorHandler()(error);\n\t\t        return $q.reject(error);\n\t\t    };\n\t\t    TransitionManager.prototype.updateUrl = function () {\n\t\t        var transition = this.transition;\n\t\t        var _a = this, $urlRouter = _a.$urlRouter, $state = _a.$state;\n\t\t        var options = transition.options();\n\t\t        if (options.location && $state.$current.navigable) {\n\t\t            $urlRouter.push($state.$current.navigable.url, $state.params, { replace: options.location === 'replace' });\n\t\t        }\n\t\t        $urlRouter.update(true);\n\t\t    };\n\t\t    TransitionManager.prototype._redirectMgr = function (redirect) {\n\t\t        var _a = this, $transitions = _a.$transitions, $urlRouter = _a.$urlRouter, $view = _a.$view, $state = _a.$state, globals = _a.globals;\n\t\t        return new TransitionManager(redirect, $transitions, $urlRouter, $view, $state, globals);\n\t\t    };\n\t\t    return TransitionManager;\n\t\t}());\n\t\texports.TransitionManager = TransitionManager;\n\t\n\t\n\t/***/ },\n\t/* 27 */\n\t/***/ function(module, exports) {\n\t\n\t\t/** @module state */ /** for typedoc */\n\t\t\"use strict\";\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.state.type:TargetState\n\t\t *\n\t\t * @description\n\t\t * Encapsulate the desired target of a transition.\n\t\t * Wraps an identifier for a state, a set of parameters, and transition options with the definition of the state.\n\t\t *\n\t\t * @param {StateOrName} _identifier  An identifier for a state. Either a fully-qualified path, or the object\n\t\t *            used to define the state.\n\t\t * @param {IState} _definition The `State` object definition.\n\t\t * @param {ParamsOrArray} _params Parameters for the target state\n\t\t * @param {TransitionOptions} _options Transition options.\n\t\t */\n\t\tvar TargetState = (function () {\n\t\t    function TargetState(_identifier, _definition, _params, _options) {\n\t\t        if (_params === void 0) { _params = {}; }\n\t\t        if (_options === void 0) { _options = {}; }\n\t\t        this._identifier = _identifier;\n\t\t        this._definition = _definition;\n\t\t        this._options = _options;\n\t\t        this._params = _params || {};\n\t\t    }\n\t\t    TargetState.prototype.name = function () {\n\t\t        return this._definition && this._definition.name || this._identifier;\n\t\t    };\n\t\t    TargetState.prototype.identifier = function () {\n\t\t        return this._identifier;\n\t\t    };\n\t\t    TargetState.prototype.params = function () {\n\t\t        return this._params;\n\t\t    };\n\t\t    TargetState.prototype.$state = function () {\n\t\t        return this._definition;\n\t\t    };\n\t\t    TargetState.prototype.state = function () {\n\t\t        return this._definition && this._definition.self;\n\t\t    };\n\t\t    TargetState.prototype.options = function () {\n\t\t        return this._options;\n\t\t    };\n\t\t    TargetState.prototype.exists = function () {\n\t\t        return !!(this._definition && this._definition.self);\n\t\t    };\n\t\t    TargetState.prototype.valid = function () {\n\t\t        return !this.error();\n\t\t    };\n\t\t    TargetState.prototype.error = function () {\n\t\t        var base = this.options().relative;\n\t\t        if (!this._definition && !!base) {\n\t\t            var stateName = base.name ? base.name : base;\n\t\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t\t        }\n\t\t        if (!this._definition)\n\t\t            return \"No such state '\" + this.name() + \"'\";\n\t\t        if (!this._definition.self)\n\t\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t\t    };\n\t\t    return TargetState;\n\t\t}());\n\t\texports.TargetState = TargetState;\n\t\n\t\n\t/***/ },\n\t/* 28 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar ViewHooks = (function () {\n\t\t    function ViewHooks(transition, $view) {\n\t\t        this.transition = transition;\n\t\t        this.$view = $view;\n\t\t        this.treeChanges = transition.treeChanges();\n\t\t        this.enteringViews = transition.views(\"entering\");\n\t\t        this.exitingViews = transition.views(\"exiting\");\n\t\t    }\n\t\t    ViewHooks.prototype.loadAllEnteringViews = function () {\n\t\t        return coreservices_1.services.$q.all(this.enteringViews.map(function (view) { return view.load(); })).then(common_1.noop);\n\t\t    };\n\t\t    ViewHooks.prototype.updateViews = function () {\n\t\t        var $view = this.$view;\n\t\t        this.exitingViews.forEach(function (viewConfig) { return $view.deactivateViewConfig(viewConfig); });\n\t\t        this.enteringViews.forEach(function (viewConfig) { return $view.activateViewConfig(viewConfig); });\n\t\t        $view.sync();\n\t\t    };\n\t\t    ViewHooks.prototype.registerHooks = function () {\n\t\t        if (this.enteringViews.length) {\n\t\t            this.transition.onStart({}, this.loadAllEnteringViews.bind(this));\n\t\t        }\n\t\t        if (this.exitingViews.length || this.enteringViews.length)\n\t\t            this.transition.onSuccess({}, this.updateViews.bind(this));\n\t\t    };\n\t\t    return ViewHooks;\n\t\t}());\n\t\texports.ViewHooks = ViewHooks;\n\t\n\t\n\t/***/ },\n\t/* 29 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\tvar EnterExitHooks = (function () {\n\t\t    function EnterExitHooks(transition) {\n\t\t        this.transition = transition;\n\t\t    }\n\t\t    EnterExitHooks.prototype.registerHooks = function () {\n\t\t        this.registerOnEnterHooks();\n\t\t        this.registerOnRetainHooks();\n\t\t        this.registerOnExitHooks();\n\t\t    };\n\t\t    EnterExitHooks.prototype.registerOnEnterHooks = function () {\n\t\t        var _this = this;\n\t\t        this.transition.entering().filter(function (state) { return !!state.onEnter; })\n\t\t            .forEach(function (state) { return _this.transition.onEnter({ entering: state.name }, state.onEnter); });\n\t\t    };\n\t\t    EnterExitHooks.prototype.registerOnRetainHooks = function () {\n\t\t        var _this = this;\n\t\t        this.transition.retained().filter(function (state) { return !!state.onRetain; })\n\t\t            .forEach(function (state) { return _this.transition.onRetain({ retained: state.name }, state.onRetain); });\n\t\t    };\n\t\t    EnterExitHooks.prototype.registerOnExitHooks = function () {\n\t\t        var _this = this;\n\t\t        this.transition.exiting().filter(function (state) { return !!state.onExit; })\n\t\t            .forEach(function (state) { return _this.transition.onExit({ exiting: state.name }, state.onExit); });\n\t\t    };\n\t\t    return EnterExitHooks;\n\t\t}());\n\t\texports.EnterExitHooks = EnterExitHooks;\n\t\n\t\n\t/***/ },\n\t/* 30 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar interface_1 = __webpack_require__(31);\n\t\tvar hof_2 = __webpack_require__(5);\n\t\tvar resolvable_1 = __webpack_require__(32);\n\t\tvar LAZY = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];\n\t\tvar EAGER = interface_1.ResolvePolicy[interface_1.ResolvePolicy.EAGER];\n\t\t/**\n\t\t * Registers Eager and Lazy (for entering states) resolve hooks\n\t\t *\n\t\t * * registers a hook that resolves EAGER resolves, for the To Path, onStart of the transition\n\t\t * * registers a hook that resolves LAZY resolves, for each state, before it is entered\n\t\t */\n\t\tvar ResolveHooks = (function () {\n\t\t    function ResolveHooks(transition) {\n\t\t        this.transition = transition;\n\t\t    }\n\t\t    ResolveHooks.prototype.registerHooks = function () {\n\t\t        var treeChanges = this.transition.treeChanges();\n\t\t        /** a function which resolves any EAGER Resolvables for a Path */\n\t\t        $eagerResolvePath.$inject = ['$transition$'];\n\t\t        function $eagerResolvePath($transition$) {\n\t\t            return common_1.tail(treeChanges.to).resolveContext.resolvePath(common_1.extend({ transition: $transition$ }, { resolvePolicy: EAGER }));\n\t\t        }\n\t\t        /** Returns a function which pre-resolves any LAZY Resolvables for a Node in a Path */\n\t\t        $lazyResolveEnteringState.$inject = ['$state$', '$transition$'];\n\t\t        function $lazyResolveEnteringState($state$, $transition$) {\n\t\t            var node = common_1.find(treeChanges.entering, hof_1.propEq('state', $state$));\n\t\t            // A new Resolvable contains all the resolved data in this context as a single object, for injection as `$resolve$`\n\t\t            var context = node.resolveContext;\n\t\t            var $resolve$ = new resolvable_1.Resolvable(\"$resolve$\", function () { return common_1.map(context.getResolvables(), function (r) { return r.data; }); });\n\t\t            var options = common_1.extend({ transition: $transition$ }, { resolvePolicy: LAZY });\n\t\t            // Resolve all the LAZY resolves, then resolve the `$resolve$` object, then add `$resolve$` to the context\n\t\t            return context.resolvePathElement(node.state, options)\n\t\t                .then(function () { return $resolve$.resolveResolvable(context); })\n\t\t                .then(function () { return context.addResolvables({ $resolve$: $resolve$ }, node.state); });\n\t\t        }\n\t\t        // Resolve eager resolvables before when the transition starts\n\t\t        this.transition.onStart({}, $eagerResolvePath, { priority: 1000 });\n\t\t        // Resolve lazy resolvables before each state is entered\n\t\t        this.transition.onEnter({ entering: hof_2.val(true) }, $lazyResolveEnteringState, { priority: 1000 });\n\t\t    };\n\t\t    return ResolveHooks;\n\t\t}());\n\t\texports.ResolveHooks = ResolveHooks;\n\t\n\t\n\t/***/ },\n\t/* 31 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t// Defines the available policies and their ordinals.\n\t\t(function (ResolvePolicy) {\n\t\t    ResolvePolicy[ResolvePolicy[\"JIT\"] = 0] = \"JIT\";\n\t\t    ResolvePolicy[ResolvePolicy[\"LAZY\"] = 1] = \"LAZY\";\n\t\t    ResolvePolicy[ResolvePolicy[\"EAGER\"] = 2] = \"EAGER\"; // Eager resolves are resolved before the transition starts.\n\t\t})(exports.ResolvePolicy || (exports.ResolvePolicy = {}));\n\t\tvar ResolvePolicy = exports.ResolvePolicy;\n\t\n\t\n\t/***/ },\n\t/* 32 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module resolve */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\t/**\n\t\t * The basic building block for the resolve system.\n\t\t *\n\t\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t\t *\n\t\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t\t * resolveFn) and returns the resulting promise.\n\t\t *\n\t\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t\t * parameter to those fns.\n\t\t */\n\t\tvar Resolvable = (function () {\n\t\t    function Resolvable(name, resolveFn, preResolvedData) {\n\t\t        this.promise = undefined;\n\t\t        common_1.extend(this, {\n\t\t            name: name,\n\t\t            resolveFn: resolveFn,\n\t\t            deps: coreservices_1.services.$injector.annotate(resolveFn, coreservices_1.services.$injector.strictDi),\n\t\t            data: preResolvedData\n\t\t        });\n\t\t    }\n\t\t    // synchronous part:\n\t\t    // - sets up the Resolvable's promise\n\t\t    // - retrieves dependencies' promises\n\t\t    // - returns promise for async part\n\t\t    // asynchronous part:\n\t\t    // - wait for dependencies promises to resolve\n\t\t    // - invoke the resolveFn\n\t\t    // - wait for resolveFn promise to resolve\n\t\t    // - store unwrapped data\n\t\t    // - resolve the Resolvable's promise\n\t\t    Resolvable.prototype.resolveResolvable = function (resolveContext, options) {\n\t\t        var _this = this;\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var _a = this, name = _a.name, deps = _a.deps, resolveFn = _a.resolveFn;\n\t\t        trace_1.trace.traceResolveResolvable(this, options);\n\t\t        // First, set up an overall deferred/promise for this Resolvable\n\t\t        var deferred = coreservices_1.services.$q.defer();\n\t\t        this.promise = deferred.promise;\n\t\t        // Load a map of all resolvables for this state from the context path\n\t\t        // Omit the current Resolvable from the result, so we don't try to inject this into this\n\t\t        var ancestorsByName = resolveContext.getResolvables(null, { omitOwnLocals: [name] });\n\t\t        // Limit the ancestors Resolvables map to only those that the current Resolvable fn's annotations depends on\n\t\t        var depResolvables = common_1.pick(ancestorsByName, deps);\n\t\t        // Get promises (or synchronously invoke resolveFn) for deps\n\t\t        var depPromises = common_1.map(depResolvables, function (resolvable) { return resolvable.get(resolveContext, options); });\n\t\t        // Return a promise chain that waits for all the deps to resolve, then invokes the resolveFn passing in the\n\t\t        // dependencies as locals, then unwraps the resulting promise's data.\n\t\t        return coreservices_1.services.$q.all(depPromises).then(function (locals) {\n\t\t            try {\n\t\t                var result = coreservices_1.services.$injector.invoke(resolveFn, null, locals);\n\t\t                deferred.resolve(result);\n\t\t            }\n\t\t            catch (error) {\n\t\t                deferred.reject(error);\n\t\t            }\n\t\t            return _this.promise;\n\t\t        }).then(function (data) {\n\t\t            _this.data = data;\n\t\t            trace_1.trace.traceResolvableResolved(_this, options);\n\t\t            return _this.promise;\n\t\t        });\n\t\t    };\n\t\t    Resolvable.prototype.get = function (resolveContext, options) {\n\t\t        return this.promise || this.resolveResolvable(resolveContext, options);\n\t\t    };\n\t\t    Resolvable.prototype.toString = function () {\n\t\t        return \"Resolvable(name: \" + this.name + \", requires: [\" + this.deps + \"])\";\n\t\t    };\n\t\t    /**\n\t\t     * Validates the result map as a \"resolve:\" style object, then transforms the resolves into Resolvables\n\t\t     */\n\t\t    Resolvable.makeResolvables = function (resolves) {\n\t\t        // If a hook result is an object, it should be a map of strings to functions.\n\t\t        var invalid = common_1.filter(resolves, hof_1.not(predicates_1.isInjectable)), keys = Object.keys(invalid);\n\t\t        if (keys.length)\n\t\t            throw new Error(\"Invalid resolve key/value: \" + keys[0] + \"/\" + invalid[keys[0]]);\n\t\t        return common_1.map(resolves, function (fn, name) { return new Resolvable(name, fn); });\n\t\t    };\n\t\t    return Resolvable;\n\t\t}());\n\t\texports.Resolvable = Resolvable;\n\t\n\t\n\t/***/ },\n\t/* 33 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module state */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.state.type:State\n\t\t *\n\t\t * @description\n\t\t * Definition object for states. Includes methods for manipulating the state heirarchy.\n\t\t *\n\t\t * @param {Object} config  A configuration object hash that includes the results of user-supplied\n\t\t *        values, as well as values from `StateBuilder`.\n\t\t *\n\t\t * @returns {Object}  Returns a new `State` object.\n\t\t */\n\t\tvar State = (function () {\n\t\t    function State(config) {\n\t\t        common_1.extend(this, config);\n\t\t        // Object.freeze(this);\n\t\t    }\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.type:State#is\n\t\t     * @methodOf ui.router.state.type:State\n\t\t     *\n\t\t     * @description\n\t\t     * Compares the identity of the state against the passed value, which is either an object\n\t\t     * reference to the actual `State` instance, the original definition object passed to\n\t\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t\t     *\n\t\t     * @param {Object} ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t\t     * @returns {boolean} Returns `true` if `ref` matches the current `State` instance.\n\t\t     */\n\t\t    State.prototype.is = function (ref) {\n\t\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.type:State#fqn\n\t\t     * @methodOf ui.router.state.type:State\n\t\t     *\n\t\t     * @description\n\t\t     * Returns the fully-qualified name of the state, based on its current position in the tree.\n\t\t     *\n\t\t     * @returns {string} Returns a dot-separated name of the state.\n\t\t     */\n\t\t    State.prototype.fqn = function () {\n\t\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t\t            return this.name;\n\t\t        var name = this.parent.fqn();\n\t\t        return name ? name + \".\" + this.name : this.name;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.type:State#root\n\t\t     * @methodOf ui.router.state.type:State\n\t\t     *\n\t\t     * @description\n\t\t     * Returns the root node of this state's tree.\n\t\t     *\n\t\t     * @returns {State} The root of this state's tree.\n\t\t     */\n\t\t    State.prototype.root = function () {\n\t\t        return this.parent && this.parent.root() || this;\n\t\t    };\n\t\t    State.prototype.parameters = function (opts) {\n\t\t        opts = common_1.defaults(opts, { inherit: true });\n\t\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t\t        return inherited.concat(common_1.values(this.params));\n\t\t    };\n\t\t    State.prototype.parameter = function (id, opts) {\n\t\t        if (opts === void 0) { opts = {}; }\n\t\t        return (this.url && this.url.parameter(id, opts) ||\n\t\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t\t    };\n\t\t    State.prototype.toString = function () {\n\t\t        return this.fqn();\n\t\t    };\n\t\t    return State;\n\t\t}());\n\t\texports.State = State;\n\t\n\t\n\t/***/ },\n\t/* 34 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar StateMatcher = (function () {\n\t\t    function StateMatcher(_states) {\n\t\t        this._states = _states;\n\t\t    }\n\t\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t\t        stateName = stateName || \"\";\n\t\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t\t    };\n\t\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t\t        if (!stateOrName && stateOrName !== \"\")\n\t\t            return undefined;\n\t\t        var isStr = predicates_1.isString(stateOrName);\n\t\t        var name = isStr ? stateOrName : stateOrName.name;\n\t\t        if (this.isRelative(name))\n\t\t            name = this.resolvePath(name, base);\n\t\t        var state = this._states[name];\n\t\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t\t            return state;\n\t\t        }\n\t\t        return undefined;\n\t\t    };\n\t\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t\t        if (!base)\n\t\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t\t        var baseState = this.find(base);\n\t\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t\t        for (; i < pathLength; i++) {\n\t\t            if (splitName[i] === \"\" && i === 0) {\n\t\t                current = baseState;\n\t\t                continue;\n\t\t            }\n\t\t            if (splitName[i] === \"^\") {\n\t\t                if (!current.parent)\n\t\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t\t                current = current.parent;\n\t\t                continue;\n\t\t            }\n\t\t            break;\n\t\t        }\n\t\t        var relName = splitName.slice(i).join(\".\");\n\t\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t\t    };\n\t\t    return StateMatcher;\n\t\t}());\n\t\texports.StateMatcher = StateMatcher;\n\t\n\t\n\t/***/ },\n\t/* 35 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(17);\n\t\tvar StateQueueManager = (function () {\n\t\t    function StateQueueManager(states, builder, $urlRouterProvider) {\n\t\t        this.states = states;\n\t\t        this.builder = builder;\n\t\t        this.$urlRouterProvider = $urlRouterProvider;\n\t\t        this.queue = [];\n\t\t    }\n\t\t    StateQueueManager.prototype.register = function (config) {\n\t\t        var _a = this, states = _a.states, queue = _a.queue, $state = _a.$state;\n\t\t        // Wrap a new object around the state so we can store our private details easily.\n\t\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t\t        var state = common_1.inherit(new module_1.State(), common_1.extend({}, config, {\n\t\t            self: config,\n\t\t            resolve: config.resolve || {},\n\t\t            toString: function () { return config.name; }\n\t\t        }));\n\t\t        if (!predicates_1.isString(state.name))\n\t\t            throw new Error(\"State must have a valid name\");\n\t\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t\t        queue.push(state);\n\t\t        if (this.$state) {\n\t\t            this.flush($state);\n\t\t        }\n\t\t        return state;\n\t\t    };\n\t\t    StateQueueManager.prototype.flush = function ($state) {\n\t\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t\t        var result, state, orphans = [], orphanIdx, previousQueueLength = {};\n\t\t        while (queue.length > 0) {\n\t\t            state = queue.shift();\n\t\t            result = builder.build(state);\n\t\t            orphanIdx = orphans.indexOf(state);\n\t\t            if (result) {\n\t\t                if (states.hasOwnProperty(state.name))\n\t\t                    throw new Error(\"State '\" + name + \"' is already defined\");\n\t\t                states[state.name] = state;\n\t\t                this.attachRoute($state, state);\n\t\t                if (orphanIdx >= 0)\n\t\t                    orphans.splice(orphanIdx, 1);\n\t\t                continue;\n\t\t            }\n\t\t            var prev = previousQueueLength[state.name];\n\t\t            previousQueueLength[state.name] = queue.length;\n\t\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t\t                return states;\n\t\t            }\n\t\t            else if (orphanIdx < 0) {\n\t\t                orphans.push(state);\n\t\t            }\n\t\t            queue.push(state);\n\t\t        }\n\t\t        return states;\n\t\t    };\n\t\t    StateQueueManager.prototype.autoFlush = function ($state) {\n\t\t        this.$state = $state;\n\t\t        this.flush($state);\n\t\t    };\n\t\t    StateQueueManager.prototype.attachRoute = function ($state, state) {\n\t\t        var $urlRouterProvider = this.$urlRouterProvider;\n\t\t        if (state[common_1.abstractKey] || !state.url)\n\t\t            return;\n\t\t        $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t\t                if ($state.$current.navigable !== state || !common_1.equalForKeys($match, $stateParams)) {\n\t\t                    $state.transitionTo(state, $match, { inherit: true, location: false });\n\t\t                }\n\t\t            }]);\n\t\t    };\n\t\t    return StateQueueManager;\n\t\t}());\n\t\texports.StateQueueManager = StateQueueManager;\n\t\n\t\n\t/***/ },\n\t/* 36 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module state */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar stateMatcher_1 = __webpack_require__(34);\n\t\tvar stateBuilder_1 = __webpack_require__(19);\n\t\tvar stateQueueManager_1 = __webpack_require__(35);\n\t\tvar StateRegistry = (function () {\n\t\t    function StateRegistry(urlMatcherFactory, urlRouterProvider) {\n\t\t        this.states = {};\n\t\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, urlMatcherFactory);\n\t\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this.states, this.builder, urlRouterProvider);\n\t\t        var rootStateDef = {\n\t\t            name: '',\n\t\t            url: '^',\n\t\t            views: null,\n\t\t            params: {\n\t\t                '#': { value: null, type: 'hash', dynamic: true }\n\t\t            },\n\t\t            abstract: true\n\t\t        };\n\t\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t\t        _root.navigable = null;\n\t\t    }\n\t\t    StateRegistry.prototype.root = function () {\n\t\t        return this._root;\n\t\t    };\n\t\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t\t        return this.stateQueue.register(stateDefinition);\n\t\t    };\n\t\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t\t        var _this = this;\n\t\t        if (arguments.length === 0)\n\t\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t\t        var found = this.matcher.find(stateOrName, base);\n\t\t        return found && found.self || null;\n\t\t    };\n\t\t    StateRegistry.prototype.decorator = function (name, func) {\n\t\t        return this.builder.builder(name, func);\n\t\t    };\n\t\t    return StateRegistry;\n\t\t}());\n\t\texports.StateRegistry = StateRegistry;\n\t\n\t\n\t/***/ },\n\t/* 37 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module state */ /** */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar queue_1 = __webpack_require__(8);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar pathFactory_1 = __webpack_require__(38);\n\t\tvar node_1 = __webpack_require__(39);\n\t\tvar transitionService_1 = __webpack_require__(43);\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar targetState_1 = __webpack_require__(27);\n\t\tvar transitionManager_1 = __webpack_require__(26);\n\t\tvar param_1 = __webpack_require__(21);\n\t\tvar glob_1 = __webpack_require__(7);\n\t\tvar common_2 = __webpack_require__(3);\n\t\tvar common_3 = __webpack_require__(3);\n\t\tvar StateService = (function () {\n\t\t    function StateService($view, $urlRouter, $transitions, stateRegistry, stateProvider, globals) {\n\t\t        this.$view = $view;\n\t\t        this.$urlRouter = $urlRouter;\n\t\t        this.$transitions = $transitions;\n\t\t        this.stateRegistry = stateRegistry;\n\t\t        this.stateProvider = stateProvider;\n\t\t        this.globals = globals;\n\t\t        var getters = ['current', '$current', 'params', 'transition'];\n\t\t        var boundFns = Object.keys(StateService.prototype).filter(function (key) { return getters.indexOf(key) === -1; });\n\t\t        common_3.bindFunctions(StateService.prototype, this, this, boundFns);\n\t\t    }\n\t\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t\t        get: function () { return this.globals.transition; },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t\t        get: function () { return this.globals.params; },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t\t        get: function () { return this.globals.current; },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t\t        get: function () { return this.globals.$current; },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    /**\n\t\t     * Invokes the onInvalid callbacks, in natural order.  Each callback's return value is checked in sequence\n\t\t     * until one of them returns an instance of TargetState.   The results of the callbacks are wrapped\n\t\t     * in $q.when(), so the callbacks may return promises.\n\t\t     *\n\t\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and\n\t\t     * the result returned.\n\t\t     */\n\t\t    StateService.prototype._handleInvalidTargetState = function (fromPath, $to$) {\n\t\t        var _this = this;\n\t\t        var latestThing = function () { return _this.globals.transitionHistory.peekTail(); };\n\t\t        var latest = latestThing();\n\t\t        var $from$ = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t\t        var callbackQueue = new queue_1.Queue([].concat(this.stateProvider.invalidCallbacks));\n\t\t        var $q = coreservices_1.services.$q, $injector = coreservices_1.services.$injector;\n\t\t        var invokeCallback = function (callback) { return $q.when($injector.invoke(callback, null, { $to$: $to$, $from$: $from$ })); };\n\t\t        var checkForRedirect = function (result) {\n\t\t            if (!(result instanceof targetState_1.TargetState)) {\n\t\t                return;\n\t\t            }\n\t\t            var target = result;\n\t\t            // Recreate the TargetState, in case the state is now defined.\n\t\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t\t            if (!target.valid())\n\t\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t\t            if (latestThing() !== latest)\n\t\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t\t        };\n\t\t        function invokeNextCallback() {\n\t\t            var nextCallback = callbackQueue.dequeue();\n\t\t            if (nextCallback === undefined)\n\t\t                return rejectFactory_1.Rejection.invalid($to$.error()).toPromise();\n\t\t            return invokeCallback(nextCallback).then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t\t        }\n\t\t        return invokeNextCallback();\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#reload\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * A method that force reloads the current state, or a partial state hierarchy. All resolves are re-resolved,\n\t\t     * controllers reinstantiated, and events re-fired.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * let app angular.module('app', ['ui.router']);\n\t\t     *\n\t\t     * app.controller('ctrl', function ($scope, $state) {\n\t\t     *   $scope.reload = function(){\n\t\t     *     $state.reload();\n\t\t     *   }\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * `reload()` is just an alias for:\n\t\t     * <pre>\n\t\t     * $state.transitionTo($state.current, $stateParams, {\n\t\t     *   reload: true, inherit: false, notify: true\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string=|object=} reloadState - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t\t     * //and current state is 'contacts.detail.item'\n\t\t     * let app angular.module('app', ['ui.router']);\n\t\t     *\n\t\t     * app.controller('ctrl', function ($scope, $state) {\n\t\t     *   $scope.reload = function(){\n\t\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t\t     *     $state.reload('contact.detail');\n\t\t     *   }\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @returns {promise} A promise representing the state of the new transition. See\n\t\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t\t     */\n\t\t    StateService.prototype.reload = function (reloadState) {\n\t\t        return this.transitionTo(this.current, this.params, {\n\t\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t\t            inherit: false,\n\t\t            notify: false\n\t\t        });\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#go\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * Convenience method for transitioning to a new state. `$state.go` calls\n\t\t     * `$state.transitionTo` internally but automatically sets options to\n\t\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t\t     * This allows you to easily use an absolute or relative to path and specify\n\t\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t\t     * inherit from the currently active ancestor states).\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * let app = angular.module('app', ['ui.router']);\n\t\t     *\n\t\t     * app.controller('ctrl', function ($scope, $state) {\n\t\t     *   $scope.changeState = function () {\n\t\t     *     $state.go('contact.detail');\n\t\t     *   };\n\t\t     * });\n\t\t     * </pre>\n\t\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t\t     *\n\t\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t\t     *\n\t\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t\t     * - `$state.go('^')` - will go to a parent state\n\t\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t\t     *\n\t\t     * @param {object=} params A map of the parameters that will be sent to the state,\n\t\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently\n\t\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t\t     * will get you all current parameters, etc.\n\t\t     * @param {object=} options Options object. The options are:\n\t\t     *\n\t\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t\t     *    defines which state to be relative from.\n\t\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params\n\t\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t\t     *\n\t\t     * @returns {promise} A promise representing the state of the new transition.\n\t\t     *\n\t\t     * Possible success values:\n\t\t     *\n\t\t     * - $state.current\n\t\t     *\n\t\t     * <br/>Possible rejection values:\n\t\t     *\n\t\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t\t     *\n\t\t     */\n\t\t    StateService.prototype.go = function (to, params, options) {\n\t\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t\t        return this.transitionTo(to, params, transOpts);\n\t\t    };\n\t\t    ;\n\t\t    /** Factory method for creating a TargetState */\n\t\t    StateService.prototype.target = function (identifier, params, options) {\n\t\t        if (options === void 0) { options = {}; }\n\t\t        // If we're reloading, find the state object to reload from\n\t\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t\t            throw new Error('Invalid reload state object');\n\t\t        options.reloadState = options.reload === true ? this.stateRegistry.root() : this.stateRegistry.matcher.find(options.reload, options.relative);\n\t\t        if (options.reload && !options.reloadState)\n\t\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t\t        var stateDefinition = this.stateRegistry.matcher.find(identifier, options.relative);\n\t\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#transitionTo\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * let app = angular.module('app', ['ui.router']);\n\t\t     *\n\t\t     * app.controller('ctrl', function ($scope, $state) {\n\t\t     *   $scope.changeState = function () {\n\t\t     *     $state.transitionTo('contact.detail');\n\t\t     *   };\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string} to State name.\n\t\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t\t     * will populate $stateParams.\n\t\t     * @param {object=} options Options object. The options are:\n\t\t     *\n\t\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'),\n\t\t     *    defines which state to be relative from.\n\t\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params\n\t\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t\t     *\n\t\t     * @returns {promise} A promise representing the state of the new transition. See\n\t\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t\t     */\n\t\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t\t        var _this = this;\n\t\t        if (toParams === void 0) { toParams = {}; }\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var transHistory = this.globals.transitionHistory;\n\t\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t\t        var ref = this.target(to, toParams, options);\n\t\t        var latestSuccess = this.globals.successfulTransitions.peekTail();\n\t\t        var rootPath = function () { return pathFactory_1.PathFactory.bindTransNodesToPath([new node_1.Node(_this.stateRegistry.root())]); };\n\t\t        var currentPath = latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t\t        if (!ref.exists())\n\t\t            return this._handleInvalidTargetState(currentPath, ref);\n\t\t        if (!ref.valid())\n\t\t            return coreservices_1.services.$q.reject(ref.error());\n\t\t        var transition = this.$transitions.create(currentPath, ref);\n\t\t        var tMgr = new transitionManager_1.TransitionManager(transition, this.$transitions, this.$urlRouter, this.$view, this, this.globals);\n\t\t        var transitionPromise = tMgr.runTransition();\n\t\t        // Return a promise for the transition, which also has the transition object on it.\n\t\t        return common_1.extend(transitionPromise, { transition: transition });\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#is\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t\t     * but only checks for the full state name. If params is supplied then it will be\n\t\t     * tested for strict equality against the current active params object, so all params\n\t\t     * must match with none missing and no extras.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * $state.$current.name = 'contacts.details.item';\n\t\t     *\n\t\t     * // absolute name\n\t\t     * $state.is('contact.details.item'); // returns true\n\t\t     * $state.is(contactDetailItemStateObject); // returns true\n\t\t     *\n\t\t     * // relative name (. and ^), typically from a template\n\t\t     * // E.g. from the 'contacts.details' template\n\t\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t\t     * to test against the current active state.\n\t\t     * @param {object=} options An options object.  The options are:\n\t\t     *\n\t\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t\t     * test relative to `options.relative` state (or name).\n\t\t     *\n\t\t     * @returns {boolean} Returns true if it is the state.\n\t\t     */\n\t\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t\t        options = common_1.defaults(options, { relative: this.$current });\n\t\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative);\n\t\t        if (!predicates_1.isDefined(state))\n\t\t            return undefined;\n\t\t        if (this.$current !== state)\n\t\t            return false;\n\t\t        return predicates_1.isDefined(params) && params !== null ? param_1.Param.equals(state.parameters(), this.params, params) : true;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#includes\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * A method to determine if the current active state is equal to or is the child of the\n\t\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t\t     *\n\t\t     * @example\n\t\t     * Partial and relative names\n\t\t     * <pre>\n\t\t     * $state.$current.name = 'contacts.details.item';\n\t\t     *\n\t\t     * // Using partial names\n\t\t     * $state.includes(\"contacts\"); // returns true\n\t\t     * $state.includes(\"contacts.details\"); // returns true\n\t\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t\t     * $state.includes(\"contacts.list\"); // returns false\n\t\t     * $state.includes(\"about\"); // returns false\n\t\t     *\n\t\t     * // Using relative names (. and ^), typically from a template\n\t\t     * // E.g. from the 'contacts.details' template\n\t\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t\t     * </pre>\n\t\t     *\n\t\t     * Basic globbing patterns\n\t\t     * <pre>\n\t\t     * $state.$current.name = 'contacts.details.item.url';\n\t\t     *\n\t\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t\t     * $state.includes(\"*.details.**\"); // returns true\n\t\t     * $state.includes(\"**.item.**\"); // returns true\n\t\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t\t     * $state.includes(\"*.details.*\"); // returns false\n\t\t     * $state.includes(\"item.**\"); // returns false\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t\t     * to be searched for within the current state name.\n\t\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t\t     * that you'd like to test against the current active state.\n\t\t     * @param {object=} options An options object.  The options are:\n\t\t     *\n\t\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t\t     * .includes will test relative to `options.relative` state (or name).\n\t\t     *\n\t\t     * @returns {boolean} Returns true if it does include the state\n\t\t     */\n\t\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t\t        options = common_1.defaults(options, { relative: this.$current });\n\t\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t\t        if (glob) {\n\t\t            if (!glob.matches(this.$current.name))\n\t\t                return false;\n\t\t            stateOrName = this.$current.name;\n\t\t        }\n\t\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t\t        if (!predicates_1.isDefined(state))\n\t\t            return undefined;\n\t\t        if (!predicates_1.isDefined(include[state.name]))\n\t\t            return false;\n\t\t        // @TODO Replace with Param.equals() ?\n\t\t        return params ? common_2.equalForKeys(param_1.Param.values(state.parameters(), params), this.params, Object.keys(params)) : true;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$state#href\n\t\t     * @methodOf ui.router.state.$state\n\t\t     *\n\t\t     * @description\n\t\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t\t     * @param {object=} options Options object. The options are:\n\t\t     *\n\t\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t\t     *    ancestor with a valid url).\n\t\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t\t     *    defines which state to be relative from.\n\t\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t\t     *\n\t\t     * @returns {string} compiled state url\n\t\t     */\n\t\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t\t        var defaultHrefOpts = {\n\t\t            lossy: true,\n\t\t            inherit: true,\n\t\t            absolute: false,\n\t\t            relative: this.$current\n\t\t        };\n\t\t        options = common_1.defaults(options, defaultHrefOpts);\n\t\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative);\n\t\t        if (!predicates_1.isDefined(state))\n\t\t            return null;\n\t\t        if (options.inherit)\n\t\t            params = this.params.$inherit(params || {}, this.$current, state);\n\t\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t\t            return null;\n\t\t        }\n\t\t        return this.$urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t\t            absolute: options.absolute\n\t\t        });\n\t\t    };\n\t\t    ;\n\t\t    StateService.prototype.get = function (stateOrName, base) {\n\t\t        if (arguments.length === 0)\n\t\t            return this.stateRegistry.get();\n\t\t        return this.stateRegistry.get(stateOrName, base || this.$current);\n\t\t    };\n\t\t    return StateService;\n\t\t}());\n\t\texports.StateService = StateService;\n\t\n\t\n\t/***/ },\n\t/* 38 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module path */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar module_1 = __webpack_require__(17);\n\t\tvar node_1 = __webpack_require__(39);\n\t\tvar module_2 = __webpack_require__(40);\n\t\t/**\n\t\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t\t */\n\t\tvar PathFactory = (function () {\n\t\t    function PathFactory() {\n\t\t    }\n\t\t    /** Given a Node[], create an TargetState */\n\t\t    PathFactory.makeTargetState = function (path) {\n\t\t        var state = common_1.tail(path).state;\n\t\t        return new module_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t\t    };\n\t\t    PathFactory.buildPath = function (targetState) {\n\t\t        var toParams = targetState.params();\n\t\t        return targetState.$state().path.map(function (state) { return new node_1.Node(state).applyRawParams(toParams); });\n\t\t    };\n\t\t    /** Given a fromPath: Node[] and a TargetState, builds a toPath: Node[] */\n\t\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t\t        var toPath = PathFactory.buildPath(targetState);\n\t\t        if (targetState.options().inherit) {\n\t\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t\t        }\n\t\t        return toPath;\n\t\t    };\n\t\t    PathFactory.applyViewConfigs = function ($view, path) {\n\t\t        return path.map(function (node) {\n\t\t            var viewDecls = common_1.values(node.state.views || {});\n\t\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(node, view); }).reduce(common_1.unnestR, []);\n\t\t            return common_1.extend(node, { views: viewConfigs });\n\t\t        });\n\t\t    };\n\t\t    /**\n\t\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t\t     *\n\t\t     * For a parameter in a node to be inherited from the from path:\n\t\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t\t     * - The parameter name must not be found in the toKeys parameter array.\n\t\t     *\n\t\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t\t     * it is not inherited from the fromPath.\n\t\t     */\n\t\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t\t        if (toKeys === void 0) { toKeys = []; }\n\t\t        function nodeParamVals(path, state) {\n\t\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t\t            return common_1.extend({}, node && node.paramValues);\n\t\t        }\n\t\t        /**\n\t\t         * Given an Node \"toNode\", return a new Node with param values inherited from the\n\t\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t\t         */\n\t\t        var makeInheritedParamsNode = hof_1.curry(function (_fromPath, _toKeys, toNode) {\n\t\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t\t            // limited to only those keys found in toParams\n\t\t            var incomingParamVals = common_1.pick(toParamVals, _toKeys);\n\t\t            toParamVals = common_1.omit(toParamVals, _toKeys);\n\t\t            var fromParamVals = nodeParamVals(_fromPath, toNode.state) || {};\n\t\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t\t            return new node_1.Node(toNode.state).applyRawParams(ownParamVals);\n\t\t        });\n\t\t        // The param keys specified by the incoming toParams\n\t\t        return toPath.map(makeInheritedParamsNode(fromPath, toKeys));\n\t\t    };\n\t\t    /**\n\t\t     * Given a path, upgrades the path to a Node[].  Each node is assigned a ResolveContext\n\t\t     * and ParamValues object which is bound to the whole path, but closes over the subpath from root to the node.\n\t\t     * The views are also added to the node.\n\t\t     */\n\t\t    PathFactory.bindTransNodesToPath = function (resolvePath) {\n\t\t        var resolveContext = new module_2.ResolveContext(resolvePath);\n\t\t        // let paramValues = new ParamValues(resolvePath);\n\t\t        // Attach bound resolveContext and paramValues to each node\n\t\t        // Attach views to each node\n\t\t        resolvePath.forEach(function (node) {\n\t\t            node.resolveContext = resolveContext.isolateRootTo(node.state);\n\t\t            node.resolveInjector = new module_2.ResolveInjector(node.resolveContext, node.state);\n\t\t            node.resolves['$stateParams'] = new module_2.Resolvable(\"$stateParams\", function () { return node.paramValues; }, node.paramValues);\n\t\t        });\n\t\t        return resolvePath;\n\t\t    };\n\t\t    /**\n\t\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t\t     */\n\t\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t\t        var staticParams = function (state) { return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id')); };\n\t\t        var nodesMatch = function (node1, node2) { return node1.equals(node2, staticParams(node1.state)); };\n\t\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t\t            keep++;\n\t\t        }\n\t\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t\t        function applyToParams(retainedNode, idx) {\n\t\t            var cloned = node_1.Node.clone(retainedNode);\n\t\t            cloned.paramValues = toPath[idx].paramValues;\n\t\t            return cloned;\n\t\t        }\n\t\t        var from, retained, exiting, entering, to;\n\t\t        // intermediate vars\n\t\t        var retainedWithToParams, enteringResolvePath, toResolvePath;\n\t\t        from = fromPath;\n\t\t        retained = from.slice(0, keep);\n\t\t        exiting = from.slice(keep);\n\t\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t\t        retainedWithToParams = retained.map(applyToParams);\n\t\t        enteringResolvePath = toPath.slice(keep);\n\t\t        // \"toResolvePath\" is \"retainedWithToParams\" concat \"enteringResolvePath\".\n\t\t        toResolvePath = (retainedWithToParams).concat(enteringResolvePath);\n\t\t        // \"to: is \"toResolvePath\" with ParamValues/ResolveContext added to each node and bound to the path context\n\t\t        to = PathFactory.bindTransNodesToPath(toResolvePath);\n\t\t        // \"entering\" is the tail of \"to\"\n\t\t        entering = to.slice(keep);\n\t\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t\t    };\n\t\t    PathFactory.bindTransitionResolve = function (treeChanges, transition) {\n\t\t        var rootNode = treeChanges.to[0];\n\t\t        rootNode.resolves['$transition$'] = new module_2.Resolvable('$transition$', function () { return transition; }, transition);\n\t\t    };\n\t\t    /**\n\t\t     * Find a subpath of a path that stops at the node for a given state\n\t\t     *\n\t\t     * Given an array of nodes, returns a subset of the array starting from the first node, up to the\n\t\t     * node whose state matches `stateName`\n\t\t     *\n\t\t     * @param path a path of [[Node]]s\n\t\t     * @param state the [[State]] to stop at\n\t\t     */\n\t\t    PathFactory.subPath = function (path, state) {\n\t\t        var node = common_1.find(path, function (_node) { return _node.state === state; });\n\t\t        var elementIdx = path.indexOf(node);\n\t\t        if (elementIdx === -1)\n\t\t            throw new Error(\"The path does not contain the state: \" + state);\n\t\t        return path.slice(0, elementIdx + 1);\n\t\t    };\n\t\t    /** Gets the raw parameter values from a path */\n\t\t    PathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\t\t    return PathFactory;\n\t\t}());\n\t\texports.PathFactory = PathFactory;\n\t\n\t\n\t/***/ },\n\t/* 39 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module path */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar module_1 = __webpack_require__(40);\n\t\tvar Node = (function () {\n\t\t    function Node(state) {\n\t\t        if (state instanceof Node) {\n\t\t            var node = state;\n\t\t            this.state = node.state;\n\t\t            this.paramSchema = node.paramSchema.slice();\n\t\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t\t            this.resolves = common_1.extend({}, node.resolves);\n\t\t            this.views = node.views && node.views.slice();\n\t\t            this.resolveContext = node.resolveContext;\n\t\t            this.resolveInjector = node.resolveInjector;\n\t\t        }\n\t\t        else {\n\t\t            this.state = state;\n\t\t            this.paramSchema = state.parameters({ inherit: false });\n\t\t            this.paramValues = {};\n\t\t            this.resolves = common_1.mapObj(state.resolve, function (fn, name) { return new module_1.Resolvable(name, fn); });\n\t\t        }\n\t\t    }\n\t\t    Node.prototype.applyRawParams = function (params) {\n\t\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t\t        return this;\n\t\t    };\n\t\t    Node.prototype.parameter = function (name) {\n\t\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t\t    };\n\t\t    Node.prototype.equals = function (node, keys) {\n\t\t        var _this = this;\n\t\t        if (keys === void 0) { keys = this.paramSchema.map(hof_1.prop('id')); }\n\t\t        var paramValsEq = function (key) { return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]); };\n\t\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t\t    };\n\t\t    Node.clone = function (node) {\n\t\t        return new Node(node);\n\t\t    };\n\t\t    /**\n\t\t     * Returns a new path which is a subpath of the first path. The new path starts from root and contains any nodes\n\t\t     * that match the nodes in the second path. Nodes are compared using their state property.\n\t\t     * @param first {Node[]}\n\t\t     * @param second {Node[]}\n\t\t     * @returns {Node[]}\n\t\t     */\n\t\t    Node.matching = function (first, second) {\n\t\t        var matchedCount = first.reduce(function (prev, node, i) {\n\t\t            return prev === i && i < second.length && node.state === second[i].state ? i + 1 : prev;\n\t\t        }, 0);\n\t\t        return first.slice(0, matchedCount);\n\t\t    };\n\t\t    return Node;\n\t\t}());\n\t\texports.Node = Node;\n\t\n\t\n\t/***/ },\n\t/* 40 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module resolve */ /** for typedoc */\n\t\t__export(__webpack_require__(31));\n\t\t__export(__webpack_require__(32));\n\t\t__export(__webpack_require__(41));\n\t\t__export(__webpack_require__(42));\n\t\n\t\n\t/***/ },\n\t/* 41 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module resolve */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar interface_1 = __webpack_require__(31);\n\t\tvar common_2 = __webpack_require__(3);\n\t\tvar pathFactory_1 = __webpack_require__(38);\n\t\t// TODO: make this configurable\n\t\tvar defaultResolvePolicy = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];\n\t\tvar ResolveContext = (function () {\n\t\t    function ResolveContext(_path) {\n\t\t        this._path = _path;\n\t\t        common_1.extend(this, {\n\t\t            _nodeFor: function (state) {\n\t\t                return common_1.find(this._path, hof_1.propEq('state', state));\n\t\t            },\n\t\t            _pathTo: function (state) {\n\t\t                return pathFactory_1.PathFactory.subPath(this._path, state);\n\t\t            }\n\t\t        });\n\t\t    }\n\t\t    /**\n\t\t     * Gets the available Resolvables for the last element of this path.\n\t\t     *\n\t\t     * @param state the State (within the ResolveContext's Path) for which to get resolvables\n\t\t     * @param options\n\t\t     *\n\t\t     * options.omitOwnLocals: array of property names\n\t\t     *   Omits those Resolvables which are found on the last element of the path.\n\t\t     *\n\t\t     *   This will hide a deepest-level resolvable (by name), potentially exposing a parent resolvable of\n\t\t     *   the same name further up the state tree.\n\t\t     *\n\t\t     *   This is used by Resolvable.resolve() in order to provide the Resolvable access to all the other\n\t\t     *   Resolvables at its own PathElement level, yet disallow that Resolvable access to its own injectable Resolvable.\n\t\t     *\n\t\t     *   This is also used to allow a state to override a parent state's resolve while also injecting\n\t\t     *   that parent state's resolve:\n\t\t     *\n\t\t     *   state({ name: 'G', resolve: { _G: function() { return \"G\"; } } });\n\t\t     *   state({ name: 'G.G2', resolve: { _G: function(_G) { return _G + \"G2\"; } } });\n\t\t     *   where injecting _G into a controller will yield \"GG2\"\n\t\t     */\n\t\t    ResolveContext.prototype.getResolvables = function (state, options) {\n\t\t        options = common_1.defaults(options, { omitOwnLocals: [] });\n\t\t        var path = (state ? this._pathTo(state) : this._path);\n\t\t        var last = common_1.tail(path);\n\t\t        return path.reduce(function (memo, node) {\n\t\t            var omitProps = (node === last) ? options.omitOwnLocals : [];\n\t\t            var filteredResolvables = common_1.omit(node.resolves, omitProps);\n\t\t            return common_1.extend(memo, filteredResolvables);\n\t\t        }, {});\n\t\t    };\n\t\t    /** Inspects a function `fn` for its dependencies.  Returns an object containing any matching Resolvables */\n\t\t    ResolveContext.prototype.getResolvablesForFn = function (fn) {\n\t\t        var deps = coreservices_1.services.$injector.annotate(fn, coreservices_1.services.$injector.strictDi);\n\t\t        return common_1.pick(this.getResolvables(), deps);\n\t\t    };\n\t\t    ResolveContext.prototype.isolateRootTo = function (state) {\n\t\t        return new ResolveContext(this._pathTo(state));\n\t\t    };\n\t\t    ResolveContext.prototype.addResolvables = function (resolvables, state) {\n\t\t        common_1.extend(this._nodeFor(state).resolves, resolvables);\n\t\t    };\n\t\t    /** Gets the resolvables declared on a particular state */\n\t\t    ResolveContext.prototype.getOwnResolvables = function (state) {\n\t\t        return common_1.extend({}, this._nodeFor(state).resolves);\n\t\t    };\n\t\t    // Returns a promise for an array of resolved path Element promises\n\t\t    ResolveContext.prototype.resolvePath = function (options) {\n\t\t        var _this = this;\n\t\t        if (options === void 0) { options = {}; }\n\t\t        trace_1.trace.traceResolvePath(this._path, options);\n\t\t        var promiseForNode = function (node) { return _this.resolvePathElement(node.state, options); };\n\t\t        return coreservices_1.services.$q.all(common_1.map(this._path, promiseForNode)).then(function (all) { return all.reduce(common_2.mergeR, {}); });\n\t\t    };\n\t\t    // returns a promise for all the resolvables on this PathElement\n\t\t    // options.resolvePolicy: only return promises for those Resolvables which are at \n\t\t    // the specified policy, or above.  i.e., options.resolvePolicy === 'lazy' will\n\t\t    // resolve both 'lazy' and 'eager' resolves.\n\t\t    ResolveContext.prototype.resolvePathElement = function (state, options) {\n\t\t        var _this = this;\n\t\t        if (options === void 0) { options = {}; }\n\t\t        // The caller can request the path be resolved for a given policy and \"below\" \n\t\t        var policy = options && options.resolvePolicy;\n\t\t        var policyOrdinal = interface_1.ResolvePolicy[policy || defaultResolvePolicy];\n\t\t        // Get path Resolvables available to this element\n\t\t        var resolvables = this.getOwnResolvables(state);\n\t\t        var matchesRequestedPolicy = function (resolvable) { return getPolicy(state.resolvePolicy, resolvable) >= policyOrdinal; };\n\t\t        var matchingResolves = common_1.filter(resolvables, matchesRequestedPolicy);\n\t\t        var getResolvePromise = function (resolvable) { return resolvable.get(_this.isolateRootTo(state), options); };\n\t\t        var resolvablePromises = common_1.map(matchingResolves, getResolvePromise);\n\t\t        trace_1.trace.traceResolvePathElement(this, matchingResolves, options);\n\t\t        return coreservices_1.services.$q.all(resolvablePromises);\n\t\t    };\n\t\t    /**\n\t\t     * Injects a function given the Resolvables available in the path, from the first node\n\t\t     * up to the node for the given state.\n\t\t     *\n\t\t     * First it resolves all the resolvable depencies.  When they are done resolving, it invokes\n\t\t     * the function.\n\t\t     *\n\t\t     * @return a promise for the return value of the function.\n\t\t     *\n\t\t     * @param fn: the function to inject (i.e., onEnter, onExit, controller)\n\t\t     * @param locals: are the angular $injector-style locals to inject\n\t\t     * @param options: options (TODO: document)\n\t\t     */\n\t\t    ResolveContext.prototype.invokeLater = function (fn, locals, options) {\n\t\t        var _this = this;\n\t\t        if (locals === void 0) { locals = {}; }\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var resolvables = this.getResolvablesForFn(fn);\n\t\t        trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({ when: \"Later\" }, options));\n\t\t        var getPromise = function (resolvable) { return resolvable.get(_this, options); };\n\t\t        var promises = common_1.map(resolvables, getPromise);\n\t\t        return coreservices_1.services.$q.all(promises).then(function () {\n\t\t            try {\n\t\t                return _this.invokeNow(fn, locals, options);\n\t\t            }\n\t\t            catch (error) {\n\t\t                return coreservices_1.services.$q.reject(error);\n\t\t            }\n\t\t        });\n\t\t    };\n\t\t    /**\n\t\t     * Immediately injects a function with the dependent Resolvables available in the path, from\n\t\t     * the first node up to the node for the given state.\n\t\t     *\n\t\t     * If a Resolvable is not yet resolved, then null is injected in place of the resolvable.\n\t\t     *\n\t\t     * @return the return value of the function.\n\t\t     *\n\t\t     * @param fn: the function to inject (i.e., onEnter, onExit, controller)\n\t\t     * @param locals: are the angular $injector-style locals to inject\n\t\t     * @param options: options (TODO: document)\n\t\t     */\n\t\t    // Injects a function at this PathElement level with available Resolvables\n\t\t    // Does not wait until all Resolvables have been resolved; you must call PathElement.resolve() (or manually resolve each dep) first\n\t\t    ResolveContext.prototype.invokeNow = function (fn, locals, options) {\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var resolvables = this.getResolvablesForFn(fn);\n\t\t        trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({ when: \"Now  \" }, options));\n\t\t        var resolvedLocals = common_1.map(resolvables, hof_1.prop(\"data\"));\n\t\t        return coreservices_1.services.$injector.invoke(fn, options.bind || null, common_1.extend({}, locals, resolvedLocals));\n\t\t    };\n\t\t    return ResolveContext;\n\t\t}());\n\t\texports.ResolveContext = ResolveContext;\n\t\t/**\n\t\t * Given a state's resolvePolicy attribute and a resolvable from that state, returns the policy ordinal for the Resolvable\n\t\t * Use the policy declared for the Resolve. If undefined, use the policy declared for the State.  If\n\t\t * undefined, use the system defaultResolvePolicy.\n\t\t *\n\t\t * @param stateResolvePolicyConf The raw resolvePolicy declaration on the state object; may be a String or Object\n\t\t * @param resolvable The resolvable to compute the policy for\n\t\t */\n\t\tfunction getPolicy(stateResolvePolicyConf, resolvable) {\n\t\t    // Normalize the configuration on the state to either state-level (a string) or resolve-level (a Map of string:string)\n\t\t    var stateLevelPolicy = (predicates_1.isString(stateResolvePolicyConf) ? stateResolvePolicyConf : null);\n\t\t    var resolveLevelPolicies = (predicates_1.isObject(stateResolvePolicyConf) ? stateResolvePolicyConf : {});\n\t\t    var policyName = resolveLevelPolicies[resolvable.name] || stateLevelPolicy || defaultResolvePolicy;\n\t\t    return interface_1.ResolvePolicy[policyName];\n\t\t}\n\t\n\t\n\t/***/ },\n\t/* 42 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module resolve */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar ResolveInjector = (function () {\n\t\t    function ResolveInjector(_resolveContext, _state) {\n\t\t        this._resolveContext = _resolveContext;\n\t\t        this._state = _state;\n\t\t    }\n\t\t    /** Returns a promise to invoke an annotated function in the resolve context */\n\t\t    ResolveInjector.prototype.invokeLater = function (injectedFn, locals) {\n\t\t        return this._resolveContext.invokeLater(injectedFn, locals);\n\t\t    };\n\t\t    /** Invokes an annotated function in the resolve context */\n\t\t    ResolveInjector.prototype.invokeNow = function (injectedFn, locals) {\n\t\t        return this._resolveContext.invokeNow(null, injectedFn, locals);\n\t\t    };\n\t\t    /** Returns the a promise for locals (realized Resolvables) that a function wants */\n\t\t    ResolveInjector.prototype.getLocals = function (injectedFn) {\n\t\t        var _this = this;\n\t\t        var resolve = function (r) { return r.get(_this._resolveContext); };\n\t\t        return common_1.map(this._resolveContext.getResolvablesForFn(injectedFn), resolve);\n\t\t    };\n\t\t    return ResolveInjector;\n\t\t}());\n\t\texports.ResolveInjector = ResolveInjector;\n\t\n\t\n\t/***/ },\n\t/* 43 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar transition_1 = __webpack_require__(11);\n\t\tvar hookRegistry_1 = __webpack_require__(15);\n\t\t/**\n\t\t * The default transition options.\n\t\t * Include this object when applying custom defaults:\n\t\t * let reloadOpts = { reload: true, notify: true }\n\t\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t\t */\n\t\texports.defaultTransOpts = {\n\t\t    location: true,\n\t\t    relative: null,\n\t\t    inherit: false,\n\t\t    notify: true,\n\t\t    reload: false,\n\t\t    custom: {},\n\t\t    current: function () { return null; }\n\t\t};\n\t\t/**\n\t\t * This class provides services related to Transitions.\n\t\t *\n\t\t * Most importantly, it allows global Transition Hooks to be registered, and has a factory function\n\t\t * for creating new Transitions.\n\t\t */\n\t\tvar TransitionService = (function () {\n\t\t    function TransitionService($view) {\n\t\t        this.$view = $view;\n\t\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t\t            if ($error$ instanceof Error) {\n\t\t                console.error($error$);\n\t\t            }\n\t\t        };\n\t\t        hookRegistry_1.HookRegistry.mixin(new hookRegistry_1.HookRegistry(), this);\n\t\t    }\n\t\t    TransitionService.prototype.defaultErrorHandler = function (handler) {\n\t\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t\t    };\n\t\t    /**\n\t\t     * Creates a new [[Transition]] object\n\t\t     *\n\t\t     * This is a factory function for creating new Transition objects.\n\t\t     *\n\t\t     * @param fromPath\n\t\t     * @param targetState\n\t\t     * @returns {Transition}\n\t\t     */\n\t\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t\t        return new transition_1.Transition(fromPath, targetState, this);\n\t\t    };\n\t\t    return TransitionService;\n\t\t}());\n\t\texports.TransitionService = TransitionService;\n\t\n\t\n\t/***/ },\n\t/* 44 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module path */ /** for typedoc */\n\t\t__export(__webpack_require__(39));\n\t\t__export(__webpack_require__(38));\n\t\n\t\n\t/***/ },\n\t/* 45 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module url */ /** for typedoc */\n\t\t__export(__webpack_require__(46));\n\t\t__export(__webpack_require__(22));\n\t\t__export(__webpack_require__(47));\n\t\t__export(__webpack_require__(48));\n\t\n\t\n\t/***/ },\n\t/* 46 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module url */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(20);\n\t\tvar predicates_2 = __webpack_require__(4);\n\t\tvar param_1 = __webpack_require__(21);\n\t\tvar common_2 = __webpack_require__(3);\n\t\tvar common_3 = __webpack_require__(3);\n\t\tfunction quoteRegExp(string, param) {\n\t\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t\t    if (!param)\n\t\t        return result;\n\t\t    switch (param.squash) {\n\t\t        case false:\n\t\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t\t            break;\n\t\t        case true:\n\t\t            result = result.replace(/\\/$/, '');\n\t\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t\t            break;\n\t\t        default:\n\t\t            surroundPattern = [(\"(\" + param.squash + \"|\"), ')?'];\n\t\t            break;\n\t\t    }\n\t\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t\t}\n\t\tvar memoizeTo = function (obj, prop, fn) { return obj[prop] = obj[prop] || fn(); };\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.util.type:UrlMatcher\n\t\t *\n\t\t * @description\n\t\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t\t *\n\t\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t\t *\n\t\t * * `':'` name - colon placeholder\n\t\t * * `'*'` name - catch-all placeholder\n\t\t * * `'{' name '}'` - curly placeholder\n\t\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t\t *\n\t\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t\t * must be unique within the pattern (across both path and search parameters). For colon\n\t\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t\t * any number of characters.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t\t *   parameter consists of 1 to 8 hex digits.\n\t\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t\t *   path into the parameter 'path'.\n\t\t * * `'/files/*path'` - ditto.\n\t\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t\t *\n\t\t * @param {string} pattern  The pattern to compile into a matcher.\n\t\t * @param {Object} config  A configuration object hash\n\t\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t\t *\n\t\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t\t *   non-null) will start with this prefix.\n\t\t *\n\t\t * @property {string} pattern  The pattern that was passed into the constructor\n\t\t *\n\t\t * @returns {Object}  New `UrlMatcher` object\n\t\t */\n\t\tvar UrlMatcher = (function () {\n\t\t    function UrlMatcher(pattern, config) {\n\t\t        var _this = this;\n\t\t        this.pattern = pattern;\n\t\t        this.config = config;\n\t\t        this._cache = { path: [], pattern: null };\n\t\t        this._children = [];\n\t\t        this._params = [];\n\t\t        this._segments = [];\n\t\t        this._compiled = [];\n\t\t        this.config = common_1.defaults(this.config, {\n\t\t            params: {},\n\t\t            strict: true,\n\t\t            caseInsensitive: false,\n\t\t            paramMap: common_1.identity\n\t\t        });\n\t\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t\t        //   '*' name\n\t\t        //   ':' name\n\t\t        //   '{' name '}'\n\t\t        //   '{' name ':' regexp '}'\n\t\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t\t        //    \\\\.                            - a backslash escape\n\t\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t\t        var checkParamErrors = function (id) {\n\t\t            if (!UrlMatcher.nameValidator.test(id))\n\t\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t\t        };\n\t\t        // Split into static segments separated by path parameter placeholders.\n\t\t        // The number of segments is always 1 more than the number of parameters.\n\t\t        var matchDetails = function (m, isSearch) {\n\t\t            // IE[78] returns '' for unmatched groups instead of null\n\t\t            var id = m[2] || m[3], regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t\t            return {\n\t\t                id: id,\n\t\t                regexp: regexp,\n\t\t                cfg: _this.config.params[id],\n\t\t                segment: pattern.substring(last, m.index),\n\t\t                type: !regexp ? null : module_1.paramTypes.type(regexp || \"string\") || common_1.inherit(module_1.paramTypes.type(\"string\"), {\n\t\t                    pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t\t                })\n\t\t            };\n\t\t        };\n\t\t        var p, segment;\n\t\t        while ((m = placeholder.exec(pattern))) {\n\t\t            p = matchDetails(m, false);\n\t\t            if (p.segment.indexOf('?') >= 0)\n\t\t                break; // we're into the search part\n\t\t            checkParamErrors(p.id);\n\t\t            this._params.push(module_1.Param.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t\t            this._segments.push(p.segment);\n\t\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t\t            last = placeholder.lastIndex;\n\t\t        }\n\t\t        segment = pattern.substring(last);\n\t\t        // Find any search parameter names and remove them from the last segment\n\t\t        var i = segment.indexOf('?');\n\t\t        if (i >= 0) {\n\t\t            var search = segment.substring(i);\n\t\t            segment = segment.substring(0, i);\n\t\t            if (search.length > 0) {\n\t\t                last = 0;\n\t\t                while ((m = searchPlaceholder.exec(search))) {\n\t\t                    p = matchDetails(m, true);\n\t\t                    checkParamErrors(p.id);\n\t\t                    this._params.push(module_1.Param.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t\t                    last = placeholder.lastIndex;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        this._segments.push(segment);\n\t\t        common_1.extend(this, {\n\t\t            _compiled: patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment)),\n\t\t            prefix: this._segments[0]\n\t\t        });\n\t\t        Object.freeze(this);\n\t\t    }\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.util.type:UrlMatcher#append\n\t\t     * @methodOf ui.router.util.type:UrlMatcher\n\t\t     *\n\t\t     * @description\n\t\t     * @TODO\n\t\t     *\n\t\t     * @example\n\t\t     * @TODO\n\t\t     *\n\t\t     * @param {UrlMatcher} url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t\t     */\n\t\t    UrlMatcher.prototype.append = function (url) {\n\t\t        this._children.push(url);\n\t\t        common_1.forEach(url._cache, function (val, key) { return url._cache[key] = predicates_1.isArray(val) ? [] : null; });\n\t\t        url._cache.path = this._cache.path.concat(this);\n\t\t        return url;\n\t\t    };\n\t\t    UrlMatcher.prototype.isRoot = function () {\n\t\t        return this._cache.path.length === 0;\n\t\t    };\n\t\t    UrlMatcher.prototype.toString = function () {\n\t\t        return this.pattern;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.util.type:UrlMatcher#exec\n\t\t     * @methodOf ui.router.util.type:UrlMatcher\n\t\t     *\n\t\t     * @description\n\t\t     * Tests the specified path against this matcher, and returns an object containing the captured\n\t\t     * parameter values, or null if the path does not match. The returned object contains the values\n\t\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t\t     * they are not present in `search`. This means that search parameters are always treated\n\t\t     * as optional.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t\t     *   x: '1', q: 'hello'\n\t\t     * });\n\t\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t\t     * @param {Object} search  URL search parameters, e.g. `$location.search()`.\n\t\t     * @param {string} hash  URL hash e.g. `$location.hash()`.\n\t\t     * @param {Object} options\n\t\t     * @returns {Object}  The captured parameter values.\n\t\t     */\n\t\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t\t        var _this = this;\n\t\t        if (search === void 0) { search = {}; }\n\t\t        if (options === void 0) { options = {}; }\n\t\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t\t            return new RegExp([\n\t\t                '^',\n\t\t                common_1.unnest(_this._cache.path.concat(_this).map(hof_1.prop('_compiled'))).join(''),\n\t\t                _this.config.strict === false ? '\\/?' : '',\n\t\t                '$'\n\t\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t\t        }).exec(path);\n\t\t        if (!match)\n\t\t            return null;\n\t\t        //options = defaults(options, { isolate: false });\n\t\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.concat(this).map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t\t        if (nPathSegments !== match.length - 1)\n\t\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t\t        function decodePathArray(string) {\n\t\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t\t            var allReversed = common_1.map(split, reverseString);\n\t\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t\t        }\n\t\t        for (var i = 0; i < nPathSegments; i++) {\n\t\t            var param = pathParams[i];\n\t\t            var value = match[i + 1];\n\t\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t\t            for (var j = 0; j < param.replace.length; j++) {\n\t\t                if (param.replace[j].from === value)\n\t\t                    value = param.replace[j].to;\n\t\t            }\n\t\t            if (value && param.array === true)\n\t\t                value = decodePathArray(value);\n\t\t            if (predicates_2.isDefined(value))\n\t\t                value = param.type.decode(value);\n\t\t            values[param.id] = param.value(value);\n\t\t        }\n\t\t        common_1.forEach(searchParams, function (param) {\n\t\t            var value = search[param.id];\n\t\t            for (var j = 0; j < param.replace.length; j++) {\n\t\t                if (param.replace[j].from === value)\n\t\t                    value = param.replace[j].to;\n\t\t            }\n\t\t            if (predicates_2.isDefined(value))\n\t\t                value = param.type.decode(value);\n\t\t            values[param.id] = param.value(value);\n\t\t        });\n\t\t        if (hash)\n\t\t            values[\"#\"] = hash;\n\t\t        return values;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.util.type:UrlMatcher#parameters\n\t\t     * @methodOf ui.router.util.type:UrlMatcher\n\t\t     *\n\t\t     * @description\n\t\t     * Returns the names of all path and search parameters of this pattern in order of appearance.\n\t\t     *\n\t\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t\t     *    pattern has no parameters, an empty array is returned.\n\t\t     */\n\t\t    UrlMatcher.prototype.parameters = function (opts) {\n\t\t        if (opts === void 0) { opts = {}; }\n\t\t        if (opts.inherit === false)\n\t\t            return this._params;\n\t\t        return common_1.unnest(this._cache.path.concat(this).map(hof_1.prop('_params')));\n\t\t    };\n\t\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t\t        if (opts === void 0) { opts = {}; }\n\t\t        var parent = common_1.tail(this._cache.path);\n\t\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t\t            (opts.inherit !== false && parent && parent.parameter(id)) ||\n\t\t            null);\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.util.type:UrlMatcher#validates\n\t\t     * @methodOf ui.router.util.type:UrlMatcher\n\t\t     *\n\t\t     * @description\n\t\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t\t     * types of this `UrlMatcher`.\n\t\t     *\n\t\t     * @param {Object} params The object hash of parameters to validate.\n\t\t     * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t\t     */\n\t\t    UrlMatcher.prototype.validates = function (params) {\n\t\t        var _this = this;\n\t\t        var validParamVal = function (param, val) { return !param || param.validates(val); };\n\t\t        return common_1.pairs(params || {}).map(function (_a) {\n\t\t            var key = _a[0], val = _a[1];\n\t\t            return validParamVal(_this.parameter(key), val);\n\t\t        }).reduce(common_1.allTrueR, true);\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.util.type:UrlMatcher#format\n\t\t     * @methodOf ui.router.util.type:UrlMatcher\n\t\t     *\n\t\t     * @description\n\t\t     * Creates a URL that matches this pattern by substituting the specified values\n\t\t     * for the path and search parameters. Null values for path parameters are\n\t\t     * treated as empty strings.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t\t     * // returns '/user/bob?q=yes'\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t\t     * @returns {string}  the formatted URL (path and optionally search part).\n\t\t     */\n\t\t    UrlMatcher.prototype.format = function (values) {\n\t\t        if (values === void 0) { values = {}; }\n\t\t        if (!this.validates(values))\n\t\t            return null;\n\t\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t\t        var urlMatchers = this._cache.path.slice().concat(this);\n\t\t        // Extract all the static segments and Params into an ordered array\n\t\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_2.unnestR, []);\n\t\t        // Extract the query params into a separate array\n\t\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_2.unnestR, []);\n\t\t        /**\n\t\t         * Given a Param,\n\t\t         * Applies the parameter value, then returns details about it\n\t\t         */\n\t\t        function getDetails(param) {\n\t\t            // Normalize to typed value\n\t\t            var value = param.value(values[param.id]);\n\t\t            var isDefaultValue = param.isDefaultValue(value);\n\t\t            // Check if we're in squash mode for the parameter\n\t\t            var squash = isDefaultValue ? param.squash : false;\n\t\t            // Allow the Parameter's Type to encode the value\n\t\t            var encoded = param.type.encode(value);\n\t\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t\t        }\n\t\t        // Build up the path-portion from the list of static segments and parameters\n\t\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t\t            // The element is a static segment (a raw string); just append it\n\t\t            if (predicates_1.isString(x))\n\t\t                return acc + x;\n\t\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t\t            // If squash is === true, try to remove a slash from the path\n\t\t            if (squash === true)\n\t\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t\t            // If squash is a string, use the string for the param value\n\t\t            if (predicates_1.isString(squash))\n\t\t                return acc + squash;\n\t\t            if (squash !== false)\n\t\t                return acc; // ?\n\t\t            if (encoded == null)\n\t\t                return acc;\n\t\t            // If this parameter value is an array, encode the value using encodeDashes\n\t\t            if (predicates_1.isArray(encoded))\n\t\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t\t            if (param.type.raw)\n\t\t                return acc + encoded;\n\t\t            // Encode the value\n\t\t            return acc + encodeURIComponent(encoded);\n\t\t        }, \"\");\n\t\t        // Build the query string by applying parameter values (array or regular)\n\t\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t\t        var queryString = queryParams.map(function (param) {\n\t\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t\t                return;\n\t\t            if (!predicates_1.isArray(encoded))\n\t\t                encoded = [encoded];\n\t\t            if (encoded.length === 0)\n\t\t                return;\n\t\t            if (!param.type.raw)\n\t\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t\t            return encoded.map(function (val) { return (param.id + \"=\" + val); });\n\t\t        }).filter(common_1.identity).reduce(common_2.unnestR, []).join(\"&\");\n\t\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t\t    };\n\t\t    UrlMatcher.encodeDashes = function (str) {\n\t\t        return encodeURIComponent(str).replace(/-/g, function (c) { return (\"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase()); });\n\t\t    };\n\t\t    /** Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t\t        var staticSegments = matcher._segments;\n\t\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t\t        return common_3.arrayTuples(staticSegments, pathParams.concat(undefined)).reduce(common_2.unnestR, []).filter(function (x) { return x !== \"\" && predicates_2.isDefined(x); });\n\t\t    };\n\t\t    /** Given a matcher, return an array with the matcher's query params */\n\t\t    UrlMatcher.queryParams = function (matcher) {\n\t\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t\t    };\n\t\t    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\t\t    return UrlMatcher;\n\t\t}());\n\t\texports.UrlMatcher = UrlMatcher;\n\t\n\t\n\t/***/ },\n\t/* 47 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module url */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(45);\n\t\tvar module_2 = __webpack_require__(20);\n\t\tfunction getDefaultConfig() {\n\t\t    return {\n\t\t        strict: module_1.matcherConfig.strictMode(),\n\t\t        caseInsensitive: module_1.matcherConfig.caseInsensitive()\n\t\t    };\n\t\t}\n\t\t/**\n\t\t * Factory for [[UrlMatcher]] instances.\n\t\t *\n\t\t * The factory is available to ng1 services as\n\t\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t\t */\n\t\tvar UrlMatcherFactory = (function () {\n\t\t    function UrlMatcherFactory() {\n\t\t        common_1.extend(this, { UrlMatcher: module_1.UrlMatcher, Param: module_2.Param });\n\t\t    }\n\t\t    /**\n\t\t     * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t\t     *\n\t\t     * @param value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t\t     * @returns the current value of caseInsensitive\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t\t        return module_1.matcherConfig.caseInsensitive(value);\n\t\t    };\n\t\t    /**\n\t\t     * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t\t     *\n\t\t     * @param value `false` to match trailing slashes in URLs, otherwise `true`.\n\t\t     * @returns the current value of strictMode\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t\t        return module_1.matcherConfig.strictMode(value);\n\t\t    };\n\t\t    /**\n\t\t     * Sets the default behavior when generating or matching URLs with default parameter values.\n\t\t     *\n\t\t     * @param value A string that defines the default parameter URL squashing behavior.\n\t\t     *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t\t     *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t\t     *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t\t     *    - any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t\t     *             the parameter value from the URL and replace it with this string.\n\t\t     * @returns the current value of defaultSquashPolicy\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t\t        return module_1.matcherConfig.defaultSquashPolicy(value);\n\t\t    };\n\t\t    /**\n\t\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t\t     *\n\t\t     * @param pattern  The URL pattern.\n\t\t     * @param config  The config object hash.\n\t\t     * @returns The UrlMatcher.\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t\t        return new module_1.UrlMatcher(pattern, common_1.extend(getDefaultConfig(), config));\n\t\t    };\n\t\t    /**\n\t\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t\t     *\n\t\t     * @param object  The object to perform the type check against.\n\t\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t\t     *          implementing all the same methods.\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t\t        // TODO: typeof?\n\t\t        if (!predicates_1.isObject(object))\n\t\t            return false;\n\t\t        var result = true;\n\t\t        common_1.forEach(module_1.UrlMatcher.prototype, function (val, name) {\n\t\t            if (predicates_1.isFunction(val))\n\t\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t\t        });\n\t\t        return result;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Registers a custom [[Type]] object that can be used to generate URLs with typed parameters.\n\t\t     *\n\t\t     * @param name  The type name.\n\t\t     * @param definition The type definition. See [[Type]] for information on the values accepted.\n\t\t     * @param definitionFn A function that is injected before the app\n\t\t     *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t\t     *        See [[Type]] for information on the values accepted.\n\t\t     *\n\t\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t\t     *   - if only the `name` parameter was specified: the currently registered [[Type]] object, or undefined\n\t\t     *\n\t\t     * ---\n\t\t     *\n\t\t     * This is a simple example of a custom type that encodes and decodes items from an\n\t\t     * array, using the array index as the URL-encoded value:\n\t\t     *\n\t\t     * @example\n\t\t     * ```\n\t\t     *\n\t\t     * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t\t     *\n\t\t     * $urlMatcherFactoryProvider.type('listItem', {\n\t\t     *   encode: function(item) {\n\t\t     *     // Represent the list item in the URL using its corresponding index\n\t\t     *     return list.indexOf(item);\n\t\t     *   },\n\t\t     *   decode: function(item) {\n\t\t     *     // Look up the list item by index\n\t\t     *     return list[parseInt(item, 10)];\n\t\t     *   },\n\t\t     *   is: function(item) {\n\t\t     *     // Ensure the item is valid by checking to see that it appears\n\t\t     *     // in the list\n\t\t     *     return list.indexOf(item) > -1;\n\t\t     *   }\n\t\t     * });\n\t\t     *\n\t\t     * $stateProvider.state('list', {\n\t\t     *   url: \"/list/{item:listItem}\",\n\t\t     *   controller: function($scope, $stateParams) {\n\t\t     *     console.log($stateParams.item);\n\t\t     *   }\n\t\t     * });\n\t\t     *\n\t\t     * // ...\n\t\t     *\n\t\t     * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t\t     * $state.go('list', { item: \"Ringo\" });\n\t\t     * ```\n\t\t     */\n\t\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t\t        var type = module_2.paramTypes.type(name, definition, definitionFn);\n\t\t        return !predicates_1.isDefined(definition) ? type : this;\n\t\t    };\n\t\t    ;\n\t\t    /** @hidden */\n\t\t    UrlMatcherFactory.prototype.$get = function () {\n\t\t        module_2.paramTypes.enqueue = false;\n\t\t        module_2.paramTypes._flushTypeQueue();\n\t\t        return this;\n\t\t    };\n\t\t    ;\n\t\t    return UrlMatcherFactory;\n\t\t}());\n\t\texports.UrlMatcherFactory = UrlMatcherFactory;\n\t\n\t\n\t/***/ },\n\t/* 48 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module url */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar $location = coreservices_1.services.location;\n\t\t// Returns a string that is a prefix of all strings matching the RegExp\n\t\tfunction regExpPrefix(re) {\n\t\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t\t}\n\t\t// Interpolates matched values into a String.replace()-style pattern\n\t\tfunction interpolate(pattern, match) {\n\t\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t\t        return match[what === '$' ? 0 : Number(what)];\n\t\t    });\n\t\t}\n\t\tfunction handleIfMatch($injector, $stateParams, handler, match) {\n\t\t    if (!match)\n\t\t        return false;\n\t\t    var result = $injector.invoke(handler, handler, { $match: match, $stateParams: $stateParams });\n\t\t    return predicates_1.isDefined(result) ? result : true;\n\t\t}\n\t\tfunction appendBasePath(url, isHtml5, absolute) {\n\t\t    var baseHref = coreservices_1.services.locationConfig.baseHref();\n\t\t    if (baseHref === '/')\n\t\t        return url;\n\t\t    if (isHtml5)\n\t\t        return baseHref.slice(0, -1) + url;\n\t\t    if (absolute)\n\t\t        return baseHref.slice(1) + url;\n\t\t    return url;\n\t\t}\n\t\t// TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t\tfunction update(rules, otherwiseFn, evt) {\n\t\t    if (evt && evt.defaultPrevented)\n\t\t        return;\n\t\t    function check(rule) {\n\t\t        var handled = rule(coreservices_1.services.$injector, $location);\n\t\t        if (!handled)\n\t\t            return false;\n\t\t        if (predicates_1.isString(handled)) {\n\t\t            $location.replace();\n\t\t            $location.url(handled);\n\t\t        }\n\t\t        return true;\n\t\t    }\n\t\t    var n = rules.length, i;\n\t\t    for (i = 0; i < n; i++) {\n\t\t        if (check(rules[i]))\n\t\t            return;\n\t\t    }\n\t\t    // always check otherwise last to allow dynamic updates to the set of rules\n\t\t    if (otherwiseFn)\n\t\t        check(otherwiseFn);\n\t\t}\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.router.$urlRouterProvider\n\t\t *\n\t\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t\t * @requires $locationProvider\n\t\t *\n\t\t * @description\n\t\t * `$urlRouterProvider` has the responsibility of watching `$location`.\n\t\t * When `$location` changes it runs through a list of rules one by one until a\n\t\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify\n\t\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t\t *\n\t\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t\t * in your module config.\n\t\t */\n\t\tvar UrlRouterProvider = (function () {\n\t\t    function UrlRouterProvider($urlMatcherFactory, $stateParams) {\n\t\t        this.$urlMatcherFactory = $urlMatcherFactory;\n\t\t        this.$stateParams = $stateParams;\n\t\t        /** @hidden */\n\t\t        this.rules = [];\n\t\t        /** @hidden */\n\t\t        this.otherwiseFn = null;\n\t\t        /** @hidden */\n\t\t        this.interceptDeferred = false;\n\t\t    }\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.router.$urlRouterProvider#rule\n\t\t     * @methodOf ui.router.router.$urlRouterProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t\t     * specific URLs.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * var app = angular.module('app', ['ui.router.router']);\n\t\t     *\n\t\t     * app.config(function ($urlRouterProvider) {\n\t\t     *   // Here's an example of how you might allow case insensitive urls\n\t\t     *   $urlRouterProvider.rule(function ($injector, $location) {\n\t\t     *     var path = $location.path(),\n\t\t     *         normalized = path.toLowerCase();\n\t\t     *\n\t\t     *     if (path !== normalized) {\n\t\t     *       return normalized;\n\t\t     *     }\n\t\t     *   });\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {function} rule Handler function that takes `$injector` and `$location`\n\t\t     * services as arguments. You can use them to return a valid path as a string.\n\t\t     *\n\t\t     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t\t     */\n\t\t    UrlRouterProvider.prototype.rule = function (rule) {\n\t\t        if (!predicates_1.isFunction(rule))\n\t\t            throw new Error(\"'rule' must be a function\");\n\t\t        this.rules.push(rule);\n\t\t        return this;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc object\n\t\t     * @name ui.router.router.$urlRouterProvider#otherwise\n\t\t     * @methodOf ui.router.router.$urlRouterProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Defines a path that is used when an invalid route is requested.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * var app = angular.module('app', ['ui.router.router']);\n\t\t     *\n\t\t     * app.config(function ($urlRouterProvider) {\n\t\t     *   // if the path doesn't match any of the urls you configured\n\t\t     *   // otherwise will take care of routing the user to the\n\t\t     *   // specified url\n\t\t     *   $urlRouterProvider.otherwise('/index');\n\t\t     *\n\t\t     *   // Example of using function rule as param\n\t\t     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t\t     *     return '/a/valid/url';\n\t\t     *   });\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string|function} rule The url path you want to redirect to or a function\n\t\t     * rule that returns the url path. The function version is passed two params:\n\t\t     * `$injector` and `$location` services, and must return a url string.\n\t\t     *\n\t\t     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t\t     */\n\t\t    UrlRouterProvider.prototype.otherwise = function (rule) {\n\t\t        if (!predicates_1.isFunction(rule) && !predicates_1.isString(rule))\n\t\t            throw new Error(\"'rule' must be a string or function\");\n\t\t        this.otherwiseFn = predicates_1.isString(rule) ? function () { return rule; } : rule;\n\t\t        return this;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.router.$urlRouterProvider#when\n\t\t     * @methodOf ui.router.router.$urlRouterProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Registers a handler for a given url matching.\n\t\t     *\n\t\t     * If the handler is a string, it is\n\t\t     * treated as a redirect, and is interpolated according to the syntax of match\n\t\t     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t\t     *\n\t\t     * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t\t     * matches. You have the option of inject the match object as `$match`.\n\t\t     *\n\t\t     * The handler can return\n\t\t     *\n\t\t     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t\t     *   will continue trying to find another one that matches.\n\t\t     * - **string** which is treated as a redirect and passed to `$location.url()`\n\t\t     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * var app = angular.module('app', ['ui.router.router']);\n\t\t     *\n\t\t     * app.config(function ($urlRouterProvider) {\n\t\t     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t\t     *     if ($state.$current.navigable !== state ||\n\t\t     *         !equalForKeys($match, $stateParams) {\n\t\t     *      $state.transitionTo(state, $match, false);\n\t\t     *     }\n\t\t     *   });\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {string|object} what The incoming path that you want to redirect.\n\t\t     * @param {string|function} handler The path you want to redirect your user to.\n\t\t     */\n\t\t    UrlRouterProvider.prototype.when = function (what, handler) {\n\t\t        var _a = this, $urlMatcherFactory = _a.$urlMatcherFactory, $stateParams = _a.$stateParams;\n\t\t        var redirect, handlerIsString = predicates_1.isString(handler);\n\t\t        // @todo Queue this\n\t\t        if (predicates_1.isString(what))\n\t\t            what = $urlMatcherFactory.compile(what);\n\t\t        if (!handlerIsString && !predicates_1.isFunction(handler) && !predicates_1.isArray(handler))\n\t\t            throw new Error(\"invalid 'handler' in when()\");\n\t\t        var strategies = {\n\t\t            matcher: function (_what, _handler) {\n\t\t                if (handlerIsString) {\n\t\t                    redirect = $urlMatcherFactory.compile(_handler);\n\t\t                    _handler = ['$match', redirect.format.bind(redirect)];\n\t\t                }\n\t\t                return common_1.extend(function () {\n\t\t                    return handleIfMatch(coreservices_1.services.$injector, $stateParams, _handler, _what.exec($location.path(), $location.search(), $location.hash()));\n\t\t                }, {\n\t\t                    prefix: predicates_1.isString(_what.prefix) ? _what.prefix : ''\n\t\t                });\n\t\t            },\n\t\t            regex: function (_what, _handler) {\n\t\t                if (_what.global || _what.sticky)\n\t\t                    throw new Error(\"when() RegExp must not be global or sticky\");\n\t\t                if (handlerIsString) {\n\t\t                    redirect = _handler;\n\t\t                    _handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t\t                }\n\t\t                return common_1.extend(function () {\n\t\t                    return handleIfMatch(coreservices_1.services.$injector, $stateParams, _handler, _what.exec($location.path()));\n\t\t                }, {\n\t\t                    prefix: regExpPrefix(_what)\n\t\t                });\n\t\t            }\n\t\t        };\n\t\t        var check = {\n\t\t            matcher: $urlMatcherFactory.isMatcher(what),\n\t\t            regex: what instanceof RegExp\n\t\t        };\n\t\t        for (var n in check) {\n\t\t            if (check[n])\n\t\t                return this.rule(strategies[n](what, handler));\n\t\t        }\n\t\t        throw new Error(\"invalid 'what' in when()\");\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t\t     * @methodOf ui.router.router.$urlRouterProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Disables (or enables) deferring location change interception.\n\t\t     *\n\t\t     * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t\t     * defer a transition but maintain the current URL), call this method at configuration time.\n\t\t     * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t\t     * `$locationChangeSuccess` event handler.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * var app = angular.module('app', ['ui.router.router']);\n\t\t     *\n\t\t     * app.config(function ($urlRouterProvider) {\n\t\t     *\n\t\t     *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t\t     *   // this allows you to configure custom behavior in between\n\t\t     *   // location changes and route synchronization:\n\t\t     *   $urlRouterProvider.deferIntercept();\n\t\t     *\n\t\t     * }).run(function ($rootScope, $urlRouter, UserService) {\n\t\t     *\n\t\t     *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t\t     *     // UserService is an example service for managing user state\n\t\t     *     if (UserService.isLoggedIn()) return;\n\t\t     *\n\t\t     *     // Prevent $urlRouter's default handler from firing\n\t\t     *     e.preventDefault();\n\t\t     *\n\t\t     *     UserService.handleLogin().then(function() {\n\t\t     *       // Once the user has logged in, sync the current URL\n\t\t     *       // to the router:\n\t\t     *       $urlRouter.sync();\n\t\t     *     });\n\t\t     *   });\n\t\t     *\n\t\t     *   // Configures $urlRouter's listener *after* your custom listener\n\t\t     *   $urlRouter.listen();\n\t\t     * });\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t\t     *        no parameter is equivalent to `true`.\n\t\t     */\n\t\t    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n\t\t        if (defer === undefined)\n\t\t            defer = true;\n\t\t        this.interceptDeferred = defer;\n\t\t    };\n\t\t    ;\n\t\t    return UrlRouterProvider;\n\t\t}());\n\t\texports.UrlRouterProvider = UrlRouterProvider;\n\t\tvar UrlRouter = (function () {\n\t\t    function UrlRouter(urlRouterProvider) {\n\t\t        this.urlRouterProvider = urlRouterProvider;\n\t\t        common_1.bindFunctions(UrlRouter.prototype, this, this);\n\t\t    }\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.router.$urlRouter#sync\n\t\t     * @methodOf ui.router.router.$urlRouter\n\t\t     *\n\t\t     * @description\n\t\t     * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t\t     * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t\t     * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t\t     * with the transition by calling `$urlRouter.sync()`.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * angular.module('app', ['ui.router'])\n\t\t     *   .run(function($rootScope, $urlRouter) {\n\t\t     *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t\t     *       // Halt state change from even starting\n\t\t     *       evt.preventDefault();\n\t\t     *       // Perform custom logic\n\t\t     *       var meetsRequirement = ...\n\t\t     *       // Continue with the update and state transition if logic allows\n\t\t     *       if (meetsRequirement) $urlRouter.sync();\n\t\t     *     });\n\t\t     * });\n\t\t     * </pre>\n\t\t     */\n\t\t    UrlRouter.prototype.sync = function () {\n\t\t        update(this.urlRouterProvider.rules, this.urlRouterProvider.otherwiseFn);\n\t\t    };\n\t\t    UrlRouter.prototype.listen = function () {\n\t\t        var _this = this;\n\t\t        return this.listener = this.listener || $location.onChange(function (evt) { return update(_this.urlRouterProvider.rules, _this.urlRouterProvider.otherwiseFn, evt); });\n\t\t    };\n\t\t    UrlRouter.prototype.update = function (read) {\n\t\t        if (read) {\n\t\t            this.location = $location.url();\n\t\t            return;\n\t\t        }\n\t\t        if ($location.url() === this.location)\n\t\t            return;\n\t\t        $location.url(this.location);\n\t\t        $location.replace();\n\t\t    };\n\t\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t\t        $location.url(urlMatcher.format(params || {}));\n\t\t        if (options && options.replace)\n\t\t            $location.replace();\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.router.$urlRouter#href\n\t\t     * @methodOf ui.router.router.$urlRouter\n\t\t     *\n\t\t     * @description\n\t\t     * A URL generation method that returns the compiled URL for a given\n\t\t     * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t\t     *\n\t\t     * @example\n\t\t     * <pre>\n\t\t     * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t\t     *   person: \"bob\"\n\t\t     * });\n\t\t     * // $bob == \"/about/bob\";\n\t\t     * </pre>\n\t\t     *\n\t\t     * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t\t     * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t\t     * @param {object=} options Options object. The options are:\n\t\t     *\n\t\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t\t     *\n\t\t     * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t\t     */\n\t\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t\t        if (!urlMatcher.validates(params))\n\t\t            return null;\n\t\t        var url = urlMatcher.format(params);\n\t\t        options = options || {};\n\t\t        var cfg = coreservices_1.services.locationConfig;\n\t\t        var isHtml5 = cfg.html5Mode();\n\t\t        if (!isHtml5 && url !== null) {\n\t\t            url = \"#\" + cfg.hashPrefix() + url;\n\t\t        }\n\t\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\t        if (!options.absolute || !url) {\n\t\t            return url;\n\t\t        }\n\t\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t\t    };\n\t\t    return UrlRouter;\n\t\t}());\n\t\texports.UrlRouter = UrlRouter;\n\t\n\t\n\t/***/ },\n\t/* 49 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tfunction __export(m) {\n\t\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t\t}\n\t\t/** @module view */ /** for typedoc */\n\t\t__export(__webpack_require__(50));\n\t\n\t\n\t/***/ },\n\t/* 50 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module view */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(2);\n\t\tvar match = function (obj1) {\n\t\t    var keys = [];\n\t\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t\t        keys[_i - 1] = arguments[_i];\n\t\t    }\n\t\t    return function (obj2) { return keys.reduce(function (memo, key) { return memo && obj1[key] === obj2[key]; }, true); };\n\t\t};\n\t\t/**\n\t\t * The View service\n\t\t */\n\t\tvar ViewService = (function () {\n\t\t    function ViewService() {\n\t\t        var _this = this;\n\t\t        this.uiViews = [];\n\t\t        this.viewConfigs = [];\n\t\t        this._viewConfigFactories = {};\n\t\t        this.sync = function () {\n\t\t            var uiViewsByFqn = _this.uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t\t            /**\n\t\t             * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t\t             *\n\t\t             * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t\t             * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t\t             *\n\t\t             * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t\t             * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t\t             *\n\t\t             * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t\t             *\n\t\t             * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t\t             * - the ui-view's name matches the ViewConfig's target name\n\t\t             * - the ui-view's context matches the ViewConfig's anchor\n\t\t             *\n\t\t             * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t\t             * - There exists a parent ui-view where:\n\t\t             *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t\t             *    - the parent ui-view's context matches the ViewConfig's anchor\n\t\t             * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t\t             *\n\t\t             * Example:\n\t\t             *\n\t\t             * DOM:\n\t\t             * <div ui-view>                        <!-- created in the root context (name: \"\") -->\n\t\t             *   <div ui-view=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t\t             *     <div ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t\t             *       <div ui-view=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t\t             *       </div>\n\t\t             *     </div>\n\t\t             *   </div>\n\t\t             * </div>\n\t\t             *\n\t\t             * uiViews: [\n\t\t             *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t\t             *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t\t             *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t\t             *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t\t             * ]\n\t\t             *\n\t\t             * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t\t             *\n\t\t             * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t\t             * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t\t             * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t\t             * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t\t             *\n\t\t             * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t\t             * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t\t             * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t\t             *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t\t             *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t\t             * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t\t             *   the tail of the ui-view's fqn \"default.bar\"\n\t\t             */\n\t\t            var matches = function (uiView) { return function (viewConfig) {\n\t\t                // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t\t                if (uiView.$type !== viewConfig.viewDecl.$type)\n\t\t                    return false;\n\t\t                // Split names apart from both viewConfig and uiView into segments\n\t\t                var vc = viewConfig.viewDecl;\n\t\t                var vcSegments = vc.$uiViewName.split(\".\");\n\t\t                var uivSegments = uiView.fqn.split(\".\");\n\t\t                // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t\t                // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t\t                if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t\t                    return false;\n\t\t                // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t\t                // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t\t                var negOffset = (1 - vcSegments.length) || undefined;\n\t\t                var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t\t                var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t\t                return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t\t            }; };\n\t\t            // Return the number of dots in the fully qualified name\n\t\t            function uiViewDepth(uiView) {\n\t\t                return uiView.fqn.split(\".\").length;\n\t\t            }\n\t\t            // Return the ViewConfig's context's depth in the context tree.\n\t\t            function viewConfigDepth(config) {\n\t\t                var context = config.viewDecl.$context, count = 0;\n\t\t                while (++count && context.parent)\n\t\t                    context = context.parent;\n\t\t                return count;\n\t\t            }\n\t\t            // Given a depth function, returns a compare function which can return either ascending or descending order\n\t\t            var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t\t            var matchingConfigPair = function (uiView) {\n\t\t                var matchingConfigs = _this.viewConfigs.filter(matches(uiView));\n\t\t                if (matchingConfigs.length > 1)\n\t\t                    matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t\t                return [uiView, matchingConfigs[0]];\n\t\t            };\n\t\t            var configureUiView = function (_a) {\n\t\t                var uiView = _a[0], viewConfig = _a[1];\n\t\t                // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t\t                // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t\t                if (_this.uiViews.indexOf(uiView) !== -1)\n\t\t                    uiView.configUpdated(viewConfig);\n\t\t            };\n\t\t            _this.uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUiView);\n\t\t        };\n\t\t    }\n\t\t    ViewService.prototype.rootContext = function (context) {\n\t\t        return this._rootContext = context || this._rootContext;\n\t\t    };\n\t\t    ;\n\t\t    ViewService.prototype.viewConfigFactory = function (viewType, factory) {\n\t\t        this._viewConfigFactories[viewType] = factory;\n\t\t    };\n\t\t    ViewService.prototype.createViewConfig = function (node, decl) {\n\t\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t\t        if (!cfgFactory)\n\t\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t\t        var cfgs = cfgFactory(node, decl);\n\t\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t\t    };\n\t\t    /**\n\t\t     * De-registers a ViewConfig.\n\t\t     *\n\t\t     * @param viewConfig The ViewConfig view to deregister.\n\t\t     */\n\t\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t\t        module_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t\t        common_1.removeFrom(this.viewConfigs, viewConfig);\n\t\t    };\n\t\t    ;\n\t\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t\t        module_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t\t        this.viewConfigs.push(viewConfig);\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Allows a `ui-view` element to register its canonical name with a callback that allows it to\n\t\t     * be updated with a template, controller, and local variables.\n\t\t     *\n\t\t     * @param {String} name The fully-qualified name of the `ui-view` object being registered.\n\t\t     * @param {Function} configUpdatedCallback A callback that receives updates to the content & configuration\n\t\t     *                   of the view.\n\t\t     * @return {Function} Returns a de-registration function used when the view is destroyed.\n\t\t     */\n\t\t    ViewService.prototype.registerUiView = function (uiView) {\n\t\t        module_1.trace.traceViewServiceUiViewEvent(\"-> Registering\", uiView);\n\t\t        var uiViews = this.uiViews;\n\t\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t\t        if (uiViews.filter(fqnMatches).length)\n\t\t            module_1.trace.traceViewServiceUiViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t\t        uiViews.push(uiView);\n\t\t        this.sync();\n\t\t        return function () {\n\t\t            var idx = uiViews.indexOf(uiView);\n\t\t            if (idx <= 0) {\n\t\t                module_1.trace.traceViewServiceUiViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t\t                return;\n\t\t            }\n\t\t            module_1.trace.traceViewServiceUiViewEvent(\"<- Deregistering\", uiView);\n\t\t            common_1.removeFrom(uiViews)(uiView);\n\t\t        };\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t\t     *\n\t\t     * @return {Array} Returns an array of fully-qualified view names.\n\t\t     */\n\t\t    ViewService.prototype.available = function () {\n\t\t        return this.uiViews.map(hof_1.prop(\"fqn\"));\n\t\t    };\n\t\t    /**\n\t\t     * Returns the list of views on the page containing loaded content.\n\t\t     *\n\t\t     * @return {Array} Returns an array of fully-qualified view names.\n\t\t     */\n\t\t    ViewService.prototype.active = function () {\n\t\t        return this.uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t\t    };\n\t\t    /**\n\t\t     * Normalizes a view's name from a state.views configuration block.\n\t\t     *\n\t\t     * @param context the context object (state declaration) that the view belongs to\n\t\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t\t     *\n\t\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t\t     */\n\t\t    ViewService.normalizeUiViewTarget = function (context, rawViewName) {\n\t\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t\t        // TODO: Validate incoming view name with a regexp to allow:\n\t\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t\t        var viewAtContext = rawViewName.split(\"@\");\n\t\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t\t        // Handle relative view-name sugar syntax.\n\t\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t\t        if (relativeViewNameSugar) {\n\t\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t\t        }\n\t\t        if (uiViewName.charAt(0) === '!') {\n\t\t            uiViewName = uiViewName.substr(1);\n\t\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t\t        }\n\t\t        // handle parent relative targeting \"^.^.^\"\n\t\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t\t            uiViewContextAnchor = anchor.name;\n\t\t        }\n\t\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t\t    };\n\t\t    return ViewService;\n\t\t}());\n\t\texports.ViewService = ViewService;\n\t\n\t\n\t/***/ },\n\t/* 51 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module core */ /** */\n\t\tvar stateParams_1 = __webpack_require__(25);\n\t\tvar queue_1 = __webpack_require__(8);\n\t\tvar common_1 = __webpack_require__(3);\n\t\t/**\n\t\t * Global mutable state\n\t\t *\n\t\t * This is where we hold the global mutable state such as current state, current\n\t\t * params, current transition, last successful transition, last attempted transition, etc.\n\t\t */\n\t\tvar UIRouterGlobals = (function () {\n\t\t    function UIRouterGlobals(transitionService) {\n\t\t        var _this = this;\n\t\t        /**\n\t\t         * Current parameter values\n\t\t         *\n\t\t         * The parameter values from the latest successful transition\n\t\t         */\n\t\t        this.params = new stateParams_1.StateParams();\n\t\t        /**\n\t\t         * The transition history\n\t\t         *\n\t\t         * This queue's size is limited to a maximum number (default: 1)\n\t\t         */\n\t\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t\t        /**\n\t\t         * The history of successful transitions\n\t\t         *\n\t\t         * This queue's size is limited to a maximum number (default: 1)\n\t\t         */\n\t\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t\t        var beforeNewTransition = function ($transition$) {\n\t\t            _this.transition = $transition$;\n\t\t            _this.transitionHistory.enqueue($transition$);\n\t\t            var updateGlobalState = function () {\n\t\t                _this.successfulTransitions.enqueue($transition$);\n\t\t                _this.$current = $transition$.$to();\n\t\t                _this.current = _this.$current.self;\n\t\t                common_1.copy($transition$.params(), _this.params);\n\t\t            };\n\t\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t\t                _this.transition = null; };\n\t\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t\t        };\n\t\t        transitionService.onBefore({}, ['$transition$', beforeNewTransition]);\n\t\t    }\n\t\t    return UIRouterGlobals;\n\t\t}());\n\t\texports.UIRouterGlobals = UIRouterGlobals;\n\t\n\t\n\t/***/ },\n\t/* 52 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module core */ /** */\n\t\tvar urlMatcherFactory_1 = __webpack_require__(47);\n\t\tvar urlRouter_1 = __webpack_require__(48);\n\t\tvar state_1 = __webpack_require__(18);\n\t\tvar urlRouter_2 = __webpack_require__(48);\n\t\tvar transitionService_1 = __webpack_require__(43);\n\t\tvar view_1 = __webpack_require__(50);\n\t\tvar stateRegistry_1 = __webpack_require__(36);\n\t\tvar stateService_1 = __webpack_require__(37);\n\t\tvar globals_1 = __webpack_require__(51);\n\t\t/**\n\t\t * The master class used to instantiate an instance of UI-Router.\n\t\t *\n\t\t * This class instantiates and wires the global UI-Router services.\n\t\t *\n\t\t * After instantiating a new instance of the Router class, configure it for your app.  For instance, register\n\t\t * your app states with the [[stateRegistry]] (and set url options using ...).  Then, tell UI-Router to monitor\n\t\t * the URL by calling `urlRouter.listen()` ([[URLRouter.listen]])\n\t\t */\n\t\tvar UIRouter = (function () {\n\t\t    function UIRouter() {\n\t\t        this.viewService = new view_1.ViewService();\n\t\t        this.transitionService = new transitionService_1.TransitionService(this.viewService);\n\t\t        this.globals = new globals_1.UIRouterGlobals(this.transitionService);\n\t\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t\t        this.urlRouterProvider = new urlRouter_1.UrlRouterProvider(this.urlMatcherFactory, this.globals.params);\n\t\t        this.urlRouter = new urlRouter_2.UrlRouter(this.urlRouterProvider);\n\t\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this.urlMatcherFactory, this.urlRouterProvider);\n\t\t        /** @hidden TODO: move this to ng1.ts */\n\t\t        this.stateProvider = new state_1.StateProvider(this.stateRegistry);\n\t\t        this.stateService = new stateService_1.StateService(this.viewService, this.urlRouter, this.transitionService, this.stateRegistry, this.stateProvider, this.globals);\n\t\t        this.viewService.rootContext(this.stateRegistry.root());\n\t\t        this.globals.$current = this.stateRegistry.root();\n\t\t        this.globals.current = this.globals.$current.self;\n\t\t    }\n\t\t    return UIRouter;\n\t\t}());\n\t\texports.UIRouter = UIRouter;\n\t\n\t\n\t/***/ },\n\t/* 53 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/**\n\t\t * # UI-Router for Angular 1\n\t\t *\n\t\t * - Provides an implementation for the [[CoreServices]] API, based on angular 1 services.\n\t\t * - Also registers some services with the angular 1 injector.\n\t\t * - Creates and bootstraps a new [[UIRouter]] object.  Ties it to the the angular 1 lifecycle.\n\t\t *\n\t\t * @module ng1\n\t\t * @preferred\n\t\t */\n\t\t\"use strict\";\n\t\t/** for typedoc */\n\t\tvar router_1 = __webpack_require__(52);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar module_1 = __webpack_require__(44);\n\t\tvar module_2 = __webpack_require__(40);\n\t\tvar module_3 = __webpack_require__(17);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar viewsBuilder_1 = __webpack_require__(54);\n\t\tvar templateFactory_1 = __webpack_require__(55);\n\t\tvar resolvesBuilder_1 = __webpack_require__(56);\n\t\t/** @hidden */\n\t\tvar app = angular.module(\"ui.router.angular1\", []);\n\t\t/**\n\t\t * @ngdoc overview\n\t\t * @name ui.router.util\n\t\t *\n\t\t * @description\n\t\t * # ui.router.util sub-module\n\t\t *\n\t\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t\t * in your angular app (use {@link ui.router} module instead).\n\t\t *\n\t\t */\n\t\tangular.module('ui.router.util', ['ng', 'ui.router.init']);\n\t\t/**\n\t\t * @ngdoc overview\n\t\t * @name ui.router.router\n\t\t *\n\t\t * @requires ui.router.util\n\t\t *\n\t\t * @description\n\t\t * # ui.router.router sub-module\n\t\t *\n\t\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t\t * in your angular app (use {@link ui.router} module instead).\n\t\t */\n\t\tangular.module('ui.router.router', ['ui.router.util']);\n\t\t/**\n\t\t * @ngdoc overview\n\t\t * @name ui.router.state\n\t\t *\n\t\t * @requires ui.router.router\n\t\t * @requires ui.router.util\n\t\t *\n\t\t * @description\n\t\t * # ui.router.state sub-module\n\t\t *\n\t\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t\t * in your angular app (use {@link ui.router} module instead).\n\t\t *\n\t\t */\n\t\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\n\t\t/**\n\t\t * @ngdoc overview\n\t\t * @name ui.router\n\t\t *\n\t\t * @requires ui.router.state\n\t\t *\n\t\t * @description\n\t\t * # ui.router\n\t\t *\n\t\t * ## The main module for ui.router\n\t\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t\t * as a dependency within your angular app. The other modules are for organization purposes.\n\t\t *\n\t\t * The modules are:\n\t\t * * ui.router - the main \"umbrella\" module\n\t\t * * ui.router.router -\n\t\t *\n\t\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t\t *\n\t\t * <pre>\n\t\t * <!doctype html>\n\t\t * <html ng-app=\"myApp\">\n\t\t * <head>\n\t\t *   <script src=\"js/angular.js\"></script>\n\t\t *   <!-- Include the ui-router script -->\n\t\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t\t *   <script>\n\t\t *     // ...and add 'ui.router' as a dependency\n\t\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t\t *   </script>\n\t\t * </head>\n\t\t * <body>\n\t\t * </body>\n\t\t * </html>\n\t\t * </pre>\n\t\t */\n\t\tangular.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\n\t\tangular.module('ui.router.compat', ['ui.router']);\n\t\t/**\n\t\t * Annotates a controller expression (may be a controller function(), a \"controllername\",\n\t\t * or \"controllername as name\")\n\t\t *\n\t\t * - Temporarily decorates $injector.instantiate.\n\t\t * - Invokes $controller() service\n\t\t *   - Calls $injector.instantiate with controller constructor\n\t\t * - Annotate constructor\n\t\t * - Undecorate $injector\n\t\t *\n\t\t * returns an array of strings, which are the arguments of the controller expression\n\t\t */\n\t\tfunction annotateController(controllerExpression) {\n\t\t    var $injector = coreservices_1.services.$injector;\n\t\t    var $controller = $injector.get(\"$controller\");\n\t\t    var oldInstantiate = $injector.instantiate;\n\t\t    try {\n\t\t        var deps_1;\n\t\t        $injector.instantiate = function fakeInstantiate(constructorFunction) {\n\t\t            $injector.instantiate = oldInstantiate; // Un-decorate ASAP\n\t\t            deps_1 = $injector.annotate(constructorFunction);\n\t\t        };\n\t\t        $controller(controllerExpression, { $scope: {} });\n\t\t        return deps_1;\n\t\t    }\n\t\t    finally {\n\t\t        $injector.instantiate = oldInstantiate;\n\t\t    }\n\t\t}\n\t\texports.annotateController = annotateController;\n\t\trunBlock.$inject = ['$injector', '$q'];\n\t\tfunction runBlock($injector, $q) {\n\t\t    coreservices_1.services.$injector = $injector;\n\t\t    coreservices_1.services.$q = $q;\n\t\t}\n\t\tapp.run(runBlock);\n\t\tvar router = null;\n\t\tng1UIRouter.$inject = ['$locationProvider'];\n\t\t/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\n\t\tfunction ng1UIRouter($locationProvider) {\n\t\t    // Create a new instance of the Router when the ng1UIRouterProvider is initialized\n\t\t    router = new router_1.UIRouter();\n\t\t    // Apply ng1 `views` builder to the StateBuilder\n\t\t    router.stateRegistry.decorator(\"views\", viewsBuilder_1.ng1ViewsBuilder);\n\t\t    router.stateRegistry.decorator(\"resolve\", resolvesBuilder_1.ng1ResolveBuilder);\n\t\t    router.viewService.viewConfigFactory('ng1', viewsBuilder_1.ng1ViewConfigFactory);\n\t\t    // Bind LocationConfig.hashPrefix to $locationProvider.hashPrefix\n\t\t    common_1.bindFunctions($locationProvider, coreservices_1.services.locationConfig, $locationProvider, ['hashPrefix']);\n\t\t    // Create a LocationService.onChange registry\n\t\t    var urlListeners = [];\n\t\t    coreservices_1.services.location.onChange = function (callback) {\n\t\t        urlListeners.push(callback);\n\t\t        return function () { return common_1.removeFrom(urlListeners)(callback); };\n\t\t    };\n\t\t    this.$get = $get;\n\t\t    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n\t\t    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n\t\t        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n\t\t        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return urlListeners.forEach(function (fn) { return fn(evt); }); });\n\t\t        // Bind LocationConfig.html5Mode to $locationProvider.html5Mode and $sniffer.history\n\t\t        coreservices_1.services.locationConfig.html5Mode = function () {\n\t\t            var html5Mode = $locationProvider.html5Mode();\n\t\t            html5Mode = predicates_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n\t\t            return html5Mode && $sniffer.history;\n\t\t        };\n\t\t        coreservices_1.services.template.get = function (url) {\n\t\t            return $http.get(url, { cache: $templateCache, headers: { Accept: 'text/html' } }).then(hof_1.prop(\"data\"));\n\t\t        };\n\t\t        // Bind these LocationService functions to $location\n\t\t        common_1.bindFunctions($location, coreservices_1.services.location, $location, [\"replace\", \"url\", \"path\", \"search\", \"hash\"]);\n\t\t        // Bind these LocationConfig functions to $location\n\t\t        common_1.bindFunctions($location, coreservices_1.services.locationConfig, $location, ['port', 'protocol', 'host']);\n\t\t        // Bind these LocationConfig functions to $browser\n\t\t        common_1.bindFunctions($browser, coreservices_1.services.locationConfig, $browser, ['baseHref']);\n\t\t        return router;\n\t\t    }\n\t\t}\n\t\tvar resolveFactory = function () { return ({\n\t\t    /**\n\t\t     * This emulates most of the behavior of the ui-router 0.2.x $resolve.resolve() service API.\n\t\t     * @param invocables an object, with keys as resolve names and values as injectable functions\n\t\t     * @param locals key/value pre-resolved data (locals)\n\t\t     * @param parent a promise for a \"parent resolve\"\n\t\t     */\n\t\t    resolve: function (invocables, locals, parent) {\n\t\t        if (locals === void 0) { locals = {}; }\n\t\t        var parentNode = new module_1.Node(new module_3.State({ params: {} }));\n\t\t        var node = new module_1.Node(new module_3.State({ params: {} }));\n\t\t        var context = new module_2.ResolveContext([parentNode, node]);\n\t\t        context.addResolvables(module_2.Resolvable.makeResolvables(invocables), node.state);\n\t\t        var resolveData = function (parentLocals) {\n\t\t            var rewrap = function (_locals) { return module_2.Resolvable.makeResolvables(common_1.map(_locals, function (local) { return function () { return local; }; })); };\n\t\t            context.addResolvables(rewrap(parentLocals), parentNode.state);\n\t\t            context.addResolvables(rewrap(locals), node.state);\n\t\t            return context.resolvePath();\n\t\t        };\n\t\t        return parent ? parent.then(resolveData) : resolveData({});\n\t\t    }\n\t\t}); };\n\t\tfunction $stateParamsFactory(ng1UIRouter) {\n\t\t    return ng1UIRouter.globals.params;\n\t\t}\n\t\t// The 'ui.router' ng1 module depends on 'ui.router.init' module.\n\t\tangular.module('ui.router.init', []).provider(\"ng1UIRouter\", ng1UIRouter);\n\t\t// This effectively calls $get() to init when we enter runtime\n\t\tangular.module('ui.router.init').run(['ng1UIRouter', function (ng1UIRouter) { }]);\n\t\t// $urlMatcherFactory service and $urlMatcherFactoryProvider\n\t\tangular.module('ui.router.util').provider('$urlMatcherFactory', ['ng1UIRouterProvider', function () { return router.urlMatcherFactory; }]);\n\t\tangular.module('ui.router.util').run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\n\t\t// $urlRouter service and $urlRouterProvider\n\t\tfunction getUrlRouterProvider() {\n\t\t    router.urlRouterProvider[\"$get\"] = function () {\n\t\t        router.urlRouter.update(true);\n\t\t        if (!this.interceptDeferred)\n\t\t            router.urlRouter.listen();\n\t\t        return router.urlRouter;\n\t\t    };\n\t\t    return router.urlRouterProvider;\n\t\t}\n\t\tangular.module('ui.router.router').provider('$urlRouter', ['ng1UIRouterProvider', getUrlRouterProvider]);\n\t\tangular.module('ui.router.router').run(['$urlRouter', function ($urlRouter) { }]);\n\t\t// $state service and $stateProvider\n\t\t// $urlRouter service and $urlRouterProvider\n\t\tfunction getStateProvider() {\n\t\t    router.stateProvider[\"$get\"] = function () {\n\t\t        // Autoflush once we are in runtime\n\t\t        router.stateRegistry.stateQueue.autoFlush(router.stateService);\n\t\t        return router.stateService;\n\t\t    };\n\t\t    return router.stateProvider;\n\t\t}\n\t\tangular.module('ui.router.state').provider('$state', ['ng1UIRouterProvider', getStateProvider]);\n\t\tangular.module('ui.router.state').run(['$state', function ($state) { }]);\n\t\t// $stateParams service\n\t\tangular.module('ui.router.state').factory('$stateParams', ['ng1UIRouter', function (ng1UIRouter) {\n\t\t        return ng1UIRouter.globals.params;\n\t\t    }]);\n\t\t// $transitions service and $transitionsProvider\n\t\tfunction getTransitionsProvider() {\n\t\t    loadAllControllerLocals.$inject = ['$transition$'];\n\t\t    function loadAllControllerLocals($transition$) {\n\t\t        var loadLocals = function (vc) {\n\t\t            var node = common_1.find($transition$.treeChanges().to, hof_1.propEq('state', vc.viewDecl.$context));\n\t\t            // Temporary fix; This whole callback should be nuked when fixing #2662\n\t\t            if (!node)\n\t\t                return coreservices_1.services.$q.when();\n\t\t            var resolveCtx = node.resolveContext;\n\t\t            var controllerDeps = annotateController(vc.controller);\n\t\t            var resolvables = resolveCtx.getResolvables();\n\t\t            function $loadControllerLocals() { }\n\t\t            $loadControllerLocals.$inject = controllerDeps.filter(function (dep) { return resolvables.hasOwnProperty(dep); });\n\t\t            // Load any controller resolves that aren't already loaded\n\t\t            return resolveCtx.invokeLater($loadControllerLocals)\n\t\t                .then(function () { return vc.locals = common_1.map(resolvables, function (res) { return res.data; }); });\n\t\t        };\n\t\t        var loadAllLocals = $transition$.views(\"entering\").filter(function (vc) { return !!vc.controller; }).map(loadLocals);\n\t\t        return coreservices_1.services.$q.all(loadAllLocals).then(common_1.noop);\n\t\t    }\n\t\t    router.transitionService.onFinish({}, loadAllControllerLocals);\n\t\t    router.transitionService[\"$get\"] = function () { return router.transitionService; };\n\t\t    return router.transitionService;\n\t\t}\n\t\tangular.module('ui.router.state').provider('$transitions', ['ng1UIRouterProvider', getTransitionsProvider]);\n\t\t// $templateFactory service\n\t\tangular.module('ui.router.util').factory('$templateFactory', ['ng1UIRouter', function () { return new templateFactory_1.TemplateFactory(); }]);\n\t\t// The $view service\n\t\tangular.module('ui.router').factory('$view', function () { return router.viewService; });\n\t\t// The old $resolve service\n\t\tangular.module('ui.router').factory('$resolve', resolveFactory);\n\t\t// $trace service\n\t\tangular.module(\"ui.router\").service(\"$trace\", function () { return trace_1.trace; });\n\t\twatchDigests.$inject = ['$rootScope'];\n\t\tfunction watchDigests($rootScope) {\n\t\t    $rootScope.$watch(function () { trace_1.trace.approximateDigests++; });\n\t\t}\n\t\texports.watchDigests = watchDigests;\n\t\tangular.module(\"ui.router\").run(watchDigests);\n\t\n\t\n\t/***/ },\n\t/* 54 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar strings_1 = __webpack_require__(9);\n\t\tvar view_1 = __webpack_require__(50);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar templateFactory_1 = __webpack_require__(55);\n\t\texports.ng1ViewConfigFactory = function (node, view) { return new Ng1ViewConfig(node, view); };\n\t\t/**\n\t\t * This is a [[StateBuilder.builder]] function for angular1 `views`.\n\t\t *\n\t\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t\t * handles the `views` property with logic specific to angular-ui-router (ng1).\n\t\t *\n\t\t * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n\t\t * and applies the state-level configuration to a view named `$default`.\n\t\t */\n\t\tfunction ng1ViewsBuilder(state) {\n\t\t    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings'], nonCompKeys = tplKeys.concat(ctrlKeys), allKeys = compKeys.concat(nonCompKeys);\n\t\t    var views = {}, viewsObject = state.views || { \"$default\": common_1.pick(state, allKeys) };\n\t\t    common_1.forEach(viewsObject, function (config, name) {\n\t\t        // Account for views: { \"\": { template... } }\n\t\t        name = name || \"$default\";\n\t\t        // Account for views: { header: \"headerComponent\" }\n\t\t        if (predicates_1.isString(config))\n\t\t            config = { component: config };\n\t\t        if (!Object.keys(config).length)\n\t\t            return;\n\t\t        // Configure this view for routing to an angular 1.5+ style .component (or any directive, really)\n\t\t        if (config.component) {\n\t\t            if (nonCompKeys.map(function (key) { return predicates_1.isDefined(config[key]); }).reduce(common_1.anyTrueR, false)) {\n\t\t                throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: 'name@\" + state.name + \"'\");\n\t\t            }\n\t\t            // Dynamically build a template like \"<component-name input1='::$resolve.foo'></component-name>\"\n\t\t            config.templateProvider = ['$injector', function ($injector) {\n\t\t                    var resolveFor = function (key) { return config.bindings && config.bindings[key] || key; };\n\t\t                    var prefix = angular.version.minor >= 3 ? \"::\" : \"\";\n\t\t                    var attributeTpl = function (input) {\n\t\t                        var attrName = strings_1.kebobString(input.name);\n\t\t                        var resolveName = resolveFor(input.name);\n\t\t                        if (input.type === '@')\n\t\t                            return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n\t\t                        return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n\t\t                    };\n\t\t                    var attrs = getComponentInputs($injector, config.component).map(attributeTpl).join(\" \");\n\t\t                    var kebobName = strings_1.kebobString(config.component);\n\t\t                    return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n\t\t                }];\n\t\t        }\n\t\t        config.resolveAs = config.resolveAs || '$resolve';\n\t\t        config.$type = \"ng1\";\n\t\t        config.$context = state;\n\t\t        config.$name = name;\n\t\t        var normalized = view_1.ViewService.normalizeUiViewTarget(config.$context, config.$name);\n\t\t        config.$uiViewName = normalized.uiViewName;\n\t\t        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t\t        views[name] = config;\n\t\t    });\n\t\t    return views;\n\t\t}\n\t\texports.ng1ViewsBuilder = ng1ViewsBuilder;\n\t\t// for ng 1.2 style, process the scope: { input: \"=foo\" }\n\t\t// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\n\t\tvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n\t\t    .map(function (key) { return [key, /^([=<@])[?]?(.*)/.exec(bindingsObj[key])]; }) // [ 'input', [ '=foo', '=', 'foo' ] ]\n\t\t    .filter(function (tuple) { return predicates_1.isDefined(tuple) && predicates_1.isDefined(tuple[1]); }) // skip malformed values\n\t\t    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); }; // { name: ('foo' || 'input'), type: '=' }\n\t\t// Given a directive definition, find its object input attributes\n\t\t// Use different properties, depending on the type of directive (component, bindToController, normal)\n\t\tvar getBindings = function (def) {\n\t\t    if (predicates_1.isObject(def.bindToController))\n\t\t        return scopeBindings(def.bindToController);\n\t\t    return scopeBindings(def.scope);\n\t\t};\n\t\t// Gets all the directive(s)' inputs ('@', '=', and '<')\n\t\tfunction getComponentInputs($injector, name) {\n\t\t    var cmpDefs = $injector.get(name + \"Directive\"); // could be multiple\n\t\t    if (!cmpDefs || !cmpDefs.length)\n\t\t        throw new Error(\"Unable to find component named '\" + name + \"'\");\n\t\t    return cmpDefs.map(getBindings).reduce(common_1.unnestR, []);\n\t\t}\n\t\tvar Ng1ViewConfig = (function () {\n\t\t    function Ng1ViewConfig(node, viewDecl) {\n\t\t        this.node = node;\n\t\t        this.viewDecl = viewDecl;\n\t\t        this.loaded = false;\n\t\t    }\n\t\t    Ng1ViewConfig.prototype.load = function () {\n\t\t        var _this = this;\n\t\t        var $q = coreservices_1.services.$q;\n\t\t        if (!this.hasTemplate())\n\t\t            throw new Error(\"No template configuration specified for '\" + this.viewDecl.$uiViewName + \"@\" + this.viewDecl.$uiViewContextAnchor + \"'\");\n\t\t        var injector = this.node.resolveContext;\n\t\t        var params = this.node.paramValues;\n\t\t        var promises = {\n\t\t            template: $q.when(this.getTemplate(params, new templateFactory_1.TemplateFactory(), injector)),\n\t\t            controller: $q.when(this.getController(injector))\n\t\t        };\n\t\t        return $q.all(promises).then(function (results) {\n\t\t            trace_1.trace.traceViewServiceEvent(\"Loaded\", _this);\n\t\t            _this.controller = results.controller;\n\t\t            _this.template = results.template;\n\t\t        });\n\t\t    };\n\t\t    /**\n\t\t     * Checks a view configuration to ensure that it specifies a template.\n\t\t     *\n\t\t     * @return {boolean} Returns `true` if the configuration contains a valid template, otherwise `false`.\n\t\t     */\n\t\t    Ng1ViewConfig.prototype.hasTemplate = function () {\n\t\t        return !!(this.viewDecl.template || this.viewDecl.templateUrl || this.viewDecl.templateProvider);\n\t\t    };\n\t\t    Ng1ViewConfig.prototype.getTemplate = function (params, $factory, injector) {\n\t\t        return $factory.fromConfig(this.viewDecl, params, injector.invokeLater.bind(injector));\n\t\t    };\n\t\t    /**\n\t\t     * Gets the controller for a view configuration.\n\t\t     *\n\t\t     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n\t\t     */\n\t\t    Ng1ViewConfig.prototype.getController = function (injector) {\n\t\t        //* @param {Object} locals A context object from transition.context() to invoke a function in the correct context\n\t\t        var provider = this.viewDecl.controllerProvider;\n\t\t        return predicates_1.isInjectable(provider) ? injector.invokeLater(provider, {}) : this.viewDecl.controller;\n\t\t    };\n\t\t    return Ng1ViewConfig;\n\t\t}());\n\t\texports.Ng1ViewConfig = Ng1ViewConfig;\n\t\n\t\n\t/***/ },\n\t/* 55 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/** @module view */ /** for typedoc */\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar coreservices_1 = __webpack_require__(6);\n\t\t/**\n\t\t * Service which manages loading of templates from a ViewConfig.\n\t\t */\n\t\tvar TemplateFactory = (function () {\n\t\t    function TemplateFactory() {\n\t\t    }\n\t\t    /**\n\t\t     * Creates a template from a configuration object.\n\t\t     *\n\t\t     * @param config Configuration object for which to load a template.\n\t\t     * The following properties are search in the specified order, and the first one\n\t\t     * that is defined is used to create the template:\n\t\t     *\n\t\t     * @param params  Parameters to pass to the template function.\n\t\t     * @param injectFn Function to which an injectable function may be passed.\n\t\t     *        If templateProvider is defined, this injectFn will be used to invoke it.\n\t\t     *\n\t\t     * @return {string|object}  The template html as a string, or a promise for\n\t\t     * that string,or `null` if no template is configured.\n\t\t     */\n\t\t    TemplateFactory.prototype.fromConfig = function (config, params, injectFn) {\n\t\t        return (predicates_1.isDefined(config.template) ? this.fromString(config.template, params) :\n\t\t            predicates_1.isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t\t                predicates_1.isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, injectFn) :\n\t\t                    null);\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Creates a template from a string or a function returning a string.\n\t\t     *\n\t\t     * @param template html template as a string or function that returns an html template as a string.\n\t\t     * @param params Parameters to pass to the template function.\n\t\t     *\n\t\t     * @return {string|object} The template html as a string, or a promise for that\n\t\t     * string.\n\t\t     */\n\t\t    TemplateFactory.prototype.fromString = function (template, params) {\n\t\t        return predicates_1.isFunction(template) ? template(params) : template;\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Loads a template from the a URL via `$http` and `$templateCache`.\n\t\t     *\n\t\t     * @param {string|Function} url url of the template to load, or a function\n\t\t     * that returns a url.\n\t\t     * @param {Object} params Parameters to pass to the url function.\n\t\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t\t     * for that string.\n\t\t     */\n\t\t    TemplateFactory.prototype.fromUrl = function (url, params) {\n\t\t        if (predicates_1.isFunction(url))\n\t\t            url = url(params);\n\t\t        if (url == null)\n\t\t            return null;\n\t\t        return coreservices_1.services.template.get(url);\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * Creates a template by invoking an injectable provider function.\n\t\t     *\n\t\t     * @param provider Function to invoke via `locals`\n\t\t     * @param {Function} injectFn a function used to invoke the template provider\n\t\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t\t     * for that string.\n\t\t     */\n\t\t    TemplateFactory.prototype.fromProvider = function (provider, params, injectFn) {\n\t\t        return injectFn(provider);\n\t\t    };\n\t\t    ;\n\t\t    return TemplateFactory;\n\t\t}());\n\t\texports.TemplateFactory = TemplateFactory;\n\t\n\t\n\t/***/ },\n\t/* 56 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\t/**\n\t\t * This is a [[StateBuilder.builder]] function for angular1 `resolve:` block on a [[Ng1StateDeclaration]].\n\t\t *\n\t\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t\t * handles the `resolve` property with logic specific to angular-ui-router (ng1).\n\t\t */\n\t\tfunction ng1ResolveBuilder(state) {\n\t\t    var resolve = {};\n\t\t    common_1.forEach(state.resolve || {}, function (resolveFn, name) {\n\t\t        resolve[name] = predicates_1.isString(resolveFn) ? [resolveFn, function (x) { return x; }] : resolveFn;\n\t\t    });\n\t\t    return resolve;\n\t\t}\n\t\texports.ng1ResolveBuilder = ng1ResolveBuilder;\n\t\n\t\n\t/***/ },\n\t/* 57 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\t/**\n\t\t * These are the UI-Router angular 1 directives.\n\t\t *\n\t\t * These directives are used in templates to create viewports and navigate to states\n\t\t *\n\t\t * @preferred @module ng1_directives\n\t\t */ /** for typedoc */\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\t/** @hidden */\n\t\tfunction parseStateRef(ref, current) {\n\t\t    var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t\t    if (preparsed)\n\t\t        ref = current + '(' + preparsed[1] + ')';\n\t\t    parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t\t    if (!parsed || parsed.length !== 4)\n\t\t        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t\t    return { state: parsed[1], paramExpr: parsed[3] || null };\n\t\t}\n\t\t/** @hidden */\n\t\tfunction stateContext(el) {\n\t\t    var $uiView = el.parent().inheritedData('$uiView');\n\t\t    var context = hof_1.parse('$cfg.node.state')($uiView);\n\t\t    return context && context.name ? context : undefined;\n\t\t}\n\t\t/** @hidden */\n\t\tfunction getTypeInfo(el) {\n\t\t    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t\t    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t\t    var isForm = el[0].nodeName === \"FORM\";\n\t\t    return {\n\t\t        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t\t        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t\t        clickable: !isForm\n\t\t    };\n\t\t}\n\t\t/** @hidden */\n\t\tfunction clickHook(el, $state, $timeout, type, current) {\n\t\t    return function (e) {\n\t\t        var button = e.which || e.button, target = current();\n\t\t        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t\t            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t\t            var transition = $timeout(function () {\n\t\t                $state.go(target.state, target.params, target.options);\n\t\t            });\n\t\t            e.preventDefault();\n\t\t            // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t\t            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n\t\t            e.preventDefault = function () {\n\t\t                if (ignorePreventDefaultCount-- <= 0)\n\t\t                    $timeout.cancel(transition);\n\t\t            };\n\t\t        }\n\t\t    };\n\t\t}\n\t\t/** @hidden */\n\t\tfunction defaultOpts(el, $state) {\n\t\t    return { relative: stateContext(el) || $state.$current, inherit: true };\n\t\t}\n\t\t/**\n\t\t * `ui-sref`: A directive for linking to a state\n\t\t *\n\t\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t\t * URL, the directive will automatically generate & update the `href` attribute via\n\t\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t\t * the link will trigger a state transition with optional parameters.\n\t\t *\n\t\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t\t * handled natively by the browser.\n\t\t *\n\t\t * You can also use relative state paths within ui-sref, just like the relative\n\t\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t\t * to the state that the link lives in, in other words the state that loaded the\n\t\t * template containing the link.\n\t\t *\n\t\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t\t * and `reload`.\n\t\t *\n\t\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t\t * following template:\n\t\t *\n\t\t * @example\n\t\t * ```html\n\t\t *\n\t\t * <pre>\n\t\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t\t *\n\t\t * <ul>\n\t\t *     <li ng-repeat=\"contact in contacts\">\n\t\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t\t *     </li>\n\t\t * </ul>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t\t *\n\t\t * ```html\n\t\t *\n\t\t * <pre>\n\t\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t\t *\n\t\t * <ul>\n\t\t *     <li ng-repeat=\"contact in contacts\">\n\t\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t\t *     </li>\n\t\t *     <li ng-repeat=\"contact in contacts\">\n\t\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t\t *     </li>\n\t\t *     <li ng-repeat=\"contact in contacts\">\n\t\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t\t *     </li>\n\t\t * </ul>\n\t\t *\n\t\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t\t * @param {Object} ui-sref-opts options to pass to [[StateService.go]]\n\t\t */\n\t\tvar uiSrefNg1 = ['$state', '$timeout',\n\t\t    function $StateRefDirective($state, $timeout) {\n\t\t        return {\n\t\t            restrict: 'A',\n\t\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t\t            link: function (scope, element, attrs, uiSrefActive) {\n\t\t                var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t\t                var def = { state: ref.state, href: null, params: null, options: null };\n\t\t                var type = getTypeInfo(element);\n\t\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t\t                var unlinkInfoFn = null;\n\t\t                def.options = common_1.extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\t                var update = function (val) {\n\t\t                    if (val)\n\t\t                        def.params = angular.copy(val);\n\t\t                    def.href = $state.href(ref.state, def.params, def.options);\n\t\t                    if (unlinkInfoFn)\n\t\t                        unlinkInfoFn();\n\t\t                    if (active)\n\t\t                        unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n\t\t                    if (def.href !== null)\n\t\t                        attrs.$set(type.attr, def.href);\n\t\t                };\n\t\t                if (ref.paramExpr) {\n\t\t                    scope.$watch(ref.paramExpr, function (val) { if (val !== def.params)\n\t\t                        update(val); }, true);\n\t\t                    def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t\t                }\n\t\t                update();\n\t\t                if (!type.clickable)\n\t\t                    return;\n\t\t                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\n\t\t            }\n\t\t        };\n\t\t    }];\n\t\t/**\n\t\t * `ui-state`: A dynamic version of `ui-sref`\n\t\t *\n\t\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t\t * params and override options.\n\t\t *\n\t\t * @example\n\t\t * ```html\n\t\t *\n\t\t * <li ng-repeat=\"nav in navlinks\">\n\t\t *   <a ui-state=\"nav.statename\">{{nav.description}}</a>\n\t\t * </li>\n\t\t *\n\t\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t\t * @param {Object} ui-state-params params to pass to [[StateService.href]]\n\t\t * @param {Object} ui-state-opts options to pass to [[StateService.go]]\n\t\t */\n\t\tvar uiStateNg1 = ['$state', '$timeout',\n\t\t    function $StateRefDynamicDirective($state, $timeout) {\n\t\t        return {\n\t\t            restrict: 'A',\n\t\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t\t            link: function (scope, element, attrs, uiSrefActive) {\n\t\t                var type = getTypeInfo(element);\n\t\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t\t                var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t\t                var watch = '[' + group.map(function (val) { return val || 'null'; }).join(', ') + ']';\n\t\t                var def = { state: null, params: null, options: null, href: null };\n\t\t                var unlinkInfoFn = null;\n\t\t                function runStateRefLink(group) {\n\t\t                    def.state = group[0];\n\t\t                    def.params = group[1];\n\t\t                    def.options = group[2];\n\t\t                    def.href = $state.href(def.state, def.params, def.options);\n\t\t                    if (unlinkInfoFn)\n\t\t                        unlinkInfoFn();\n\t\t                    if (active)\n\t\t                        unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n\t\t                    if (def.href)\n\t\t                        attrs.$set(type.attr, def.href);\n\t\t                }\n\t\t                scope.$watch(watch, runStateRefLink, true);\n\t\t                runStateRefLink(scope.$eval(watch));\n\t\t                if (!type.clickable)\n\t\t                    return;\n\t\t                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\n\t\t            }\n\t\t        };\n\t\t    }];\n\t\t/**\n\t\t * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n\t\t *\n\t\t * A directive working alongside ui-sref to add classes to an element when the\n\t\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t\t * The primary use-case is to simplify the special appearance of navigation menus\n\t\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t\t * distinguishing it from the inactive menu items.\n\t\t *\n\t\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t\t *\n\t\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t\t * need to activate only when the ui-sref target state is active and *not* any of\n\t\t * it's children, then you will use ui-sref-active-eq\n\t\t *\n\t\t * Given the following template:\n\t\t * @example\n\t\t * ```html\n\t\t *\n\t\t * <pre>\n\t\t * <ul>\n\t\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t\t *   </li>\n\t\t * </ul>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t *\n\t\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t\t * the resulting HTML will appear as (note the 'active' class):\n\t\t *\n\t\t * ```html\n\t\t *\n\t\t * <pre>\n\t\t * <ul>\n\t\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t\t *   </li>\n\t\t * </ul>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t\t * interpolated value are ignored).\n\t\t *\n\t\t * Multiple classes may be specified in a space-separated format:\n\t\t *\n\t\t * ```html\n\t\t * <pre>\n\t\t * <ul>\n\t\t *   <li ui-sref-active='class1 class2 class3'>\n\t\t *     <a ui-sref=\"app.user\">link</a>\n\t\t *   </li>\n\t\t * </ul>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t\t * to an object hash, whose keys represent active class names and whose\n\t\t * values represent the respective state names/globs.\n\t\t * ui-sref-active will match if the current active state **includes** any of\n\t\t * the specified state names/globs, even the abstract ones.\n\t\t *\n\t\t * Given the following template, with \"admin\" being an abstract state:\n\t\t * @example\n\t\t * ```html\n\t\t *\n\t\t * <pre>\n\t\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t\t * </div>\n\t\t * </pre>\n\t\t * ```\n\t\t *\n\t\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t\t * to both the <div> and <a> elements. It is important to note that the state\n\t\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t\t */\n\t\tvar uiSrefActiveNg1 = ['$state', '$stateParams', '$interpolate', '$transitions',\n\t\t    function $StateRefActiveDirective($state, $stateParams, $interpolate, $transitions) {\n\t\t        return {\n\t\t            restrict: \"A\",\n\t\t            controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t\t                    var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\t                    // There probably isn't much point in $observing this\n\t\t                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t\t                    // slight difference in logic routing\n\t\t                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\t                    try {\n\t\t                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t\t                    }\n\t\t                    catch (e) {\n\t\t                    }\n\t\t                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t\t                    if (predicates_1.isObject(uiSrefActive)) {\n\t\t                        common_1.forEach(uiSrefActive, function (stateOrName, activeClass) {\n\t\t                            if (predicates_1.isString(stateOrName)) {\n\t\t                                var ref = parseStateRef(stateOrName, $state.current.name);\n\t\t                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t\t                            }\n\t\t                        });\n\t\t                    }\n\t\t                    // Allow uiSref to communicate with uiSrefActive[Equals]\n\t\t                    this.$$addStateInfo = function (newState, newParams) {\n\t\t                        // we already got an explicit state provided by ui-sref-active, so we\n\t\t                        // shadow the one that comes from ui-sref\n\t\t                        if (predicates_1.isObject(uiSrefActive) && states.length > 0) {\n\t\t                            return;\n\t\t                        }\n\t\t                        var deregister = addState(newState, newParams, uiSrefActive);\n\t\t                        update();\n\t\t                        return deregister;\n\t\t                    };\n\t\t                    $scope.$on('$stateChangeSuccess', update);\n\t\t                    var updateAfterTransition = ['$transition$', function ($transition$) { $transition$.promise.then(update); }];\n\t\t                    var deregisterFn = $transitions.onStart({}, updateAfterTransition);\n\t\t                    $scope.$on('$destroy', deregisterFn);\n\t\t                    function addState(stateName, stateParams, activeClass) {\n\t\t                        var state = $state.get(stateName, stateContext($element));\n\t\t                        var stateHash = createStateHash(stateName, stateParams);\n\t\t                        var stateInfo = {\n\t\t                            state: state || { name: stateName },\n\t\t                            params: stateParams,\n\t\t                            hash: stateHash\n\t\t                        };\n\t\t                        states.push(stateInfo);\n\t\t                        activeClasses[stateHash] = activeClass;\n\t\t                        return function removeState() {\n\t\t                            var idx = states.indexOf(stateInfo);\n\t\t                            if (idx !== -1)\n\t\t                                states.splice(idx, 1);\n\t\t                        };\n\t\t                    }\n\t\t                    /**\n\t\t                     * @param {string} state\n\t\t                     * @param {Object|string} [params]\n\t\t                     * @return {string}\n\t\t                     */\n\t\t                    function createStateHash(state, params) {\n\t\t                        if (!predicates_1.isString(state)) {\n\t\t                            throw new Error('state should be a string');\n\t\t                        }\n\t\t                        if (predicates_1.isObject(params)) {\n\t\t                            return state + common_1.toJson(params);\n\t\t                        }\n\t\t                        params = $scope.$eval(params);\n\t\t                        if (predicates_1.isObject(params)) {\n\t\t                            return state + common_1.toJson(params);\n\t\t                        }\n\t\t                        return state;\n\t\t                    }\n\t\t                    // Update route state\n\t\t                    function update() {\n\t\t                        for (var i = 0; i < states.length; i++) {\n\t\t                            if (anyMatch(states[i].state, states[i].params)) {\n\t\t                                addClass($element, activeClasses[states[i].hash]);\n\t\t                            }\n\t\t                            else {\n\t\t                                removeClass($element, activeClasses[states[i].hash]);\n\t\t                            }\n\t\t                            if (exactMatch(states[i].state, states[i].params)) {\n\t\t                                addClass($element, activeEqClass);\n\t\t                            }\n\t\t                            else {\n\t\t                                removeClass($element, activeEqClass);\n\t\t                            }\n\t\t                        }\n\t\t                    }\n\t\t                    function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t\t                    function removeClass(el, className) { el.removeClass(className); }\n\t\t                    function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t\t                    function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\t                    update();\n\t\t                }]\n\t\t        };\n\t\t    }];\n\t\tangular.module('ui.router.state')\n\t\t    .directive('uiSref', uiSrefNg1)\n\t\t    .directive('uiSrefActive', uiSrefActiveNg1)\n\t\t    .directive('uiSrefActiveEq', uiSrefActiveNg1)\n\t\t    .directive('uiState', uiStateNg1);\n\t\n\t\n\t/***/ },\n\t/* 58 */\n\t/***/ function(module, exports) {\n\t\n\t\t/** @module state */ /** for typedoc */\n\t\t\"use strict\";\n\t\t/**\n\t\t * @ngdoc filter\n\t\t * @name ui.router.state.filter:isState\n\t\t *\n\t\t * @requires ui.router.state.$state\n\t\t *\n\t\t * @description\n\t\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t\t */\n\t\t$IsStateFilter.$inject = ['$state'];\n\t\tfunction $IsStateFilter($state) {\n\t\t    var isFilter = function (state, params, options) {\n\t\t        return $state.is(state, params, options);\n\t\t    };\n\t\t    isFilter.$stateful = true;\n\t\t    return isFilter;\n\t\t}\n\t\texports.$IsStateFilter = $IsStateFilter;\n\t\t/**\n\t\t * @ngdoc filter\n\t\t * @name ui.router.state.filter:includedByState\n\t\t *\n\t\t * @requires ui.router.state.$state\n\t\t *\n\t\t * @description\n\t\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t\t */\n\t\t$IncludedByStateFilter.$inject = ['$state'];\n\t\tfunction $IncludedByStateFilter($state) {\n\t\t    var includesFilter = function (state, params, options) {\n\t\t        return $state.includes(state, params, options);\n\t\t    };\n\t\t    includesFilter.$stateful = true;\n\t\t    return includesFilter;\n\t\t}\n\t\texports.$IncludedByStateFilter = $IncludedByStateFilter;\n\t\tangular.module('ui.router.state')\n\t\t    .filter('isState', $IsStateFilter)\n\t\t    .filter('includedByState', $IncludedByStateFilter);\n\t\n\t\n\t/***/ },\n\t/* 59 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t/** @module ng1_directives */ /** for typedoc */\n\t\t\"use strict\";\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar predicates_1 = __webpack_require__(4);\n\t\tvar trace_1 = __webpack_require__(12);\n\t\tvar viewsBuilder_1 = __webpack_require__(54);\n\t\tvar rejectFactory_1 = __webpack_require__(10);\n\t\tvar hof_1 = __webpack_require__(5);\n\t\tvar strings_1 = __webpack_require__(9);\n\t\t/**\n\t\t * `ui-view`: A viewport directive which is filled in by a view from the active state.\n\t\t *\n\t\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t\t * same state. You can have views of the same name that live in different states.\n\t\t *\n\t\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t\t * scroll ui-view elements into view when they are populated during a state activation.\n\t\t *\n\t\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t\t *\n\t\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t\t *\n\t\t * A view can be unnamed or named.\n\t\t * @example\n\t\t * ```html\n\t\t *\n\t\t * <!-- Unnamed -->\n\t\t * <div ui-view></div>\n\t\t *\n\t\t * <!-- Named -->\n\t\t * <div ui-view=\"viewName\"></div>\n\t\t * ```\n\t\t *\n\t\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t\t * single view and it is unnamed then you can populate it like so:\n\t\t * ```\n\t\t *\n\t\t * <div ui-view></div>\n\t\t * $stateProvider.state(\"home\", {\n\t\t *   template: \"<h1>HELLO!</h1>\"\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t\t * config property, by name, in this case an empty name:\n\t\t * ```js\n\t\t *\n\t\t * $stateProvider.state(\"home\", {\n\t\t *   views: {\n\t\t *     \"\": {\n\t\t *       template: \"<h1>HELLO!</h1>\"\n\t\t *     }\n\t\t *   }\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * But typically you'll only use the views property if you name your view or have more than one view\n\t\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t\t * but you could if you wanted, like so:\n\t\t *\n\t\t * ```html\n\t\t *\n\t\t * <div ui-view=\"main\"></div>\n\t\t * ```\n\t\t *\n\t\t * ```js\n\t\t *\n\t\t * $stateProvider.state(\"home\", {\n\t\t *   views: {\n\t\t *     \"main\": {\n\t\t *       template: \"<h1>HELLO!</h1>\"\n\t\t *     }\n\t\t *   }\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * Really though, you'll use views to set up multiple views:\n\t\t * ```html\n\t\t *\n\t\t * <div ui-view></div>\n\t\t * <div ui-view=\"chart\"></div>\n\t\t * <div ui-view=\"data\"></div>\n\t\t * ```\n\t\t *\n\t\t * ```js\n\t\t * $stateProvider.state(\"home\", {\n\t\t *   views: {\n\t\t *     \"\": {\n\t\t *       template: \"<h1>HELLO!</h1>\"\n\t\t *     },\n\t\t *     \"chart\": {\n\t\t *       template: \"<chart_thing/>\"\n\t\t *     },\n\t\t *     \"data\": {\n\t\t *       template: \"<data_thing/>\"\n\t\t *     }\n\t\t *   }\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * Examples for `autoscroll`:\n\t\t *\n\t\t * ```html\n\t\t *\n\t\t * <!-- If autoscroll present with no expression,\n\t\t *      then scroll ui-view into view -->\n\t\t * <ui-view autoscroll/>\n\t\t *\n\t\t * <!-- If autoscroll present with valid expression,\n\t\t *      then scroll ui-view into view if expression evaluates to true -->\n\t\t * <ui-view autoscroll='true'/>\n\t\t * <ui-view autoscroll='false'/>\n\t\t * <ui-view autoscroll='scopeVariable'/>\n\t\t * ```\n\t\t *\n\t\t * Resolve data:\n\t\t *\n\t\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t\t * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t\t *\n\t\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t\t * depends on `$resolve` data.\n\t\t *\n\t\t * @example\n\t\t * ```js\n\t\t *\n\t\t * $stateProvider.state('home', {\n\t\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t\t *   resolve: {\n\t\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t\t *   }\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tvar uiViewNg1 = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n\t\t    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n\t\t        function getRenderer(attrs, scope) {\n\t\t            return {\n\t\t                enter: function (element, target, cb) {\n\t\t                    if (angular.version.minor > 2) {\n\t\t                        $animate.enter(element, null, target).then(cb);\n\t\t                    }\n\t\t                    else {\n\t\t                        $animate.enter(element, null, target, cb);\n\t\t                    }\n\t\t                },\n\t\t                leave: function (element, cb) {\n\t\t                    if (angular.version.minor > 2) {\n\t\t                        $animate.leave(element).then(cb);\n\t\t                    }\n\t\t                    else {\n\t\t                        $animate.leave(element, cb);\n\t\t                    }\n\t\t                }\n\t\t            };\n\t\t        }\n\t\t        function configsEqual(config1, config2) {\n\t\t            return config1 === config2;\n\t\t        }\n\t\t        var rootData = {\n\t\t            $cfg: { viewDecl: { $context: $view.rootContext() } },\n\t\t            $uiView: {}\n\t\t        };\n\t\t        var directive = {\n\t\t            count: 0,\n\t\t            restrict: 'ECA',\n\t\t            terminal: true,\n\t\t            priority: 400,\n\t\t            transclude: 'element',\n\t\t            compile: function (tElement, tAttrs, $transclude) {\n\t\t                return function (scope, $element, attrs) {\n\t\t                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs.onload || '', autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs.uiView || attrs.name || '')(scope) || '$default';\n\t\t                    var activeUIView = {\n\t\t                        $type: 'ng1',\n\t\t                        id: directive.count++,\n\t\t                        name: name,\n\t\t                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n\t\t                        config: null,\n\t\t                        configUpdated: configUpdatedCallback,\n\t\t                        get creationContext() {\n\t\t                            return hof_1.parse('$cfg.viewDecl.$context')(inherited);\n\t\t                        }\n\t\t                    };\n\t\t                    trace_1.trace.traceUiViewEvent(\"Linking\", activeUIView);\n\t\t                    function configUpdatedCallback(config) {\n\t\t                        if (config && !(config instanceof viewsBuilder_1.Ng1ViewConfig))\n\t\t                            return;\n\t\t                        if (configsEqual(viewConfig, config))\n\t\t                            return;\n\t\t                        trace_1.trace.traceUiViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n\t\t                        viewConfig = config;\n\t\t                        updateView(config);\n\t\t                    }\n\t\t                    $element.data('$uiView', { $uiView: activeUIView });\n\t\t                    updateView();\n\t\t                    unregister = $view.registerUiView(activeUIView);\n\t\t                    scope.$on(\"$destroy\", function () {\n\t\t                        trace_1.trace.traceUiViewEvent(\"Destroying/Unregistering\", activeUIView);\n\t\t                        unregister();\n\t\t                    });\n\t\t                    function cleanupLastView() {\n\t\t                        if (previousEl) {\n\t\t                            trace_1.trace.traceUiViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n\t\t                            previousEl.remove();\n\t\t                            previousEl = null;\n\t\t                        }\n\t\t                        if (currentScope) {\n\t\t                            trace_1.trace.traceUiViewEvent(\"Destroying scope\", activeUIView);\n\t\t                            currentScope.$destroy();\n\t\t                            currentScope = null;\n\t\t                        }\n\t\t                        if (currentEl) {\n\t\t                            var _viewData_1 = currentEl.data('$uiView');\n\t\t                            trace_1.trace.traceUiViewEvent(\"Animate out\", _viewData_1);\n\t\t                            renderer.leave(currentEl, function () {\n\t\t                                _viewData_1.$$animLeave.resolve();\n\t\t                                previousEl = null;\n\t\t                            });\n\t\t                            previousEl = currentEl;\n\t\t                            currentEl = null;\n\t\t                        }\n\t\t                    }\n\t\t                    function updateView(config) {\n\t\t                        var newScope = scope.$new();\n\t\t                        trace_1.trace.traceUiViewScopeCreated(activeUIView, newScope);\n\t\t                        var animEnter = $q.defer(), animLeave = $q.defer();\n\t\t                        var $uiViewData = {\n\t\t                            $cfg: config,\n\t\t                            $uiView: activeUIView,\n\t\t                            $animEnter: animEnter.promise,\n\t\t                            $animLeave: animLeave.promise,\n\t\t                            $$animLeave: animLeave\n\t\t                        };\n\t\t                        var cloned = $transclude(newScope, function (clone) {\n\t\t                            renderer.enter(clone.data('$uiView', $uiViewData), $element, function onUiViewEnter() {\n\t\t                                animEnter.resolve();\n\t\t                                if (currentScope)\n\t\t                                    currentScope.$emit('$viewContentAnimationEnded');\n\t\t                                if (predicates_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t\t                                    $uiViewScroll(clone);\n\t\t                                }\n\t\t                            });\n\t\t                            cleanupLastView();\n\t\t                        });\n\t\t                        currentEl = cloned;\n\t\t                        currentScope = newScope;\n\t\t                        /**\n\t\t                         * @ngdoc event\n\t\t                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t\t                         * @eventOf ui.router.state.directive:ui-view\n\t\t                         * @eventType emits on ui-view directive scope\n\t\t                         * @description           *\n\t\t                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t\t                         *\n\t\t                         * @param {Object} event Event object.\n\t\t                         */\n\t\t                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n\t\t                        currentScope.$eval(onloadExp);\n\t\t                    }\n\t\t                };\n\t\t            }\n\t\t        };\n\t\t        return directive;\n\t\t    }];\n\t\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$timeout'];\n\t\t/** @hidden */\n\t\tfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $timeout) {\n\t\t    var getControllerAs = hof_1.parse('viewDecl.controllerAs');\n\t\t    var getResolveAs = hof_1.parse('viewDecl.resolveAs');\n\t\t    var getResolveContext = hof_1.parse('node.resolveContext');\n\t\t    return {\n\t\t        restrict: 'ECA',\n\t\t        priority: -400,\n\t\t        compile: function (tElement) {\n\t\t            var initial = tElement.html();\n\t\t            return function (scope, $element) {\n\t\t                var data = $element.data('$uiView');\n\t\t                if (!data)\n\t\t                    return;\n\t\t                var cfg = data.$cfg || { viewDecl: {} };\n\t\t                $element.html(cfg.template || initial);\n\t\t                trace_1.trace.traceUiViewFill(data.$uiView, $element.html());\n\t\t                var link = $compile($element.contents());\n\t\t                var controller = cfg.controller;\n\t\t                var controllerAs = getControllerAs(cfg);\n\t\t                var resolveAs = getResolveAs(cfg);\n\t\t                var resolveCtx = getResolveContext(cfg);\n\t\t                var locals = resolveCtx && common_1.map(resolveCtx.getResolvables(), function (r) { return r.data; });\n\t\t                scope[resolveAs] = locals;\n\t\t                if (controller) {\n\t\t                    var controllerInstance = $controller(controller, common_1.extend({}, locals, { $scope: scope, $element: $element }));\n\t\t                    if (controllerAs) {\n\t\t                        scope[controllerAs] = controllerInstance;\n\t\t                        scope[controllerAs][resolveAs] = locals;\n\t\t                    }\n\t\t                    // TODO: Use $view service as a central point for registering component-level hooks\n\t\t                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n\t\t                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n\t\t                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\t\t                    $element.data('$ngControllerController', controllerInstance);\n\t\t                    $element.children().data('$ngControllerController', controllerInstance);\n\t\t                    registerControllerCallbacks($transitions, controllerInstance, scope, cfg);\n\t\t                }\n\t\t                // Wait for the component to appear in the DOM\n\t\t                if (predicates_1.isString(cfg.viewDecl.component)) {\n\t\t                    var cmp_1 = cfg.viewDecl.component;\n\t\t                    var kebobName_1 = strings_1.kebobString(cmp_1);\n\t\t                    var getComponentController = function () {\n\t\t                        var directiveEl = [].slice.call($element[0].children)\n\t\t                            .filter(function (el) { return el && el.tagName && el.tagName.toLowerCase() === kebobName_1; });\n\t\t                        return directiveEl && angular.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n\t\t                    };\n\t\t                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n\t\t                        if (!ctrlInstance)\n\t\t                            return;\n\t\t                        registerControllerCallbacks($transitions, ctrlInstance, scope, cfg);\n\t\t                        deregisterWatch_1();\n\t\t                    });\n\t\t                }\n\t\t                link(scope);\n\t\t            };\n\t\t        }\n\t\t    };\n\t\t}\n\t\t/** @hidden */\n\t\tvar hasComponentImpl = typeof angular.module('ui.router')['component'] === 'function';\n\t\t/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\n\t\tfunction registerControllerCallbacks($transitions, controllerInstance, $scope, cfg) {\n\t\t    // Call $onInit() ASAP\n\t\t    if (predicates_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl))\n\t\t        controllerInstance.$onInit();\n\t\t    var hookOptions = { bind: controllerInstance };\n\t\t    // Add component-level hook for onParamsChange\n\t\t    if (predicates_1.isFunction(controllerInstance.uiOnParamsChanged)) {\n\t\t        // Fire callback on any successful transition\n\t\t        var paramsUpdated_1 = function ($transition$) {\n\t\t            var ctx = cfg.node.resolveContext;\n\t\t            var viewCreationTrans = ctx.getResolvables()['$transition$'].data;\n\t\t            // Exit early if the $transition$ is the same as the view was created within.\n\t\t            // Exit early if the $transition$ will exit the state the view is for.\n\t\t            if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(cfg.node.state.self) !== -1)\n\t\t                return;\n\t\t            var toParams = $transition$.params(\"to\");\n\t\t            var fromParams = $transition$.params(\"from\");\n\t\t            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(common_1.unnestR, []);\n\t\t            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(common_1.unnestR, []);\n\t\t            // Find the to params that have different values than the from params\n\t\t            var changedToParams = toSchema.filter(function (param) {\n\t\t                var idx = fromSchema.indexOf(param);\n\t\t                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n\t\t            });\n\t\t            // Only trigger callback if a to param has changed or is new\n\t\t            if (changedToParams.length) {\n\t\t                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n\t\t                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n\t\t                controllerInstance.uiOnParamsChanged(common_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; }), $transition$);\n\t\t            }\n\t\t        };\n\t\t        $scope.$on('$destroy', $transitions.onSuccess({}, ['$transition$', paramsUpdated_1]), hookOptions);\n\t\t        // Fire callback on any IGNORED transition\n\t\t        var onDynamic = function ($error$, $transition$) {\n\t\t            if ($error$.type === rejectFactory_1.RejectType.IGNORED)\n\t\t                paramsUpdated_1($transition$);\n\t\t        };\n\t\t        $scope.$on('$destroy', $transitions.onError({}, ['$error$', '$transition$', onDynamic]), hookOptions);\n\t\t    }\n\t\t    // Add component-level hook for uiCanExit\n\t\t    if (predicates_1.isFunction(controllerInstance.uiCanExit)) {\n\t\t        var criteria = { exiting: cfg.node.state.name };\n\t\t        $scope.$on('$destroy', $transitions.onBefore(criteria, controllerInstance.uiCanExit, hookOptions));\n\t\t    }\n\t\t}\n\t\tangular.module('ui.router.state').directive('uiView', uiViewNg1);\n\t\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\t\n\t/***/ },\n\t/* 60 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t/**\n\t\t * @ngdoc object\n\t\t * @name ui.router.state.$uiViewScrollProvider\n\t\t *\n\t\t * @description\n\t\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t\t */\n\t\tfunction $ViewScrollProvider() {\n\t\t    var useAnchorScroll = false;\n\t\t    /**\n\t\t     * @ngdoc function\n\t\t     * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t\t     * @methodOf ui.router.state.$uiViewScrollProvider\n\t\t     *\n\t\t     * @description\n\t\t     * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t\t     * scrolling based on the url anchor.\n\t\t     */\n\t\t    this.useAnchorScroll = function () {\n\t\t        useAnchorScroll = true;\n\t\t    };\n\t\t    /**\n\t\t     * @ngdoc object\n\t\t     * @name ui.router.state.$uiViewScroll\n\t\t     *\n\t\t     * @requires $anchorScroll\n\t\t     * @requires $timeout\n\t\t     *\n\t\t     * @description\n\t\t     * When called with a jqLite element, it scrolls the element into view (after a\n\t\t     * `$timeout` so the DOM has time to refresh).\n\t\t     *\n\t\t     * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t\t     * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t\t     */\n\t\t    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t\t            if (useAnchorScroll) {\n\t\t                return $anchorScroll;\n\t\t            }\n\t\t            return function ($element) {\n\t\t                return $timeout(function () {\n\t\t                    $element[0].scrollIntoView();\n\t\t                }, 0, false);\n\t\t            };\n\t\t        }];\n\t\t}\n\t\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=angular-ui-router.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(7);\n\tmodule.exports = 'ngAnimate';\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @license AngularJS v1.5.7\n\t * (c) 2010-2016 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t(function(window, angular) {'use strict';\n\t\n\t/* jshint ignore:start */\n\tvar noop        = angular.noop;\n\tvar copy        = angular.copy;\n\tvar extend      = angular.extend;\n\tvar jqLite      = angular.element;\n\tvar forEach     = angular.forEach;\n\tvar isArray     = angular.isArray;\n\tvar isString    = angular.isString;\n\tvar isObject    = angular.isObject;\n\tvar isUndefined = angular.isUndefined;\n\tvar isDefined   = angular.isDefined;\n\tvar isFunction  = angular.isFunction;\n\tvar isElement   = angular.isElement;\n\t\n\tvar ELEMENT_NODE = 1;\n\tvar COMMENT_NODE = 8;\n\t\n\tvar ADD_CLASS_SUFFIX = '-add';\n\tvar REMOVE_CLASS_SUFFIX = '-remove';\n\tvar EVENT_CLASS_PREFIX = 'ng-';\n\tvar ACTIVE_CLASS_SUFFIX = '-active';\n\tvar PREPARE_CLASS_SUFFIX = '-prepare';\n\t\n\tvar NG_ANIMATE_CLASSNAME = 'ng-animate';\n\tvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\t\n\t// Detect proper transitionend/animationend event names.\n\tvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\t\n\t// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n\t// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n\t// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n\t// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n\t// Register both events in case `window.onanimationend` is not supported because of that,\n\t// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n\t// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n\t// therefore there is no reason to test anymore for other vendor prefixes:\n\t// http://caniuse.com/#search=transition\n\tif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  TRANSITION_PROP = 'WebkitTransition';\n\t  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n\t} else {\n\t  TRANSITION_PROP = 'transition';\n\t  TRANSITIONEND_EVENT = 'transitionend';\n\t}\n\t\n\tif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n\t  CSS_PREFIX = '-webkit-';\n\t  ANIMATION_PROP = 'WebkitAnimation';\n\t  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n\t} else {\n\t  ANIMATION_PROP = 'animation';\n\t  ANIMATIONEND_EVENT = 'animationend';\n\t}\n\t\n\tvar DURATION_KEY = 'Duration';\n\tvar PROPERTY_KEY = 'Property';\n\tvar DELAY_KEY = 'Delay';\n\tvar TIMING_KEY = 'TimingFunction';\n\tvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\n\tvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\n\tvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\t\n\tvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\n\tvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\n\tvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\n\tvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\t\n\tvar isPromiseLike = function(p) {\n\t  return p && p.then ? true : false;\n\t};\n\t\n\tvar ngMinErr = angular.$$minErr('ng');\n\tfunction assertArg(arg, name, reason) {\n\t  if (!arg) {\n\t    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n\t  }\n\t  return arg;\n\t}\n\t\n\tfunction mergeClasses(a,b) {\n\t  if (!a && !b) return '';\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  if (isArray(a)) a = a.join(' ');\n\t  if (isArray(b)) b = b.join(' ');\n\t  return a + ' ' + b;\n\t}\n\t\n\tfunction packageStyles(options) {\n\t  var styles = {};\n\t  if (options && (options.to || options.from)) {\n\t    styles.to = options.to;\n\t    styles.from = options.from;\n\t  }\n\t  return styles;\n\t}\n\t\n\tfunction pendClasses(classes, fix, isPrefix) {\n\t  var className = '';\n\t  classes = isArray(classes)\n\t      ? classes\n\t      : classes && isString(classes) && classes.length\n\t          ? classes.split(/\\s+/)\n\t          : [];\n\t  forEach(classes, function(klass, i) {\n\t    if (klass && klass.length > 0) {\n\t      className += (i > 0) ? ' ' : '';\n\t      className += isPrefix ? fix + klass\n\t                            : klass + fix;\n\t    }\n\t  });\n\t  return className;\n\t}\n\t\n\tfunction removeFromArray(arr, val) {\n\t  var index = arr.indexOf(val);\n\t  if (val >= 0) {\n\t    arr.splice(index, 1);\n\t  }\n\t}\n\t\n\tfunction stripCommentsFromElement(element) {\n\t  if (element instanceof jqLite) {\n\t    switch (element.length) {\n\t      case 0:\n\t        return element;\n\t        break;\n\t\n\t      case 1:\n\t        // there is no point of stripping anything if the element\n\t        // is the only element within the jqLite wrapper.\n\t        // (it's important that we retain the element instance.)\n\t        if (element[0].nodeType === ELEMENT_NODE) {\n\t          return element;\n\t        }\n\t        break;\n\t\n\t      default:\n\t        return jqLite(extractElementNode(element));\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (element.nodeType === ELEMENT_NODE) {\n\t    return jqLite(element);\n\t  }\n\t}\n\t\n\tfunction extractElementNode(element) {\n\t  if (!element[0]) return element;\n\t  for (var i = 0; i < element.length; i++) {\n\t    var elm = element[i];\n\t    if (elm.nodeType == ELEMENT_NODE) {\n\t      return elm;\n\t    }\n\t  }\n\t}\n\t\n\tfunction $$addClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.addClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction $$removeClass($$jqLite, element, className) {\n\t  forEach(element, function(elm) {\n\t    $$jqLite.removeClass(elm, className);\n\t  });\n\t}\n\t\n\tfunction applyAnimationClassesFactory($$jqLite) {\n\t  return function(element, options) {\n\t    if (options.addClass) {\n\t      $$addClass($$jqLite, element, options.addClass);\n\t      options.addClass = null;\n\t    }\n\t    if (options.removeClass) {\n\t      $$removeClass($$jqLite, element, options.removeClass);\n\t      options.removeClass = null;\n\t    }\n\t  }\n\t}\n\t\n\tfunction prepareAnimationOptions(options) {\n\t  options = options || {};\n\t  if (!options.$$prepared) {\n\t    var domOperation = options.domOperation || noop;\n\t    options.domOperation = function() {\n\t      options.$$domOperationFired = true;\n\t      domOperation();\n\t      domOperation = noop;\n\t    };\n\t    options.$$prepared = true;\n\t  }\n\t  return options;\n\t}\n\t\n\tfunction applyAnimationStyles(element, options) {\n\t  applyAnimationFromStyles(element, options);\n\t  applyAnimationToStyles(element, options);\n\t}\n\t\n\tfunction applyAnimationFromStyles(element, options) {\n\t  if (options.from) {\n\t    element.css(options.from);\n\t    options.from = null;\n\t  }\n\t}\n\t\n\tfunction applyAnimationToStyles(element, options) {\n\t  if (options.to) {\n\t    element.css(options.to);\n\t    options.to = null;\n\t  }\n\t}\n\t\n\tfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n\t  var target = oldAnimation.options || {};\n\t  var newOptions = newAnimation.options || {};\n\t\n\t  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n\t  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n\t  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\t\n\t  if (newOptions.preparationClasses) {\n\t    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n\t    delete newOptions.preparationClasses;\n\t  }\n\t\n\t  // noop is basically when there is no callback; otherwise something has been set\n\t  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\t\n\t  extend(target, newOptions);\n\t\n\t  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n\t  if (realDomOperation) {\n\t    target.domOperation = realDomOperation;\n\t  }\n\t\n\t  if (classes.addClass) {\n\t    target.addClass = classes.addClass;\n\t  } else {\n\t    target.addClass = null;\n\t  }\n\t\n\t  if (classes.removeClass) {\n\t    target.removeClass = classes.removeClass;\n\t  } else {\n\t    target.removeClass = null;\n\t  }\n\t\n\t  oldAnimation.addClass = target.addClass;\n\t  oldAnimation.removeClass = target.removeClass;\n\t\n\t  return target;\n\t}\n\t\n\tfunction resolveElementClasses(existing, toAdd, toRemove) {\n\t  var ADD_CLASS = 1;\n\t  var REMOVE_CLASS = -1;\n\t\n\t  var flags = {};\n\t  existing = splitClassesToLookup(existing);\n\t\n\t  toAdd = splitClassesToLookup(toAdd);\n\t  forEach(toAdd, function(value, key) {\n\t    flags[key] = ADD_CLASS;\n\t  });\n\t\n\t  toRemove = splitClassesToLookup(toRemove);\n\t  forEach(toRemove, function(value, key) {\n\t    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n\t  });\n\t\n\t  var classes = {\n\t    addClass: '',\n\t    removeClass: ''\n\t  };\n\t\n\t  forEach(flags, function(val, klass) {\n\t    var prop, allow;\n\t    if (val === ADD_CLASS) {\n\t      prop = 'addClass';\n\t      allow = !existing[klass];\n\t    } else if (val === REMOVE_CLASS) {\n\t      prop = 'removeClass';\n\t      allow = existing[klass];\n\t    }\n\t    if (allow) {\n\t      if (classes[prop].length) {\n\t        classes[prop] += ' ';\n\t      }\n\t      classes[prop] += klass;\n\t    }\n\t  });\n\t\n\t  function splitClassesToLookup(classes) {\n\t    if (isString(classes)) {\n\t      classes = classes.split(' ');\n\t    }\n\t\n\t    var obj = {};\n\t    forEach(classes, function(klass) {\n\t      // sometimes the split leaves empty string values\n\t      // incase extra spaces were applied to the options\n\t      if (klass.length) {\n\t        obj[klass] = true;\n\t      }\n\t    });\n\t    return obj;\n\t  }\n\t\n\t  return classes;\n\t}\n\t\n\tfunction getDomNode(element) {\n\t  return (element instanceof angular.element) ? element[0] : element;\n\t}\n\t\n\tfunction applyGeneratedPreparationClasses(element, event, options) {\n\t  var classes = '';\n\t  if (event) {\n\t    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n\t  }\n\t  if (options.addClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n\t  }\n\t  if (options.removeClass) {\n\t    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n\t  }\n\t  if (classes.length) {\n\t    options.preparationClasses = classes;\n\t    element.addClass(classes);\n\t  }\n\t}\n\t\n\tfunction clearGeneratedClasses(element, options) {\n\t  if (options.preparationClasses) {\n\t    element.removeClass(options.preparationClasses);\n\t    options.preparationClasses = null;\n\t  }\n\t  if (options.activeClasses) {\n\t    element.removeClass(options.activeClasses);\n\t    options.activeClasses = null;\n\t  }\n\t}\n\t\n\tfunction blockTransitions(node, duration) {\n\t  // we use a negative delay value since it performs blocking\n\t  // yet it doesn't kill any existing transitions running on the\n\t  // same element which makes this safe for class-based animations\n\t  var value = duration ? '-' + duration + 's' : '';\n\t  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n\t  return [TRANSITION_DELAY_PROP, value];\n\t}\n\t\n\tfunction blockKeyframeAnimations(node, applyBlock) {\n\t  var value = applyBlock ? 'paused' : '';\n\t  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n\t  applyInlineStyle(node, [key, value]);\n\t  return [key, value];\n\t}\n\t\n\tfunction applyInlineStyle(node, styleTuple) {\n\t  var prop = styleTuple[0];\n\t  var value = styleTuple[1];\n\t  node.style[prop] = value;\n\t}\n\t\n\tfunction concatWithSpace(a,b) {\n\t  if (!a) return b;\n\t  if (!b) return a;\n\t  return a + ' ' + b;\n\t}\n\t\n\tvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n\t  var queue, cancelFn;\n\t\n\t  function scheduler(tasks) {\n\t    // we make a copy since RAFScheduler mutates the state\n\t    // of the passed in array variable and this would be difficult\n\t    // to track down on the outside code\n\t    queue = queue.concat(tasks);\n\t    nextTick();\n\t  }\n\t\n\t  queue = scheduler.queue = [];\n\t\n\t  /* waitUntilQuiet does two things:\n\t   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n\t   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n\t   *\n\t   * The motivation here is that animation code can request more time from the scheduler\n\t   * before the next wave runs. This allows for certain DOM properties such as classes to\n\t   * be resolved in time for the next animation to run.\n\t   */\n\t  scheduler.waitUntilQuiet = function(fn) {\n\t    if (cancelFn) cancelFn();\n\t\n\t    cancelFn = $$rAF(function() {\n\t      cancelFn = null;\n\t      fn();\n\t      nextTick();\n\t    });\n\t  };\n\t\n\t  return scheduler;\n\t\n\t  function nextTick() {\n\t    if (!queue.length) return;\n\t\n\t    var items = queue.shift();\n\t    for (var i = 0; i < items.length; i++) {\n\t      items[i]();\n\t    }\n\t\n\t    if (!cancelFn) {\n\t      $$rAF(function() {\n\t        if (!cancelFn) nextTick();\n\t      });\n\t    }\n\t  }\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateChildren\n\t * @restrict AE\n\t * @element ANY\n\t *\n\t * @description\n\t *\n\t * ngAnimateChildren allows you to specify that children of this element should animate even if any\n\t * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n\t * (structural) animation, child elements that also have an active structural animation are not animated.\n\t *\n\t * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n\t *\n\t *\n\t * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n\t *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n\t *\n\t * @example\n\t * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n\t     <file name=\"index.html\">\n\t       <div ng-controller=\"mainController as main\">\n\t         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n\t         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n\t         <hr>\n\t         <div ng-animate-children=\"{{main.animateChildren}}\">\n\t           <div ng-if=\"main.enterElement\" class=\"container\">\n\t             List of items:\n\t             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n\t           </div>\n\t         </div>\n\t       </div>\n\t     </file>\n\t     <file name=\"animations.css\">\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave {\n\t        transition: all ease 1.5s;\n\t      }\n\t\n\t      .container.ng-enter,\n\t      .container.ng-leave-active {\n\t        opacity: 0;\n\t      }\n\t\n\t      .container.ng-leave,\n\t      .container.ng-enter-active {\n\t        opacity: 1;\n\t      }\n\t\n\t      .item {\n\t        background: firebrick;\n\t        color: #FFF;\n\t        margin-bottom: 10px;\n\t      }\n\t\n\t      .item.ng-enter,\n\t      .item.ng-leave {\n\t        transition: transform 1.5s ease;\n\t      }\n\t\n\t      .item.ng-enter {\n\t        transform: translateX(50px);\n\t      }\n\t\n\t      .item.ng-enter-active {\n\t        transform: translateX(0);\n\t      }\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('ngAnimateChildren', ['ngAnimate'])\n\t        .controller('mainController', function() {\n\t          this.animateChildren = false;\n\t          this.enterElement = false;\n\t        });\n\t    </file>\n\t  </example>\n\t */\n\tvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n\t  return {\n\t    link: function(scope, element, attrs) {\n\t      var val = attrs.ngAnimateChildren;\n\t      if (angular.isString(val) && val.length === 0) { //empty attribute\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n\t      } else {\n\t        // Interpolate and set the value, so that it is available to\n\t        // animations that run right after compilation\n\t        setData($interpolate(val)(scope));\n\t        attrs.$observe('ngAnimateChildren', setData);\n\t      }\n\t\n\t      function setData(value) {\n\t        value = value === 'on' || value === 'true';\n\t        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n\t      }\n\t    }\n\t  };\n\t}];\n\t\n\tvar ANIMATE_TIMER_KEY = '$$animateCss';\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animateCss\n\t * @kind object\n\t *\n\t * @description\n\t * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n\t * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n\t * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n\t * directives to create more complex animations that can be purely driven using CSS code.\n\t *\n\t * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n\t * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n\t *\n\t * ## Usage\n\t * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n\t * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n\t * any automatic control over cancelling animations and/or preventing animations from being run on\n\t * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n\t * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n\t * the CSS animation.\n\t *\n\t * The example below shows how we can create a folding animation on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <!-- notice the `fold-animation` CSS class -->\n\t * <div ng-if=\"onOff\" class=\"fold-animation\">\n\t *   This element will go BOOM\n\t * </div>\n\t * <button ng-click=\"onOff=true\">Fold In</button>\n\t * ```\n\t *\n\t * Now we create the **JavaScript animation** that will trigger the CSS transition:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## More Advanced Uses\n\t *\n\t * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n\t * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n\t *\n\t * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n\t * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n\t * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n\t * to provide a working animation that will run in CSS.\n\t *\n\t * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n\t *\n\t * ```js\n\t * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       var height = element[0].offsetHeight;\n\t *       return $animateCss(element, {\n\t *         addClass: 'red large-text pulse-twice',\n\t *         easing: 'ease-out',\n\t *         from: { height:'0px' },\n\t *         to: { height:height + 'px' },\n\t *         duration: 1 // one second\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n\t *\n\t * ```css\n\t * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n\t * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n\t * .red { background:red; }\n\t * .large-text { font-size:20px; }\n\t *\n\t * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n\t * .pulse-twice {\n\t *   animation: 0.5s pulse linear 2;\n\t *   -webkit-animation: 0.5s pulse linear 2;\n\t * }\n\t *\n\t * @keyframes pulse {\n\t *   from { transform: scale(0.5); }\n\t *   to { transform: scale(1.5); }\n\t * }\n\t *\n\t * @-webkit-keyframes pulse {\n\t *   from { -webkit-transform: scale(0.5); }\n\t *   to { -webkit-transform: scale(1.5); }\n\t * }\n\t * ```\n\t *\n\t * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n\t *\n\t * ## How the Options are handled\n\t *\n\t * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n\t * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n\t * styles using the `from` and `to` properties.\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, {\n\t *   from: { background:'red' },\n\t *   to: { background:'blue' }\n\t * });\n\t * animator.start();\n\t * ```\n\t *\n\t * ```css\n\t * .rotating-animation {\n\t *   animation:0.5s rotate linear;\n\t *   -webkit-animation:0.5s rotate linear;\n\t * }\n\t *\n\t * @keyframes rotate {\n\t *   from { transform: rotate(0deg); }\n\t *   to { transform: rotate(360deg); }\n\t * }\n\t *\n\t * @-webkit-keyframes rotate {\n\t *   from { -webkit-transform: rotate(0deg); }\n\t *   to { -webkit-transform: rotate(360deg); }\n\t * }\n\t * ```\n\t *\n\t * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n\t * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n\t * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n\t * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n\t * and spread across the transition and keyframe animation.\n\t *\n\t * ## What is returned\n\t *\n\t * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n\t * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n\t * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n\t *\n\t * ```js\n\t * var animator = $animateCss(element, { ... });\n\t * ```\n\t *\n\t * Now what do the contents of our `animator` variable look like:\n\t *\n\t * ```js\n\t * {\n\t *   // starts the animation\n\t *   start: Function,\n\t *\n\t *   // ends (aborts) the animation\n\t *   end: Function\n\t * }\n\t * ```\n\t *\n\t * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n\t * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n\t * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n\t * and that changing them will not reconfigure the parameters of the animation.\n\t *\n\t * ### runner.done() vs runner.then()\n\t * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n\t * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n\t * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n\t * unless you really need a digest to kick off afterwards.\n\t *\n\t * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n\t * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n\t * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n\t *\n\t * @param {DOMElement} element the element that will be animated\n\t * @param {object} options the animation-related options that will be applied during the animation\n\t *\n\t * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n\t * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n\t * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n\t * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n\t * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n\t * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n\t * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n\t * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n\t * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n\t * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n\t * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n\t * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n\t * is provided then the animation will be skipped entirely.\n\t * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n\t * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n\t * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n\t * CSS delay value.\n\t * * `stagger` - A numeric time value representing the delay between successively animated elements\n\t * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n\t * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n\t *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n\t * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n\t * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n\t *    the animation is closed. This is useful for when the styles are used purely for the sake of\n\t *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n\t *    By default this value is set to `false`.\n\t *\n\t * @return {object} an object with start and end methods and details about the animation.\n\t *\n\t * * `start` - The method to start the animation. This will return a `Promise` when called.\n\t * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n\t */\n\tvar ONE_SECOND = 1000;\n\tvar BASE_TEN = 10;\n\t\n\tvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n\tvar CLOSING_TIME_BUFFER = 1.5;\n\t\n\tvar DETECT_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP,\n\t  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n\t};\n\t\n\tvar DETECT_STAGGER_CSS_PROPERTIES = {\n\t  transitionDuration:      TRANSITION_DURATION_PROP,\n\t  transitionDelay:         TRANSITION_DELAY_PROP,\n\t  animationDuration:       ANIMATION_DURATION_PROP,\n\t  animationDelay:          ANIMATION_DELAY_PROP\n\t};\n\t\n\tfunction getCssKeyframeDurationStyle(duration) {\n\t  return [ANIMATION_DURATION_PROP, duration + 's'];\n\t}\n\t\n\tfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n\t  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n\t  return [prop, delay + 's'];\n\t}\n\t\n\tfunction computeCssStyles($window, element, properties) {\n\t  var styles = Object.create(null);\n\t  var detectedStyles = $window.getComputedStyle(element) || {};\n\t  forEach(properties, function(formalStyleName, actualStyleName) {\n\t    var val = detectedStyles[formalStyleName];\n\t    if (val) {\n\t      var c = val.charAt(0);\n\t\n\t      // only numerical-based values have a negative sign or digit as the first value\n\t      if (c === '-' || c === '+' || c >= 0) {\n\t        val = parseMaxTime(val);\n\t      }\n\t\n\t      // by setting this to null in the event that the delay is not set or is set directly as 0\n\t      // then we can still allow for negative values to be used later on and not mistake this\n\t      // value for being greater than any other negative value.\n\t      if (val === 0) {\n\t        val = null;\n\t      }\n\t      styles[actualStyleName] = val;\n\t    }\n\t  });\n\t\n\t  return styles;\n\t}\n\t\n\tfunction parseMaxTime(str) {\n\t  var maxValue = 0;\n\t  var values = str.split(/\\s*,\\s*/);\n\t  forEach(values, function(value) {\n\t    // it's always safe to consider only second values and omit `ms` values since\n\t    // getComputedStyle will always handle the conversion for us\n\t    if (value.charAt(value.length - 1) == 's') {\n\t      value = value.substring(0, value.length - 1);\n\t    }\n\t    value = parseFloat(value) || 0;\n\t    maxValue = maxValue ? Math.max(value, maxValue) : value;\n\t  });\n\t  return maxValue;\n\t}\n\t\n\tfunction truthyTimingValue(val) {\n\t  return val === 0 || val != null;\n\t}\n\t\n\tfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n\t  var style = TRANSITION_PROP;\n\t  var value = duration + 's';\n\t  if (applyOnlyDuration) {\n\t    style += DURATION_KEY;\n\t  } else {\n\t    value += ' linear all';\n\t  }\n\t  return [style, value];\n\t}\n\t\n\tfunction createLocalCacheLookup() {\n\t  var cache = Object.create(null);\n\t  return {\n\t    flush: function() {\n\t      cache = Object.create(null);\n\t    },\n\t\n\t    count: function(key) {\n\t      var entry = cache[key];\n\t      return entry ? entry.total : 0;\n\t    },\n\t\n\t    get: function(key) {\n\t      var entry = cache[key];\n\t      return entry && entry.value;\n\t    },\n\t\n\t    put: function(key, value) {\n\t      if (!cache[key]) {\n\t        cache[key] = { total: 1, value: value };\n\t      } else {\n\t        cache[key].total++;\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\t// we do not reassign an already present style value since\n\t// if we detect the style property value again we may be\n\t// detecting styles that were added via the `from` styles.\n\t// We make use of `isDefined` here since an empty string\n\t// or null value (which is what getPropertyValue will return\n\t// for a non-existing style) will still be marked as a valid\n\t// value for the style (a falsy value implies that the style\n\t// is to be removed at the end of the animation). If we had a simple\n\t// \"OR\" statement then it would not be enough to catch that.\n\tfunction registerRestorableStyles(backup, node, properties) {\n\t  forEach(properties, function(prop) {\n\t    backup[prop] = isDefined(backup[prop])\n\t        ? backup[prop]\n\t        : node.style.getPropertyValue(prop);\n\t  });\n\t}\n\t\n\tvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n\t  var gcsLookup = createLocalCacheLookup();\n\t  var gcsStaggerLookup = createLocalCacheLookup();\n\t\n\t  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n\t               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n\t       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n\t                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    var parentCounter = 0;\n\t    function gcsHashFn(node, extraClasses) {\n\t      var KEY = \"$$ngAnimateParentKey\";\n\t      var parentNode = node.parentNode;\n\t      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n\t      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n\t    }\n\t\n\t    function computeCachedCssStyles(node, className, cacheKey, properties) {\n\t      var timings = gcsLookup.get(cacheKey);\n\t\n\t      if (!timings) {\n\t        timings = computeCssStyles($window, node, properties);\n\t        if (timings.animationIterationCount === 'infinite') {\n\t          timings.animationIterationCount = 1;\n\t        }\n\t      }\n\t\n\t      // we keep putting this in multiple times even though the value and the cacheKey are the same\n\t      // because we're keeping an internal tally of how many duplicate animations are detected.\n\t      gcsLookup.put(cacheKey, timings);\n\t      return timings;\n\t    }\n\t\n\t    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n\t      var stagger;\n\t\n\t      // if we have one or more existing matches of matching elements\n\t      // containing the same parent + CSS styles (which is how cacheKey works)\n\t      // then staggering is possible\n\t      if (gcsLookup.count(cacheKey) > 0) {\n\t        stagger = gcsStaggerLookup.get(cacheKey);\n\t\n\t        if (!stagger) {\n\t          var staggerClassName = pendClasses(className, '-stagger');\n\t\n\t          $$jqLite.addClass(node, staggerClassName);\n\t\n\t          stagger = computeCssStyles($window, node, properties);\n\t\n\t          // force the conversion of a null value to zero incase not set\n\t          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n\t          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\t\n\t          $$jqLite.removeClass(node, staggerClassName);\n\t\n\t          gcsStaggerLookup.put(cacheKey, stagger);\n\t        }\n\t      }\n\t\n\t      return stagger || {};\n\t    }\n\t\n\t    var cancelLastRAFRequest;\n\t    var rafWaitQueue = [];\n\t    function waitUntilQuiet(callback) {\n\t      rafWaitQueue.push(callback);\n\t      $$rAFScheduler.waitUntilQuiet(function() {\n\t        gcsLookup.flush();\n\t        gcsStaggerLookup.flush();\n\t\n\t        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n\t        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n\t        var pageWidth = $$forceReflow();\n\t\n\t        // we use a for loop to ensure that if the queue is changed\n\t        // during this looping then it will consider new requests\n\t        for (var i = 0; i < rafWaitQueue.length; i++) {\n\t          rafWaitQueue[i](pageWidth);\n\t        }\n\t        rafWaitQueue.length = 0;\n\t      });\n\t    }\n\t\n\t    function computeTimings(node, className, cacheKey) {\n\t      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n\t      var aD = timings.animationDelay;\n\t      var tD = timings.transitionDelay;\n\t      timings.maxDelay = aD && tD\n\t          ? Math.max(aD, tD)\n\t          : (aD || tD);\n\t      timings.maxDuration = Math.max(\n\t          timings.animationDuration * timings.animationIterationCount,\n\t          timings.transitionDuration);\n\t\n\t      return timings;\n\t    }\n\t\n\t    return function init(element, initialOptions) {\n\t      // all of the animation functions should create\n\t      // a copy of the options data, however, if a\n\t      // parent service has already created a copy then\n\t      // we should stick to using that\n\t      var options = initialOptions || {};\n\t      if (!options.$$prepared) {\n\t        options = prepareAnimationOptions(copy(options));\n\t      }\n\t\n\t      var restoreStyles = {};\n\t      var node = getDomNode(element);\n\t      if (!node\n\t          || !node.parentNode\n\t          || !$$animateQueue.enabled()) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var temporaryStyles = [];\n\t      var classes = element.attr('class');\n\t      var styles = packageStyles(options);\n\t      var animationClosed;\n\t      var animationPaused;\n\t      var animationCompleted;\n\t      var runner;\n\t      var runnerHost;\n\t      var maxDelay;\n\t      var maxDelayTime;\n\t      var maxDuration;\n\t      var maxDurationTime;\n\t      var startTime;\n\t      var events = [];\n\t\n\t      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var method = options.event && isArray(options.event)\n\t            ? options.event.join(' ')\n\t            : options.event;\n\t\n\t      var isStructural = method && options.structural;\n\t      var structuralClassName = '';\n\t      var addRemoveClassName = '';\n\t\n\t      if (isStructural) {\n\t        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n\t      } else if (method) {\n\t        structuralClassName = method;\n\t      }\n\t\n\t      if (options.addClass) {\n\t        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n\t      }\n\t\n\t      if (options.removeClass) {\n\t        if (addRemoveClassName.length) {\n\t          addRemoveClassName += ' ';\n\t        }\n\t        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n\t      }\n\t\n\t      // there may be a situation where a structural animation is combined together\n\t      // with CSS classes that need to resolve before the animation is computed.\n\t      // However this means that there is no explicit CSS code to block the animation\n\t      // from happening (by setting 0s none in the class name). If this is the case\n\t      // we need to apply the classes before the first rAF so we know to continue if\n\t      // there actually is a detected transition or keyframe animation\n\t      if (options.applyClassesEarly && addRemoveClassName.length) {\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n\t      var fullClassName = classes + ' ' + preparationClasses;\n\t      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n\t      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n\t      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\t\n\t      // there is no way we can trigger an animation if no styles and\n\t      // no classes are being applied which would then trigger a transition,\n\t      // unless there a is raw keyframe value that is applied to the element.\n\t      if (!containsKeyframeAnimation\n\t           && !hasToStyles\n\t           && !preparationClasses) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      var cacheKey, stagger;\n\t      if (options.stagger > 0) {\n\t        var staggerVal = parseFloat(options.stagger);\n\t        stagger = {\n\t          transitionDelay: staggerVal,\n\t          animationDelay: staggerVal,\n\t          transitionDuration: 0,\n\t          animationDuration: 0\n\t        };\n\t      } else {\n\t        cacheKey = gcsHashFn(node, fullClassName);\n\t        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n\t      }\n\t\n\t      if (!options.$$skipPreparationClasses) {\n\t        $$jqLite.addClass(element, preparationClasses);\n\t      }\n\t\n\t      var applyOnlyDuration;\n\t\n\t      if (options.transitionStyle) {\n\t        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n\t        applyInlineStyle(node, transitionStyle);\n\t        temporaryStyles.push(transitionStyle);\n\t      }\n\t\n\t      if (options.duration >= 0) {\n\t        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n\t        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\t\n\t        // we set the duration so that it will be picked up by getComputedStyle later\n\t        applyInlineStyle(node, durationStyle);\n\t        temporaryStyles.push(durationStyle);\n\t      }\n\t\n\t      if (options.keyframeStyle) {\n\t        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n\t        applyInlineStyle(node, keyframeStyle);\n\t        temporaryStyles.push(keyframeStyle);\n\t      }\n\t\n\t      var itemIndex = stagger\n\t          ? options.staggerIndex >= 0\n\t              ? options.staggerIndex\n\t              : gcsLookup.count(cacheKey)\n\t          : 0;\n\t\n\t      var isFirst = itemIndex === 0;\n\t\n\t      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n\t      // without causing any combination of transitions to kick in. By adding a negative delay value\n\t      // it forces the setup class' transition to end immediately. We later then remove the negative\n\t      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n\t      // that if there is no transition defined then nothing will happen and this will also allow\n\t      // other transitions to be stacked on top of each other without any chopping them out.\n\t      if (isFirst && !options.skipBlocking) {\n\t        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n\t      }\n\t\n\t      var timings = computeTimings(node, fullClassName, cacheKey);\n\t      var relativeDelay = timings.maxDelay;\n\t      maxDelay = Math.max(relativeDelay, 0);\n\t      maxDuration = timings.maxDuration;\n\t\n\t      var flags = {};\n\t      flags.hasTransitions          = timings.transitionDuration > 0;\n\t      flags.hasAnimations           = timings.animationDuration > 0;\n\t      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n\t      flags.applyTransitionDuration = hasToStyles && (\n\t                                        (flags.hasTransitions && !flags.hasTransitionAll)\n\t                                         || (flags.hasAnimations && !flags.hasTransitions));\n\t      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n\t      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n\t      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n\t      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\t\n\t      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n\t        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\t\n\t        if (flags.applyTransitionDuration) {\n\t          flags.hasTransitions = true;\n\t          timings.transitionDuration = maxDuration;\n\t          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n\t          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n\t        }\n\t\n\t        if (flags.applyAnimationDuration) {\n\t          flags.hasAnimations = true;\n\t          timings.animationDuration = maxDuration;\n\t          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n\t        }\n\t      }\n\t\n\t      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n\t        return closeAndReturnNoopAnimator();\n\t      }\n\t\n\t      if (options.delay != null) {\n\t        var delayStyle;\n\t        if (typeof options.delay !== \"boolean\") {\n\t          delayStyle = parseFloat(options.delay);\n\t          // number in options.delay means we have to recalculate the delay for the closing timeout\n\t          maxDelay = Math.max(delayStyle, 0);\n\t        }\n\t\n\t        if (flags.applyTransitionDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle));\n\t        }\n\t\n\t        if (flags.applyAnimationDelay) {\n\t          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n\t        }\n\t      }\n\t\n\t      // we need to recalculate the delay value since we used a pre-emptive negative\n\t      // delay value and the delay value is required for the final event checking. This\n\t      // property will ensure that this will happen after the RAF phase has passed.\n\t      if (options.duration == null && timings.transitionDuration > 0) {\n\t        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n\t      }\n\t\n\t      maxDelayTime = maxDelay * ONE_SECOND;\n\t      maxDurationTime = maxDuration * ONE_SECOND;\n\t      if (!options.skipBlocking) {\n\t        flags.blockTransition = timings.transitionDuration > 0;\n\t        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n\t                                       stagger.animationDelay > 0 &&\n\t                                       stagger.animationDuration === 0;\n\t      }\n\t\n\t      if (options.from) {\n\t        if (options.cleanupStyles) {\n\t          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n\t        }\n\t        applyAnimationFromStyles(element, options);\n\t      }\n\t\n\t      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n\t        applyBlocking(maxDuration);\n\t      } else if (!options.skipBlocking) {\n\t        blockTransitions(node, false);\n\t      }\n\t\n\t      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n\t      return {\n\t        $$willAnimate: true,\n\t        end: endFn,\n\t        start: function() {\n\t          if (animationClosed) return;\n\t\n\t          runnerHost = {\n\t            end: endFn,\n\t            cancel: cancelFn,\n\t            resume: null, //this will be set during the start() phase\n\t            pause: null\n\t          };\n\t\n\t          runner = new $$AnimateRunner(runnerHost);\n\t\n\t          waitUntilQuiet(start);\n\t\n\t          // we don't have access to pause/resume the animation\n\t          // since it hasn't run yet. AnimateRunner will therefore\n\t          // set noop functions for resume and pause and they will\n\t          // later be overridden once the animation is triggered\n\t          return runner;\n\t        }\n\t      };\n\t\n\t      function endFn() {\n\t        close();\n\t      }\n\t\n\t      function cancelFn() {\n\t        close(true);\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        // if the promise has been called already then we shouldn't close\n\t        // the animation again\n\t        if (animationClosed || (animationCompleted && animationPaused)) return;\n\t        animationClosed = true;\n\t        animationPaused = false;\n\t\n\t        if (!options.$$skipPreparationClasses) {\n\t          $$jqLite.removeClass(element, preparationClasses);\n\t        }\n\t        $$jqLite.removeClass(element, activeClasses);\n\t\n\t        blockKeyframeAnimations(node, false);\n\t        blockTransitions(node, false);\n\t\n\t        forEach(temporaryStyles, function(entry) {\n\t          // There is only one way to remove inline style properties entirely from elements.\n\t          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n\t          // styles down to hyphenated values.\n\t          node.style[entry[0]] = '';\n\t        });\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t\n\t        if (Object.keys(restoreStyles).length) {\n\t          forEach(restoreStyles, function(value, prop) {\n\t            value ? node.style.setProperty(prop, value)\n\t                  : node.style.removeProperty(prop);\n\t          });\n\t        }\n\t\n\t        // the reason why we have this option is to allow a synchronous closing callback\n\t        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n\t        // the animation never takes off at all. A good example is a leave animation since\n\t        // the element must be removed just after the animation is over or else the element\n\t        // will appear on screen for one animation frame causing an overbearing flicker.\n\t        if (options.onDone) {\n\t          options.onDone();\n\t        }\n\t\n\t        if (events && events.length) {\n\t          // Remove the transitionend / animationend listener(s)\n\t          element.off(events.join(' '), onAnimationProgress);\n\t        }\n\t\n\t        //Cancel the fallback closing timeout and remove the timer data\n\t        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n\t        if (animationTimerData) {\n\t          $timeout.cancel(animationTimerData[0].timer);\n\t          element.removeData(ANIMATE_TIMER_KEY);\n\t        }\n\t\n\t        // if the preparation function fails then the promise is not setup\n\t        if (runner) {\n\t          runner.complete(!rejected);\n\t        }\n\t      }\n\t\n\t      function applyBlocking(duration) {\n\t        if (flags.blockTransition) {\n\t          blockTransitions(node, duration);\n\t        }\n\t\n\t        if (flags.blockKeyframeAnimation) {\n\t          blockKeyframeAnimations(node, !!duration);\n\t        }\n\t      }\n\t\n\t      function closeAndReturnNoopAnimator() {\n\t        runner = new $$AnimateRunner({\n\t          end: endFn,\n\t          cancel: cancelFn\n\t        });\n\t\n\t        // should flush the cache animation\n\t        waitUntilQuiet(noop);\n\t        close();\n\t\n\t        return {\n\t          $$willAnimate: false,\n\t          start: function() {\n\t            return runner;\n\t          },\n\t          end: endFn\n\t        };\n\t      }\n\t\n\t      function onAnimationProgress(event) {\n\t        event.stopPropagation();\n\t        var ev = event.originalEvent || event;\n\t\n\t        // we now always use `Date.now()` due to the recent changes with\n\t        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n\t        var timeStamp = ev.$manualTimeStamp || Date.now();\n\t\n\t        /* Firefox (or possibly just Gecko) likes to not round values up\n\t         * when a ms measurement is used for the animation */\n\t        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\t\n\t        /* $manualTimeStamp is a mocked timeStamp value which is set\n\t         * within browserTrigger(). This is only here so that tests can\n\t         * mock animations properly. Real events fallback to event.timeStamp,\n\t         * or, if they don't, then a timeStamp is automatically created for them.\n\t         * We're checking to see if the timeStamp surpasses the expected delay,\n\t         * but we're using elapsedTime instead of the timeStamp on the 2nd\n\t         * pre-condition since animationPauseds sometimes close off early */\n\t        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n\t          // we set this flag to ensure that if the transition is paused then, when resumed,\n\t          // the animation will automatically close itself since transitions cannot be paused.\n\t          animationCompleted = true;\n\t          close();\n\t        }\n\t      }\n\t\n\t      function start() {\n\t        if (animationClosed) return;\n\t        if (!node.parentNode) {\n\t          close();\n\t          return;\n\t        }\n\t\n\t        // even though we only pause keyframe animations here the pause flag\n\t        // will still happen when transitions are used. Only the transition will\n\t        // not be paused since that is not possible. If the animation ends when\n\t        // paused then it will not complete until unpaused or cancelled.\n\t        var playPause = function(playAnimation) {\n\t          if (!animationCompleted) {\n\t            animationPaused = !playAnimation;\n\t            if (timings.animationDuration) {\n\t              var value = blockKeyframeAnimations(node, animationPaused);\n\t              animationPaused\n\t                  ? temporaryStyles.push(value)\n\t                  : removeFromArray(temporaryStyles, value);\n\t            }\n\t          } else if (animationPaused && playAnimation) {\n\t            animationPaused = false;\n\t            close();\n\t          }\n\t        };\n\t\n\t        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n\t        // being inherited from the parent. If the transition duration is zero then we can safely\n\t        // rely that the delay value is an intentional stagger delay style.\n\t        var maxStagger = itemIndex > 0\n\t                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n\t                            (timings.animationDuration && stagger.animationDuration === 0))\n\t                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n\t        if (maxStagger) {\n\t          $timeout(triggerAnimationStart,\n\t                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n\t                   false);\n\t        } else {\n\t          triggerAnimationStart();\n\t        }\n\t\n\t        // this will decorate the existing promise runner with pause/resume methods\n\t        runnerHost.resume = function() {\n\t          playPause(true);\n\t        };\n\t\n\t        runnerHost.pause = function() {\n\t          playPause(false);\n\t        };\n\t\n\t        function triggerAnimationStart() {\n\t          // just incase a stagger animation kicks in when the animation\n\t          // itself was cancelled entirely\n\t          if (animationClosed) return;\n\t\n\t          applyBlocking(false);\n\t\n\t          forEach(temporaryStyles, function(entry) {\n\t            var key = entry[0];\n\t            var value = entry[1];\n\t            node.style[key] = value;\n\t          });\n\t\n\t          applyAnimationClasses(element, options);\n\t          $$jqLite.addClass(element, activeClasses);\n\t\n\t          if (flags.recalculateTimingStyles) {\n\t            fullClassName = node.className + ' ' + preparationClasses;\n\t            cacheKey = gcsHashFn(node, fullClassName);\n\t\n\t            timings = computeTimings(node, fullClassName, cacheKey);\n\t            relativeDelay = timings.maxDelay;\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            maxDuration = timings.maxDuration;\n\t\n\t            if (maxDuration === 0) {\n\t              close();\n\t              return;\n\t            }\n\t\n\t            flags.hasTransitions = timings.transitionDuration > 0;\n\t            flags.hasAnimations = timings.animationDuration > 0;\n\t          }\n\t\n\t          if (flags.applyAnimationDelay) {\n\t            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n\t                  ? parseFloat(options.delay)\n\t                  : relativeDelay;\n\t\n\t            maxDelay = Math.max(relativeDelay, 0);\n\t            timings.animationDelay = relativeDelay;\n\t            delayStyle = getCssDelayStyle(relativeDelay, true);\n\t            temporaryStyles.push(delayStyle);\n\t            node.style[delayStyle[0]] = delayStyle[1];\n\t          }\n\t\n\t          maxDelayTime = maxDelay * ONE_SECOND;\n\t          maxDurationTime = maxDuration * ONE_SECOND;\n\t\n\t          if (options.easing) {\n\t            var easeProp, easeVal = options.easing;\n\t            if (flags.hasTransitions) {\n\t              easeProp = TRANSITION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t            if (flags.hasAnimations) {\n\t              easeProp = ANIMATION_PROP + TIMING_KEY;\n\t              temporaryStyles.push([easeProp, easeVal]);\n\t              node.style[easeProp] = easeVal;\n\t            }\n\t          }\n\t\n\t          if (timings.transitionDuration) {\n\t            events.push(TRANSITIONEND_EVENT);\n\t          }\n\t\n\t          if (timings.animationDuration) {\n\t            events.push(ANIMATIONEND_EVENT);\n\t          }\n\t\n\t          startTime = Date.now();\n\t          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n\t          var endTime = startTime + timerTime;\n\t\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n\t          var setupFallbackTimer = true;\n\t          if (animationsData.length) {\n\t            var currentTimerData = animationsData[0];\n\t            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n\t            if (setupFallbackTimer) {\n\t              $timeout.cancel(currentTimerData.timer);\n\t            } else {\n\t              animationsData.push(close);\n\t            }\n\t          }\n\t\n\t          if (setupFallbackTimer) {\n\t            var timer = $timeout(onAnimationExpired, timerTime, false);\n\t            animationsData[0] = {\n\t              timer: timer,\n\t              expectedEndTime: endTime\n\t            };\n\t            animationsData.push(close);\n\t            element.data(ANIMATE_TIMER_KEY, animationsData);\n\t          }\n\t\n\t          if (events.length) {\n\t            element.on(events.join(' '), onAnimationProgress);\n\t          }\n\t\n\t          if (options.to) {\n\t            if (options.cleanupStyles) {\n\t              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n\t            }\n\t            applyAnimationToStyles(element, options);\n\t          }\n\t        }\n\t\n\t        function onAnimationExpired() {\n\t          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\t\n\t          // this will be false in the event that the element was\n\t          // removed from the DOM (via a leave animation or something\n\t          // similar)\n\t          if (animationsData) {\n\t            for (var i = 1; i < animationsData.length; i++) {\n\t              animationsData[i]();\n\t            }\n\t            element.removeData(ANIMATE_TIMER_KEY);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\tvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateCssDriver');\n\t\n\t  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n\t  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\t\n\t  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n\t  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\t\n\t  function isDocumentFragment(node) {\n\t    return node.parentNode && node.parentNode.nodeType === 11;\n\t  }\n\t\n\t  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n\t       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\t\n\t    // only browsers that support these properties can render animations\n\t    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\t\n\t    var bodyNode = $document[0].body;\n\t    var rootNode = getDomNode($rootElement);\n\t\n\t    var rootBodyElement = jqLite(\n\t      // this is to avoid using something that exists outside of the body\n\t      // we also special case the doc fragment case because our unit test code\n\t      // appends the $rootElement to the body after the app has been bootstrapped\n\t      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n\t    );\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    return function initDriverFn(animationDetails) {\n\t      return animationDetails.from && animationDetails.to\n\t          ? prepareFromToAnchorAnimation(animationDetails.from,\n\t                                         animationDetails.to,\n\t                                         animationDetails.classes,\n\t                                         animationDetails.anchors)\n\t          : prepareRegularAnimation(animationDetails);\n\t    };\n\t\n\t    function filterCssClasses(classes) {\n\t      //remove all the `ng-` stuff\n\t      return classes.replace(/\\bng-\\S+\\b/g, '');\n\t    }\n\t\n\t    function getUniqueValues(a, b) {\n\t      if (isString(a)) a = a.split(' ');\n\t      if (isString(b)) b = b.split(' ');\n\t      return a.filter(function(val) {\n\t        return b.indexOf(val) === -1;\n\t      }).join(' ');\n\t    }\n\t\n\t    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n\t      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n\t      var startingClasses = filterCssClasses(getClassVal(clone));\n\t\n\t      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t\n\t      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\t\n\t      rootBodyElement.append(clone);\n\t\n\t      var animatorIn, animatorOut = prepareOutAnimation();\n\t\n\t      // the user may not end up using the `out` animation and\n\t      // only making use of the `in` animation or vice-versa.\n\t      // In either case we should allow this and not assume the\n\t      // animation is over unless both animations are not used.\n\t      if (!animatorOut) {\n\t        animatorIn = prepareInAnimation();\n\t        if (!animatorIn) {\n\t          return end();\n\t        }\n\t      }\n\t\n\t      var startingAnimator = animatorOut || animatorIn;\n\t\n\t      return {\n\t        start: function() {\n\t          var runner;\n\t\n\t          var currentAnimation = startingAnimator.start();\n\t          currentAnimation.done(function() {\n\t            currentAnimation = null;\n\t            if (!animatorIn) {\n\t              animatorIn = prepareInAnimation();\n\t              if (animatorIn) {\n\t                currentAnimation = animatorIn.start();\n\t                currentAnimation.done(function() {\n\t                  currentAnimation = null;\n\t                  end();\n\t                  runner.complete();\n\t                });\n\t                return currentAnimation;\n\t              }\n\t            }\n\t            // in the event that there is no `in` animation\n\t            end();\n\t            runner.complete();\n\t          });\n\t\n\t          runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            if (currentAnimation) {\n\t              currentAnimation.end();\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function calculateAnchorStyles(anchor) {\n\t        var styles = {};\n\t\n\t        var coords = getDomNode(anchor).getBoundingClientRect();\n\t\n\t        // we iterate directly since safari messes up and doesn't return\n\t        // all the keys for the coords object when iterated\n\t        forEach(['width','height','top','left'], function(key) {\n\t          var value = coords[key];\n\t          switch (key) {\n\t            case 'top':\n\t              value += bodyNode.scrollTop;\n\t              break;\n\t            case 'left':\n\t              value += bodyNode.scrollLeft;\n\t              break;\n\t          }\n\t          styles[key] = Math.floor(value) + 'px';\n\t        });\n\t        return styles;\n\t      }\n\t\n\t      function prepareOutAnimation() {\n\t        var animator = $animateCss(clone, {\n\t          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n\t          delay: true,\n\t          from: calculateAnchorStyles(outAnchor)\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function getClassVal(element) {\n\t        return element.attr('class') || '';\n\t      }\n\t\n\t      function prepareInAnimation() {\n\t        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n\t        var toAdd = getUniqueValues(endingClasses, startingClasses);\n\t        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\t\n\t        var animator = $animateCss(clone, {\n\t          to: calculateAnchorStyles(inAnchor),\n\t          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n\t          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n\t          delay: true\n\t        });\n\t\n\t        // read the comment within `prepareRegularAnimation` to understand\n\t        // why this check is necessary\n\t        return animator.$$willAnimate ? animator : null;\n\t      }\n\t\n\t      function end() {\n\t        clone.remove();\n\t        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\t      }\n\t    }\n\t\n\t    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n\t      var fromAnimation = prepareRegularAnimation(from, noop);\n\t      var toAnimation = prepareRegularAnimation(to, noop);\n\t\n\t      var anchorAnimations = [];\n\t      forEach(anchors, function(anchor) {\n\t        var outElement = anchor['out'];\n\t        var inElement = anchor['in'];\n\t        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n\t        if (animator) {\n\t          anchorAnimations.push(animator);\n\t        }\n\t      });\n\t\n\t      // no point in doing anything when there are no elements to animate\n\t      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\t\n\t      return {\n\t        start: function() {\n\t          var animationRunners = [];\n\t\n\t          if (fromAnimation) {\n\t            animationRunners.push(fromAnimation.start());\n\t          }\n\t\n\t          if (toAnimation) {\n\t            animationRunners.push(toAnimation.start());\n\t          }\n\t\n\t          forEach(anchorAnimations, function(animation) {\n\t            animationRunners.push(animation.start());\n\t          });\n\t\n\t          var runner = new $$AnimateRunner({\n\t            end: endFn,\n\t            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n\t          });\n\t\n\t          $$AnimateRunner.all(animationRunners, function(status) {\n\t            runner.complete(status);\n\t          });\n\t\n\t          return runner;\n\t\n\t          function endFn() {\n\t            forEach(animationRunners, function(runner) {\n\t              runner.end();\n\t            });\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    function prepareRegularAnimation(animationDetails) {\n\t      var element = animationDetails.element;\n\t      var options = animationDetails.options || {};\n\t\n\t      if (animationDetails.structural) {\n\t        options.event = animationDetails.event;\n\t        options.structural = true;\n\t        options.applyClassesEarly = true;\n\t\n\t        // we special case the leave animation since we want to ensure that\n\t        // the element is removed as soon as the animation is over. Otherwise\n\t        // a flicker might appear or the element may not be removed at all\n\t        if (animationDetails.event === 'leave') {\n\t          options.onDone = options.domOperation;\n\t        }\n\t      }\n\t\n\t      // We assign the preparationClasses as the actual animation event since\n\t      // the internals of $animateCss will just suffix the event token values\n\t      // with `-active` to trigger the animation.\n\t      if (options.preparationClasses) {\n\t        options.event = concatWithSpace(options.event, options.preparationClasses);\n\t      }\n\t\n\t      var animator = $animateCss(element, options);\n\t\n\t      // the driver lookup code inside of $$animation attempts to spawn a\n\t      // driver one by one until a driver returns a.$$willAnimate animator object.\n\t      // $animateCss will always return an object, however, it will pass in\n\t      // a flag as a hint as to whether an animation was detected or not\n\t      return animator.$$willAnimate ? animator : null;\n\t    }\n\t  }];\n\t}];\n\t\n\t// TODO(matsko): use caching here to speed things up for detection\n\t// TODO(matsko): add documentation\n\t//  by the time...\n\t\n\tvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n\t  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n\t       function($injector,   $$AnimateRunner,   $$jqLite) {\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t         // $animateJs(element, 'enter');\n\t    return function(element, event, classes, options) {\n\t      var animationClosed = false;\n\t\n\t      // the `classes` argument is optional and if it is not used\n\t      // then the classes will be resolved from the element's className\n\t      // property as well as options.addClass/options.removeClass.\n\t      if (arguments.length === 3 && isObject(classes)) {\n\t        options = classes;\n\t        classes = null;\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t      if (!classes) {\n\t        classes = element.attr('class') || '';\n\t        if (options.addClass) {\n\t          classes += ' ' + options.addClass;\n\t        }\n\t        if (options.removeClass) {\n\t          classes += ' ' + options.removeClass;\n\t        }\n\t      }\n\t\n\t      var classesToAdd = options.addClass;\n\t      var classesToRemove = options.removeClass;\n\t\n\t      // the lookupAnimations function returns a series of animation objects that are\n\t      // matched up with one or more of the CSS classes. These animation objects are\n\t      // defined via the module.animation factory function. If nothing is detected then\n\t      // we don't return anything which then makes $animation query the next driver.\n\t      var animations = lookupAnimations(classes);\n\t      var before, after;\n\t      if (animations.length) {\n\t        var afterFn, beforeFn;\n\t        if (event == 'leave') {\n\t          beforeFn = 'leave';\n\t          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n\t        } else {\n\t          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n\t          afterFn = event;\n\t        }\n\t\n\t        if (event !== 'enter' && event !== 'move') {\n\t          before = packageAnimations(element, event, options, animations, beforeFn);\n\t        }\n\t        after  = packageAnimations(element, event, options, animations, afterFn);\n\t      }\n\t\n\t      // no matching animations\n\t      if (!before && !after) return;\n\t\n\t      function applyOptions() {\n\t        options.domOperation();\n\t        applyAnimationClasses(element, options);\n\t      }\n\t\n\t      function close() {\n\t        animationClosed = true;\n\t        applyOptions();\n\t        applyAnimationStyles(element, options);\n\t      }\n\t\n\t      var runner;\n\t\n\t      return {\n\t        $$willAnimate: true,\n\t        end: function() {\n\t          if (runner) {\n\t            runner.end();\n\t          } else {\n\t            close();\n\t            runner = new $$AnimateRunner();\n\t            runner.complete(true);\n\t          }\n\t          return runner;\n\t        },\n\t        start: function() {\n\t          if (runner) {\n\t            return runner;\n\t          }\n\t\n\t          runner = new $$AnimateRunner();\n\t          var closeActiveAnimations;\n\t          var chain = [];\n\t\n\t          if (before) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = before(fn);\n\t            });\n\t          }\n\t\n\t          if (chain.length) {\n\t            chain.push(function(fn) {\n\t              applyOptions();\n\t              fn(true);\n\t            });\n\t          } else {\n\t            applyOptions();\n\t          }\n\t\n\t          if (after) {\n\t            chain.push(function(fn) {\n\t              closeActiveAnimations = after(fn);\n\t            });\n\t          }\n\t\n\t          runner.setHost({\n\t            end: function() {\n\t              endAnimations();\n\t            },\n\t            cancel: function() {\n\t              endAnimations(true);\n\t            }\n\t          });\n\t\n\t          $$AnimateRunner.chain(chain, onComplete);\n\t          return runner;\n\t\n\t          function onComplete(success) {\n\t            close(success);\n\t            runner.complete(success);\n\t          }\n\t\n\t          function endAnimations(cancelled) {\n\t            if (!animationClosed) {\n\t              (closeActiveAnimations || noop)(cancelled);\n\t              onComplete(cancelled);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      function executeAnimationFn(fn, element, event, options, onDone) {\n\t        var args;\n\t        switch (event) {\n\t          case 'animate':\n\t            args = [element, options.from, options.to, onDone];\n\t            break;\n\t\n\t          case 'setClass':\n\t            args = [element, classesToAdd, classesToRemove, onDone];\n\t            break;\n\t\n\t          case 'addClass':\n\t            args = [element, classesToAdd, onDone];\n\t            break;\n\t\n\t          case 'removeClass':\n\t            args = [element, classesToRemove, onDone];\n\t            break;\n\t\n\t          default:\n\t            args = [element, onDone];\n\t            break;\n\t        }\n\t\n\t        args.push(options);\n\t\n\t        var value = fn.apply(fn, args);\n\t        if (value) {\n\t          if (isFunction(value.start)) {\n\t            value = value.start();\n\t          }\n\t\n\t          if (value instanceof $$AnimateRunner) {\n\t            value.done(onDone);\n\t          } else if (isFunction(value)) {\n\t            // optional onEnd / onCancel callback\n\t            return value;\n\t          }\n\t        }\n\t\n\t        return noop;\n\t      }\n\t\n\t      function groupEventedAnimations(element, event, options, animations, fnName) {\n\t        var operations = [];\n\t        forEach(animations, function(ani) {\n\t          var animation = ani[fnName];\n\t          if (!animation) return;\n\t\n\t          // note that all of these animations will run in parallel\n\t          operations.push(function() {\n\t            var runner;\n\t            var endProgressCb;\n\t\n\t            var resolved = false;\n\t            var onAnimationComplete = function(rejected) {\n\t              if (!resolved) {\n\t                resolved = true;\n\t                (endProgressCb || noop)(rejected);\n\t                runner.complete(!rejected);\n\t              }\n\t            };\n\t\n\t            runner = new $$AnimateRunner({\n\t              end: function() {\n\t                onAnimationComplete();\n\t              },\n\t              cancel: function() {\n\t                onAnimationComplete(true);\n\t              }\n\t            });\n\t\n\t            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n\t              var cancelled = result === false;\n\t              onAnimationComplete(cancelled);\n\t            });\n\t\n\t            return runner;\n\t          });\n\t        });\n\t\n\t        return operations;\n\t      }\n\t\n\t      function packageAnimations(element, event, options, animations, fnName) {\n\t        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n\t        if (operations.length === 0) {\n\t          var a,b;\n\t          if (fnName === 'beforeSetClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n\t          } else if (fnName === 'setClass') {\n\t            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n\t            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n\t          }\n\t\n\t          if (a) {\n\t            operations = operations.concat(a);\n\t          }\n\t          if (b) {\n\t            operations = operations.concat(b);\n\t          }\n\t        }\n\t\n\t        if (operations.length === 0) return;\n\t\n\t        // TODO(matsko): add documentation\n\t        return function startAnimation(callback) {\n\t          var runners = [];\n\t          if (operations.length) {\n\t            forEach(operations, function(animateFn) {\n\t              runners.push(animateFn());\n\t            });\n\t          }\n\t\n\t          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\t\n\t          return function endFn(reject) {\n\t            forEach(runners, function(runner) {\n\t              reject ? runner.cancel() : runner.end();\n\t            });\n\t          };\n\t        };\n\t      }\n\t    };\n\t\n\t    function lookupAnimations(classes) {\n\t      classes = isArray(classes) ? classes : classes.split(' ');\n\t      var matches = [], flagMap = {};\n\t      for (var i=0; i < classes.length; i++) {\n\t        var klass = classes[i],\n\t            animationFactory = $animateProvider.$$registeredAnimations[klass];\n\t        if (animationFactory && !flagMap[klass]) {\n\t          matches.push($injector.get(animationFactory));\n\t          flagMap[klass] = true;\n\t        }\n\t      }\n\t      return matches;\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n\t  $$animationProvider.drivers.push('$$animateJsDriver');\n\t  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n\t    return function initDriverFn(animationDetails) {\n\t      if (animationDetails.from && animationDetails.to) {\n\t        var fromAnimation = prepareAnimation(animationDetails.from);\n\t        var toAnimation = prepareAnimation(animationDetails.to);\n\t        if (!fromAnimation && !toAnimation) return;\n\t\n\t        return {\n\t          start: function() {\n\t            var animationRunners = [];\n\t\n\t            if (fromAnimation) {\n\t              animationRunners.push(fromAnimation.start());\n\t            }\n\t\n\t            if (toAnimation) {\n\t              animationRunners.push(toAnimation.start());\n\t            }\n\t\n\t            $$AnimateRunner.all(animationRunners, done);\n\t\n\t            var runner = new $$AnimateRunner({\n\t              end: endFnFactory(),\n\t              cancel: endFnFactory()\n\t            });\n\t\n\t            return runner;\n\t\n\t            function endFnFactory() {\n\t              return function() {\n\t                forEach(animationRunners, function(runner) {\n\t                  // at this point we cannot cancel animations for groups just yet. 1.5+\n\t                  runner.end();\n\t                });\n\t              };\n\t            }\n\t\n\t            function done(status) {\n\t              runner.complete(status);\n\t            }\n\t          }\n\t        };\n\t      } else {\n\t        return prepareAnimation(animationDetails);\n\t      }\n\t    };\n\t\n\t    function prepareAnimation(animationDetails) {\n\t      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n\t      var element = animationDetails.element;\n\t      var event = animationDetails.event;\n\t      var options = animationDetails.options;\n\t      var classes = animationDetails.classes;\n\t      return $$animateJs(element, event, classes, options);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\n\tvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\n\tvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n\t  var PRE_DIGEST_STATE = 1;\n\t  var RUNNING_STATE = 2;\n\t  var ONE_SPACE = ' ';\n\t\n\t  var rules = this.rules = {\n\t    skip: [],\n\t    cancel: [],\n\t    join: []\n\t  };\n\t\n\t  function makeTruthyCssClassMap(classString) {\n\t    if (!classString) {\n\t      return null;\n\t    }\n\t\n\t    var keys = classString.split(ONE_SPACE);\n\t    var map = Object.create(null);\n\t\n\t    forEach(keys, function(key) {\n\t      map[key] = true;\n\t    });\n\t    return map;\n\t  }\n\t\n\t  function hasMatchingClasses(newClassString, currentClassString) {\n\t    if (newClassString && currentClassString) {\n\t      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n\t      return newClassString.split(ONE_SPACE).some(function(className) {\n\t        return currentClassMap[className];\n\t      });\n\t    }\n\t  }\n\t\n\t  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n\t    return rules[ruleType].some(function(fn) {\n\t      return fn(element, currentAnimation, previousAnimation);\n\t    });\n\t  }\n\t\n\t  function hasAnimationClasses(animation, and) {\n\t    var a = (animation.addClass || '').length > 0;\n\t    var b = (animation.removeClass || '').length > 0;\n\t    return and ? a && b : a || b;\n\t  }\n\t\n\t  rules.join.push(function(element, newAnimation, currentAnimation) {\n\t    // if the new animation is class-based then we can just tack that on\n\t    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // there is no need to animate anything if no classes are being added and\n\t    // there is no structural animation that will be triggered\n\t    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // why should we trigger a new structural animation if the element will\n\t    // be removed from the DOM anyway?\n\t    return currentAnimation.event == 'leave' && newAnimation.structural;\n\t  });\n\t\n\t  rules.skip.push(function(element, newAnimation, currentAnimation) {\n\t    // if there is an ongoing current animation then don't even bother running the class-based animation\n\t    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // there can never be two structural animations running at the same time\n\t    return currentAnimation.structural && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // if the previous animation is already running, but the new animation will\n\t    // be triggered, but the new animation is structural\n\t    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n\t  });\n\t\n\t  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n\t    // cancel the animation if classes added / removed in both animation cancel each other out,\n\t    // but only if the current animation isn't structural\n\t\n\t    if (currentAnimation.structural) return false;\n\t\n\t    var nA = newAnimation.addClass;\n\t    var nR = newAnimation.removeClass;\n\t    var cA = currentAnimation.addClass;\n\t    var cR = currentAnimation.removeClass;\n\t\n\t    // early detection to save the global CPU shortage :)\n\t    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n\t      return false;\n\t    }\n\t\n\t    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n\t  });\n\t\n\t  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n\t               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n\t       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n\t                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\t\n\t    var activeAnimationsLookup = new $$HashMap();\n\t    var disabledElementsLookup = new $$HashMap();\n\t    var animationsEnabled = null;\n\t\n\t    function postDigestTaskFactory() {\n\t      var postDigestCalled = false;\n\t      return function(fn) {\n\t        // we only issue a call to postDigest before\n\t        // it has first passed. This prevents any callbacks\n\t        // from not firing once the animation has completed\n\t        // since it will be out of the digest cycle.\n\t        if (postDigestCalled) {\n\t          fn();\n\t        } else {\n\t          $rootScope.$$postDigest(function() {\n\t            postDigestCalled = true;\n\t            fn();\n\t          });\n\t        }\n\t      };\n\t    }\n\t\n\t    // Wait until all directive and route-related templates are downloaded and\n\t    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n\t    // all of the remote templates being currently downloaded. If there are no\n\t    // templates currently downloading then the watcher will still fire anyway.\n\t    var deregisterWatch = $rootScope.$watch(\n\t      function() { return $templateRequest.totalPendingRequests === 0; },\n\t      function(isEmpty) {\n\t        if (!isEmpty) return;\n\t        deregisterWatch();\n\t\n\t        // Now that all templates have been downloaded, $animate will wait until\n\t        // the post digest queue is empty before enabling animations. By having two\n\t        // calls to $postDigest calls we can ensure that the flag is enabled at the\n\t        // very end of the post digest queue. Since all of the animations in $animate\n\t        // use $postDigest, it's important that the code below executes at the end.\n\t        // This basically means that the page is fully downloaded and compiled before\n\t        // any animations are triggered.\n\t        $rootScope.$$postDigest(function() {\n\t          $rootScope.$$postDigest(function() {\n\t            // we check for null directly in the event that the application already called\n\t            // .enabled() with whatever arguments that it provided it with\n\t            if (animationsEnabled === null) {\n\t              animationsEnabled = true;\n\t            }\n\t          });\n\t        });\n\t      }\n\t    );\n\t\n\t    var callbackRegistry = {};\n\t\n\t    // remember that the classNameFilter is set during the provider/config\n\t    // stage therefore we can optimize here and setup a helper function\n\t    var classNameFilter = $animateProvider.classNameFilter();\n\t    var isAnimatableClassName = !classNameFilter\n\t              ? function() { return true; }\n\t              : function(className) {\n\t                return classNameFilter.test(className);\n\t              };\n\t\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function normalizeAnimationDetails(element, animation) {\n\t      return mergeAnimationDetails(element, animation, {});\n\t    }\n\t\n\t    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n\t    var contains = window.Node.prototype.contains || function(arg) {\n\t      // jshint bitwise: false\n\t      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n\t      // jshint bitwise: true\n\t    };\n\t\n\t    function findCallbacks(parent, element, event) {\n\t      var targetNode = getDomNode(element);\n\t      var targetParentNode = getDomNode(parent);\n\t\n\t      var matches = [];\n\t      var entries = callbackRegistry[event];\n\t      if (entries) {\n\t        forEach(entries, function(entry) {\n\t          if (contains.call(entry.node, targetNode)) {\n\t            matches.push(entry.callback);\n\t          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n\t            matches.push(entry.callback);\n\t          }\n\t        });\n\t      }\n\t\n\t      return matches;\n\t    }\n\t\n\t    function filterFromRegistry(list, matchContainer, matchCallback) {\n\t      var containerNode = extractElementNode(matchContainer);\n\t      return list.filter(function(entry) {\n\t        var isMatch = entry.node === containerNode &&\n\t                        (!matchCallback || entry.callback === matchCallback);\n\t        return !isMatch;\n\t      });\n\t    }\n\t\n\t    function cleanupEventListeners(phase, element) {\n\t      if (phase === 'close' && !element[0].parentNode) {\n\t        // If the element is not attached to a parentNode, it has been removed by\n\t        // the domOperation, and we can safely remove the event callbacks\n\t        $animate.off(element);\n\t      }\n\t    }\n\t\n\t    var $animate = {\n\t      on: function(event, container, callback) {\n\t        var node = extractElementNode(container);\n\t        callbackRegistry[event] = callbackRegistry[event] || [];\n\t        callbackRegistry[event].push({\n\t          node: node,\n\t          callback: callback\n\t        });\n\t\n\t        // Remove the callback when the element is removed from the DOM\n\t        jqLite(container).on('$destroy', function() {\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t\n\t          if (!animationDetails) {\n\t            // If there's an animation ongoing, the callback calling code will remove\n\t            // the event listeners. If we'd remove here, the callbacks would be removed\n\t            // before the animation ends\n\t            $animate.off(event, container, callback);\n\t          }\n\t        });\n\t      },\n\t\n\t      off: function(event, container, callback) {\n\t        if (arguments.length === 1 && !angular.isString(arguments[0])) {\n\t          container = arguments[0];\n\t          for (var eventType in callbackRegistry) {\n\t            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        var entries = callbackRegistry[event];\n\t        if (!entries) return;\n\t\n\t        callbackRegistry[event] = arguments.length === 1\n\t            ? null\n\t            : filterFromRegistry(entries, container, callback);\n\t      },\n\t\n\t      pin: function(element, parentElement) {\n\t        assertArg(isElement(element), 'element', 'not an element');\n\t        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n\t        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n\t      },\n\t\n\t      push: function(element, event, options, domOperation) {\n\t        options = options || {};\n\t        options.domOperation = domOperation;\n\t        return queueAnimation(element, event, options);\n\t      },\n\t\n\t      // this method has four signatures:\n\t      //  () - global getter\n\t      //  (bool) - global setter\n\t      //  (element) - element getter\n\t      //  (element, bool) - element setter<F37>\n\t      enabled: function(element, bool) {\n\t        var argCount = arguments.length;\n\t\n\t        if (argCount === 0) {\n\t          // () - Global getter\n\t          bool = !!animationsEnabled;\n\t        } else {\n\t          var hasElement = isElement(element);\n\t\n\t          if (!hasElement) {\n\t            // (bool) - Global setter\n\t            bool = animationsEnabled = !!element;\n\t          } else {\n\t            var node = getDomNode(element);\n\t            var recordExists = disabledElementsLookup.get(node);\n\t\n\t            if (argCount === 1) {\n\t              // (element) - Element getter\n\t              bool = !recordExists;\n\t            } else {\n\t              // (element, bool) - Element setter\n\t              disabledElementsLookup.put(node, !bool);\n\t            }\n\t          }\n\t        }\n\t\n\t        return bool;\n\t      }\n\t    };\n\t\n\t    return $animate;\n\t\n\t    function queueAnimation(element, event, initialOptions) {\n\t      // we always make a copy of the options since\n\t      // there should never be any side effects on\n\t      // the input data when running `$animateCss`.\n\t      var options = copy(initialOptions);\n\t\n\t      var node, parent;\n\t      element = stripCommentsFromElement(element);\n\t      if (element) {\n\t        node = getDomNode(element);\n\t        parent = element.parent();\n\t      }\n\t\n\t      options = prepareAnimationOptions(options);\n\t\n\t      // we create a fake runner with a working promise.\n\t      // These methods will become available after the digest has passed\n\t      var runner = new $$AnimateRunner();\n\t\n\t      // this is used to trigger callbacks in postDigest mode\n\t      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\t\n\t      if (isArray(options.addClass)) {\n\t        options.addClass = options.addClass.join(' ');\n\t      }\n\t\n\t      if (options.addClass && !isString(options.addClass)) {\n\t        options.addClass = null;\n\t      }\n\t\n\t      if (isArray(options.removeClass)) {\n\t        options.removeClass = options.removeClass.join(' ');\n\t      }\n\t\n\t      if (options.removeClass && !isString(options.removeClass)) {\n\t        options.removeClass = null;\n\t      }\n\t\n\t      if (options.from && !isObject(options.from)) {\n\t        options.from = null;\n\t      }\n\t\n\t      if (options.to && !isObject(options.to)) {\n\t        options.to = null;\n\t      }\n\t\n\t      // there are situations where a directive issues an animation for\n\t      // a jqLite wrapper that contains only comment nodes... If this\n\t      // happens then there is no way we can perform an animation\n\t      if (!node) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var className = [node.className, options.addClass, options.removeClass].join(' ');\n\t      if (!isAnimatableClassName(className)) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      var documentHidden = $document[0].hidden;\n\t\n\t      // this is a hard disable of all animations for the application or on\n\t      // the element itself, therefore  there is no need to continue further\n\t      // past this point if not enabled\n\t      // Animations are also disabled if the document is currently hidden (page is not visible\n\t      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n\t      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n\t      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n\t      var hasExistingAnimation = !!existingAnimation.state;\n\t\n\t      // there is no point in traversing the same collection of parent ancestors if a followup\n\t      // animation will be run on the same element that already did all that checking work\n\t      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n\t        skipAnimations = !areAnimationsAllowed(element, parent, event);\n\t      }\n\t\n\t      if (skipAnimations) {\n\t        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n\t        if (documentHidden) notifyProgress(runner, event, 'start');\n\t        close();\n\t        if (documentHidden) notifyProgress(runner, event, 'close');\n\t        return runner;\n\t      }\n\t\n\t      if (isStructural) {\n\t        closeChildAnimations(element);\n\t      }\n\t\n\t      var newAnimation = {\n\t        structural: isStructural,\n\t        element: element,\n\t        event: event,\n\t        addClass: options.addClass,\n\t        removeClass: options.removeClass,\n\t        close: close,\n\t        options: options,\n\t        runner: runner\n\t      };\n\t\n\t      if (hasExistingAnimation) {\n\t        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n\t        if (skipAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            close();\n\t            return runner;\n\t          } else {\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t            return existingAnimation.runner;\n\t          }\n\t        }\n\t        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n\t        if (cancelAnimationFlag) {\n\t          if (existingAnimation.state === RUNNING_STATE) {\n\t            // this will end the animation right away and it is safe\n\t            // to do so since the animation is already running and the\n\t            // runner callback code will run in async\n\t            existingAnimation.runner.end();\n\t          } else if (existingAnimation.structural) {\n\t            // this means that the animation is queued into a digest, but\n\t            // hasn't started yet. Therefore it is safe to run the close\n\t            // method which will call the runner methods in async.\n\t            existingAnimation.close();\n\t          } else {\n\t            // this will merge the new animation options into existing animation options\n\t            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t            return existingAnimation.runner;\n\t          }\n\t        } else {\n\t          // a joined animation means that this animation will take over the existing one\n\t          // so an example would involve a leave animation taking over an enter. Then when\n\t          // the postDigest kicks in the enter will be ignored.\n\t          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n\t          if (joinAnimationFlag) {\n\t            if (existingAnimation.state === RUNNING_STATE) {\n\t              normalizeAnimationDetails(element, newAnimation);\n\t            } else {\n\t              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\t\n\t              event = newAnimation.event = existingAnimation.event;\n\t              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\t\n\t              //we return the same runner since only the option values of this animation will\n\t              //be fed into the `existingAnimation`.\n\t              return existingAnimation.runner;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        // normalization in this case means that it removes redundant CSS classes that\n\t        // already exist (addClass) or do not exist (removeClass) on the element\n\t        normalizeAnimationDetails(element, newAnimation);\n\t      }\n\t\n\t      // when the options are merged and cleaned up we may end up not having to do\n\t      // an animation at all, therefore we should check this before issuing a post\n\t      // digest callback. Structural animations will always run no matter what.\n\t      var isValidAnimation = newAnimation.structural;\n\t      if (!isValidAnimation) {\n\t        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n\t        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n\t                            || hasAnimationClasses(newAnimation);\n\t      }\n\t\n\t      if (!isValidAnimation) {\n\t        close();\n\t        clearElementAnimationState(element);\n\t        return runner;\n\t      }\n\t\n\t      // the counter keeps track of cancelled animations\n\t      var counter = (existingAnimation.counter || 0) + 1;\n\t      newAnimation.counter = counter;\n\t\n\t      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animationDetails = activeAnimationsLookup.get(node);\n\t        var animationCancelled = !animationDetails;\n\t        animationDetails = animationDetails || {};\n\t\n\t        // if addClass/removeClass is called before something like enter then the\n\t        // registered parent element may not be present. The code below will ensure\n\t        // that a final value for parent element is obtained\n\t        var parentElement = element.parent() || [];\n\t\n\t        // animate/structural/class-based animations all have requirements. Otherwise there\n\t        // is no point in performing an animation. The parent node must also be set.\n\t        var isValidAnimation = parentElement.length > 0\n\t                                && (animationDetails.event === 'animate'\n\t                                    || animationDetails.structural\n\t                                    || hasAnimationClasses(animationDetails));\n\t\n\t        // this means that the previous animation was cancelled\n\t        // even if the follow-up animation is the same event\n\t        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n\t          // if another animation did not take over then we need\n\t          // to make sure that the domOperation and options are\n\t          // handled accordingly\n\t          if (animationCancelled) {\n\t            applyAnimationClasses(element, options);\n\t            applyAnimationStyles(element, options);\n\t          }\n\t\n\t          // if the event changed from something like enter to leave then we do\n\t          // it, otherwise if it's the same then the end result will be the same too\n\t          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n\t            options.domOperation();\n\t            runner.end();\n\t          }\n\t\n\t          // in the event that the element animation was not cancelled or a follow-up animation\n\t          // isn't allowed to animate from here then we need to clear the state of the element\n\t          // so that any future animations won't read the expired animation data.\n\t          if (!isValidAnimation) {\n\t            clearElementAnimationState(element);\n\t          }\n\t\n\t          return;\n\t        }\n\t\n\t        // this combined multiple class to addClass / removeClass into a setClass event\n\t        // so long as a structural event did not take over the animation\n\t        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n\t            ? 'setClass'\n\t            : animationDetails.event;\n\t\n\t        markElementAnimationState(element, RUNNING_STATE);\n\t        var realRunner = $$animation(element, event, animationDetails.options);\n\t\n\t        // this will update the runner's flow-control events based on\n\t        // the `realRunner` object.\n\t        runner.setHost(realRunner);\n\t        notifyProgress(runner, event, 'start', {});\n\t\n\t        realRunner.done(function(status) {\n\t          close(!status);\n\t          var animationDetails = activeAnimationsLookup.get(node);\n\t          if (animationDetails && animationDetails.counter === counter) {\n\t            clearElementAnimationState(getDomNode(element));\n\t          }\n\t          notifyProgress(runner, event, 'close', {});\n\t        });\n\t      });\n\t\n\t      return runner;\n\t\n\t      function notifyProgress(runner, event, phase, data) {\n\t        runInNextPostDigestOrNow(function() {\n\t          var callbacks = findCallbacks(parent, element, event);\n\t          if (callbacks.length) {\n\t            // do not optimize this call here to RAF because\n\t            // we don't know how heavy the callback code here will\n\t            // be and if this code is buffered then this can\n\t            // lead to a performance regression.\n\t            $$rAF(function() {\n\t              forEach(callbacks, function(callback) {\n\t                callback(element, phase, data);\n\t              });\n\t              cleanupEventListeners(phase, element);\n\t            });\n\t          } else {\n\t            cleanupEventListeners(phase, element);\n\t          }\n\t        });\n\t        runner.progress(event, phase, data);\n\t      }\n\t\n\t      function close(reject) { // jshint ignore:line\n\t        clearGeneratedClasses(element, options);\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t        runner.complete(!reject);\n\t      }\n\t    }\n\t\n\t    function closeChildAnimations(element) {\n\t      var node = getDomNode(element);\n\t      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n\t      forEach(children, function(child) {\n\t        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n\t        var animationDetails = activeAnimationsLookup.get(child);\n\t        if (animationDetails) {\n\t          switch (state) {\n\t            case RUNNING_STATE:\n\t              animationDetails.runner.end();\n\t              /* falls through */\n\t            case PRE_DIGEST_STATE:\n\t              activeAnimationsLookup.remove(child);\n\t              break;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    function clearElementAnimationState(element) {\n\t      var node = getDomNode(element);\n\t      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n\t      activeAnimationsLookup.remove(node);\n\t    }\n\t\n\t    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n\t      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n\t    }\n\t\n\t    /**\n\t     * This fn returns false if any of the following is true:\n\t     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n\t     * b) a parent element has an ongoing structural animation, and animateChildren is false\n\t     * c) the element is not a child of the body\n\t     * d) the element is not a child of the $rootElement\n\t     */\n\t    function areAnimationsAllowed(element, parentElement, event) {\n\t      var bodyElement = jqLite($document[0].body);\n\t      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n\t      var rootElementDetected = isMatchingElement(element, $rootElement);\n\t      var parentAnimationDetected = false;\n\t      var animateChildren;\n\t      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\t\n\t      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n\t      if (parentHost) {\n\t        parentElement = parentHost;\n\t      }\n\t\n\t      parentElement = getDomNode(parentElement);\n\t\n\t      while (parentElement) {\n\t        if (!rootElementDetected) {\n\t          // angular doesn't want to attempt to animate elements outside of the application\n\t          // therefore we need to ensure that the rootElement is an ancestor of the current element\n\t          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n\t        }\n\t\n\t        if (parentElement.nodeType !== ELEMENT_NODE) {\n\t          // no point in inspecting the #document element\n\t          break;\n\t        }\n\t\n\t        var details = activeAnimationsLookup.get(parentElement) || {};\n\t        // either an enter, leave or move animation will commence\n\t        // therefore we can't allow any animations to take place\n\t        // but if a parent animation is class-based then that's ok\n\t        if (!parentAnimationDetected) {\n\t          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\t\n\t          if (parentElementDisabled === true && elementDisabled !== false) {\n\t            // disable animations if the user hasn't explicitly enabled animations on the\n\t            // current element\n\t            elementDisabled = true;\n\t            // element is disabled via parent element, no need to check anything else\n\t            break;\n\t          } else if (parentElementDisabled === false) {\n\t            elementDisabled = false;\n\t          }\n\t          parentAnimationDetected = details.structural;\n\t        }\n\t\n\t        if (isUndefined(animateChildren) || animateChildren === true) {\n\t          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n\t          if (isDefined(value)) {\n\t            animateChildren = value;\n\t          }\n\t        }\n\t\n\t        // there is no need to continue traversing at this point\n\t        if (parentAnimationDetected && animateChildren === false) break;\n\t\n\t        if (!bodyElementDetected) {\n\t          // we also need to ensure that the element is or will be a part of the body element\n\t          // otherwise it is pointless to even issue an animation to be rendered\n\t          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n\t        }\n\t\n\t        if (bodyElementDetected && rootElementDetected) {\n\t          // If both body and root have been found, any other checks are pointless,\n\t          // as no animation data should live outside the application\n\t          break;\n\t        }\n\t\n\t        if (!rootElementDetected) {\n\t          // If no rootElement is detected, check if the parentElement is pinned to another element\n\t          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n\t          if (parentHost) {\n\t            // The pin target element becomes the next parent element\n\t            parentElement = getDomNode(parentHost);\n\t            continue;\n\t          }\n\t        }\n\t\n\t        parentElement = parentElement.parentNode;\n\t      }\n\t\n\t      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n\t      return allowAnimation && rootElementDetected && bodyElementDetected;\n\t    }\n\t\n\t    function markElementAnimationState(element, state, details) {\n\t      details = details || {};\n\t      details.state = state;\n\t\n\t      var node = getDomNode(element);\n\t      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\t\n\t      var oldValue = activeAnimationsLookup.get(node);\n\t      var newValue = oldValue\n\t          ? extend(oldValue, details)\n\t          : details;\n\t      activeAnimationsLookup.put(node, newValue);\n\t    }\n\t  }];\n\t}];\n\t\n\tvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n\t  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\t\n\t  var drivers = this.drivers = [];\n\t\n\t  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\t\n\t  function setRunner(element, runner) {\n\t    element.data(RUNNER_STORAGE_KEY, runner);\n\t  }\n\t\n\t  function removeRunner(element) {\n\t    element.removeData(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  function getRunner(element) {\n\t    return element.data(RUNNER_STORAGE_KEY);\n\t  }\n\t\n\t  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n\t       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\t\n\t    var animationQueue = [];\n\t    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\t\n\t    function sortAnimations(animations) {\n\t      var tree = { children: [] };\n\t      var i, lookup = new $$HashMap();\n\t\n\t      // this is done first beforehand so that the hashmap\n\t      // is filled with a list of the elements that will be animated\n\t      for (i = 0; i < animations.length; i++) {\n\t        var animation = animations[i];\n\t        lookup.put(animation.domNode, animations[i] = {\n\t          domNode: animation.domNode,\n\t          fn: animation.fn,\n\t          children: []\n\t        });\n\t      }\n\t\n\t      for (i = 0; i < animations.length; i++) {\n\t        processNode(animations[i]);\n\t      }\n\t\n\t      return flatten(tree);\n\t\n\t      function processNode(entry) {\n\t        if (entry.processed) return entry;\n\t        entry.processed = true;\n\t\n\t        var elementNode = entry.domNode;\n\t        var parentNode = elementNode.parentNode;\n\t        lookup.put(elementNode, entry);\n\t\n\t        var parentEntry;\n\t        while (parentNode) {\n\t          parentEntry = lookup.get(parentNode);\n\t          if (parentEntry) {\n\t            if (!parentEntry.processed) {\n\t              parentEntry = processNode(parentEntry);\n\t            }\n\t            break;\n\t          }\n\t          parentNode = parentNode.parentNode;\n\t        }\n\t\n\t        (parentEntry || tree).children.push(entry);\n\t        return entry;\n\t      }\n\t\n\t      function flatten(tree) {\n\t        var result = [];\n\t        var queue = [];\n\t        var i;\n\t\n\t        for (i = 0; i < tree.children.length; i++) {\n\t          queue.push(tree.children[i]);\n\t        }\n\t\n\t        var remainingLevelEntries = queue.length;\n\t        var nextLevelEntries = 0;\n\t        var row = [];\n\t\n\t        for (i = 0; i < queue.length; i++) {\n\t          var entry = queue[i];\n\t          if (remainingLevelEntries <= 0) {\n\t            remainingLevelEntries = nextLevelEntries;\n\t            nextLevelEntries = 0;\n\t            result.push(row);\n\t            row = [];\n\t          }\n\t          row.push(entry.fn);\n\t          entry.children.forEach(function(childEntry) {\n\t            nextLevelEntries++;\n\t            queue.push(childEntry);\n\t          });\n\t          remainingLevelEntries--;\n\t        }\n\t\n\t        if (row.length) {\n\t          result.push(row);\n\t        }\n\t\n\t        return result;\n\t      }\n\t    }\n\t\n\t    // TODO(matsko): document the signature in a better way\n\t    return function(element, event, options) {\n\t      options = prepareAnimationOptions(options);\n\t      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\t\n\t      // there is no animation at the current moment, however\n\t      // these runner methods will get later updated with the\n\t      // methods leading into the driver's end/cancel methods\n\t      // for now they just stop the animation from starting\n\t      var runner = new $$AnimateRunner({\n\t        end: function() { close(); },\n\t        cancel: function() { close(true); }\n\t      });\n\t\n\t      if (!drivers.length) {\n\t        close();\n\t        return runner;\n\t      }\n\t\n\t      setRunner(element, runner);\n\t\n\t      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n\t      var tempClasses = options.tempClasses;\n\t      if (tempClasses) {\n\t        classes += ' ' + tempClasses;\n\t        options.tempClasses = null;\n\t      }\n\t\n\t      var prepareClassName;\n\t      if (isStructural) {\n\t        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n\t        $$jqLite.addClass(element, prepareClassName);\n\t      }\n\t\n\t      animationQueue.push({\n\t        // this data is used by the postDigest code and passed into\n\t        // the driver step function\n\t        element: element,\n\t        classes: classes,\n\t        event: event,\n\t        structural: isStructural,\n\t        options: options,\n\t        beforeStart: beforeStart,\n\t        close: close\n\t      });\n\t\n\t      element.on('$destroy', handleDestroyedElement);\n\t\n\t      // we only want there to be one function called within the post digest\n\t      // block. This way we can group animations for all the animations that\n\t      // were apart of the same postDigest flush call.\n\t      if (animationQueue.length > 1) return runner;\n\t\n\t      $rootScope.$$postDigest(function() {\n\t        var animations = [];\n\t        forEach(animationQueue, function(entry) {\n\t          // the element was destroyed early on which removed the runner\n\t          // form its storage. This means we can't animate this element\n\t          // at all and it already has been closed due to destruction.\n\t          if (getRunner(entry.element)) {\n\t            animations.push(entry);\n\t          } else {\n\t            entry.close();\n\t          }\n\t        });\n\t\n\t        // now any future animations will be in another postDigest\n\t        animationQueue.length = 0;\n\t\n\t        var groupedAnimations = groupAnimations(animations);\n\t        var toBeSortedAnimations = [];\n\t\n\t        forEach(groupedAnimations, function(animationEntry) {\n\t          toBeSortedAnimations.push({\n\t            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n\t            fn: function triggerAnimationStart() {\n\t              // it's important that we apply the `ng-animate` CSS class and the\n\t              // temporary classes before we do any driver invoking since these\n\t              // CSS classes may be required for proper CSS detection.\n\t              animationEntry.beforeStart();\n\t\n\t              var startAnimationFn, closeFn = animationEntry.close;\n\t\n\t              // in the event that the element was removed before the digest runs or\n\t              // during the RAF sequencing then we should not trigger the animation.\n\t              var targetElement = animationEntry.anchors\n\t                  ? (animationEntry.from.element || animationEntry.to.element)\n\t                  : animationEntry.element;\n\t\n\t              if (getRunner(targetElement)) {\n\t                var operation = invokeFirstDriver(animationEntry);\n\t                if (operation) {\n\t                  startAnimationFn = operation.start;\n\t                }\n\t              }\n\t\n\t              if (!startAnimationFn) {\n\t                closeFn();\n\t              } else {\n\t                var animationRunner = startAnimationFn();\n\t                animationRunner.done(function(status) {\n\t                  closeFn(!status);\n\t                });\n\t                updateAnimationRunners(animationEntry, animationRunner);\n\t              }\n\t            }\n\t          });\n\t        });\n\t\n\t        // we need to sort each of the animations in order of parent to child\n\t        // relationships. This ensures that the child classes are applied at the\n\t        // right time.\n\t        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n\t      });\n\t\n\t      return runner;\n\t\n\t      // TODO(matsko): change to reference nodes\n\t      function getAnchorNodes(node) {\n\t        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n\t        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n\t              ? [node]\n\t              : node.querySelectorAll(SELECTOR);\n\t        var anchors = [];\n\t        forEach(items, function(node) {\n\t          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n\t          if (attr && attr.length) {\n\t            anchors.push(node);\n\t          }\n\t        });\n\t        return anchors;\n\t      }\n\t\n\t      function groupAnimations(animations) {\n\t        var preparedAnimations = [];\n\t        var refLookup = {};\n\t        forEach(animations, function(animation, index) {\n\t          var element = animation.element;\n\t          var node = getDomNode(element);\n\t          var event = animation.event;\n\t          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n\t          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\t\n\t          if (anchorNodes.length) {\n\t            var direction = enterOrMove ? 'to' : 'from';\n\t\n\t            forEach(anchorNodes, function(anchor) {\n\t              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n\t              refLookup[key] = refLookup[key] || {};\n\t              refLookup[key][direction] = {\n\t                animationID: index,\n\t                element: jqLite(anchor)\n\t              };\n\t            });\n\t          } else {\n\t            preparedAnimations.push(animation);\n\t          }\n\t        });\n\t\n\t        var usedIndicesLookup = {};\n\t        var anchorGroups = {};\n\t        forEach(refLookup, function(operations, key) {\n\t          var from = operations.from;\n\t          var to = operations.to;\n\t\n\t          if (!from || !to) {\n\t            // only one of these is set therefore we can't have an\n\t            // anchor animation since all three pieces are required\n\t            var index = from ? from.animationID : to.animationID;\n\t            var indexKey = index.toString();\n\t            if (!usedIndicesLookup[indexKey]) {\n\t              usedIndicesLookup[indexKey] = true;\n\t              preparedAnimations.push(animations[index]);\n\t            }\n\t            return;\n\t          }\n\t\n\t          var fromAnimation = animations[from.animationID];\n\t          var toAnimation = animations[to.animationID];\n\t          var lookupKey = from.animationID.toString();\n\t          if (!anchorGroups[lookupKey]) {\n\t            var group = anchorGroups[lookupKey] = {\n\t              structural: true,\n\t              beforeStart: function() {\n\t                fromAnimation.beforeStart();\n\t                toAnimation.beforeStart();\n\t              },\n\t              close: function() {\n\t                fromAnimation.close();\n\t                toAnimation.close();\n\t              },\n\t              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n\t              from: fromAnimation,\n\t              to: toAnimation,\n\t              anchors: [] // TODO(matsko): change to reference nodes\n\t            };\n\t\n\t            // the anchor animations require that the from and to elements both have at least\n\t            // one shared CSS class which effectively marries the two elements together to use\n\t            // the same animation driver and to properly sequence the anchor animation.\n\t            if (group.classes.length) {\n\t              preparedAnimations.push(group);\n\t            } else {\n\t              preparedAnimations.push(fromAnimation);\n\t              preparedAnimations.push(toAnimation);\n\t            }\n\t          }\n\t\n\t          anchorGroups[lookupKey].anchors.push({\n\t            'out': from.element, 'in': to.element\n\t          });\n\t        });\n\t\n\t        return preparedAnimations;\n\t      }\n\t\n\t      function cssClassesIntersection(a,b) {\n\t        a = a.split(' ');\n\t        b = b.split(' ');\n\t        var matches = [];\n\t\n\t        for (var i = 0; i < a.length; i++) {\n\t          var aa = a[i];\n\t          if (aa.substring(0,3) === 'ng-') continue;\n\t\n\t          for (var j = 0; j < b.length; j++) {\n\t            if (aa === b[j]) {\n\t              matches.push(aa);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        return matches.join(' ');\n\t      }\n\t\n\t      function invokeFirstDriver(animationDetails) {\n\t        // we loop in reverse order since the more general drivers (like CSS and JS)\n\t        // may attempt more elements, but custom drivers are more particular\n\t        for (var i = drivers.length - 1; i >= 0; i--) {\n\t          var driverName = drivers[i];\n\t          var factory = $injector.get(driverName);\n\t          var driver = factory(animationDetails);\n\t          if (driver) {\n\t            return driver;\n\t          }\n\t        }\n\t      }\n\t\n\t      function beforeStart() {\n\t        element.addClass(NG_ANIMATE_CLASSNAME);\n\t        if (tempClasses) {\n\t          $$jqLite.addClass(element, tempClasses);\n\t        }\n\t        if (prepareClassName) {\n\t          $$jqLite.removeClass(element, prepareClassName);\n\t          prepareClassName = null;\n\t        }\n\t      }\n\t\n\t      function updateAnimationRunners(animation, newRunner) {\n\t        if (animation.from && animation.to) {\n\t          update(animation.from.element);\n\t          update(animation.to.element);\n\t        } else {\n\t          update(animation.element);\n\t        }\n\t\n\t        function update(element) {\n\t          var runner = getRunner(element);\n\t          if (runner) runner.setHost(newRunner);\n\t        }\n\t      }\n\t\n\t      function handleDestroyedElement() {\n\t        var runner = getRunner(element);\n\t        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n\t          runner.end();\n\t        }\n\t      }\n\t\n\t      function close(rejected) { // jshint ignore:line\n\t        element.off('$destroy', handleDestroyedElement);\n\t        removeRunner(element);\n\t\n\t        applyAnimationClasses(element, options);\n\t        applyAnimationStyles(element, options);\n\t        options.domOperation();\n\t\n\t        if (tempClasses) {\n\t          $$jqLite.removeClass(element, tempClasses);\n\t        }\n\t\n\t        element.removeClass(NG_ANIMATE_CLASSNAME);\n\t        runner.complete(!rejected);\n\t      }\n\t    };\n\t  }];\n\t}];\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ngAnimateSwap\n\t * @restrict A\n\t * @scope\n\t *\n\t * @description\n\t *\n\t * ngAnimateSwap is a animation-oriented directive that allows for the container to\n\t * be removed and entered in whenever the associated expression changes. A\n\t * common usecase for this directive is a rotating banner or slider component which\n\t * contains one image being present at a time. When the active image changes\n\t * then the old image will perform a `leave` animation and the new element\n\t * will be inserted via an `enter` animation.\n\t *\n\t * @animations\n\t * | Animation                        | Occurs                               |\n\t * |----------------------------------|--------------------------------------|\n\t * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n\t * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n\t *\n\t * @example\n\t * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n\t *          deps=\"angular-animate.js\"\n\t *          animations=\"true\" fixBase=\"true\">\n\t *   <file name=\"index.html\">\n\t *     <div class=\"container\" ng-controller=\"AppCtrl\">\n\t *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n\t *         {{ number }}\n\t *       </div>\n\t *     </div>\n\t *   </file>\n\t *   <file name=\"script.js\">\n\t *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n\t *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n\t *         $scope.number = 0;\n\t *         $interval(function() {\n\t *           $scope.number++;\n\t *         }, 1000);\n\t *\n\t *         var colors = ['red','blue','green','yellow','orange'];\n\t *         $scope.colorClass = function(number) {\n\t *           return colors[number % colors.length];\n\t *         };\n\t *       }]);\n\t *   </file>\n\t *  <file name=\"animations.css\">\n\t *  .container {\n\t *    height:250px;\n\t *    width:250px;\n\t *    position:relative;\n\t *    overflow:hidden;\n\t *    border:2px solid black;\n\t *  }\n\t *  .container .cell {\n\t *    font-size:150px;\n\t *    text-align:center;\n\t *    line-height:250px;\n\t *    position:absolute;\n\t *    top:0;\n\t *    left:0;\n\t *    right:0;\n\t *    border-bottom:2px solid black;\n\t *  }\n\t *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n\t *    transition:0.5s linear all;\n\t *  }\n\t *  .swap-animation.ng-enter {\n\t *    top:-250px;\n\t *  }\n\t *  .swap-animation.ng-enter-active {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave {\n\t *    top:0px;\n\t *  }\n\t *  .swap-animation.ng-leave-active {\n\t *    top:250px;\n\t *  }\n\t *  .red { background:red; }\n\t *  .green { background:green; }\n\t *  .blue { background:blue; }\n\t *  .yellow { background:yellow; }\n\t *  .orange { background:orange; }\n\t *  </file>\n\t * </example>\n\t */\n\tvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n\t  return {\n\t    restrict: 'A',\n\t    transclude: 'element',\n\t    terminal: true,\n\t    priority: 600, // we use 600 here to ensure that the directive is caught before others\n\t    link: function(scope, $element, attrs, ctrl, $transclude) {\n\t      var previousElement, previousScope;\n\t      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n\t        if (previousElement) {\n\t          $animate.leave(previousElement);\n\t        }\n\t        if (previousScope) {\n\t          previousScope.$destroy();\n\t          previousScope = null;\n\t        }\n\t        if (value || value === 0) {\n\t          previousScope = scope.$new();\n\t          $transclude(previousScope, function(element) {\n\t            previousElement = element;\n\t            $animate.enter(element, null, $element);\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t}];\n\t\n\t/* global angularAnimateModule: true,\n\t\n\t   ngAnimateSwapDirective,\n\t   $$AnimateAsyncRunFactory,\n\t   $$rAFSchedulerFactory,\n\t   $$AnimateChildrenDirective,\n\t   $$AnimateQueueProvider,\n\t   $$AnimationProvider,\n\t   $AnimateCssProvider,\n\t   $$AnimateCssDriverProvider,\n\t   $$AnimateJsProvider,\n\t   $$AnimateJsDriverProvider,\n\t*/\n\t\n\t/**\n\t * @ngdoc module\n\t * @name ngAnimate\n\t * @description\n\t *\n\t * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n\t * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n\t *\n\t * <div doc-module-components=\"ngAnimate\"></div>\n\t *\n\t * # Usage\n\t * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n\t * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n\t * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n\t * the HTML element that the animation will be triggered on.\n\t *\n\t * ## Directive Support\n\t * The following directives are \"animation aware\":\n\t *\n\t * | Directive                                                                                                | Supported Animations                                                     |\n\t * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n\t * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n\t * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n\t * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n\t * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n\t * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n\t * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n\t * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n\t * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n\t * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n\t * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n\t *\n\t * (More information can be found by visiting each the documentation associated with each directive.)\n\t *\n\t * ## CSS-based Animations\n\t *\n\t * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n\t * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n\t *\n\t * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"fade\">\n\t *    Fade me in out\n\t * </div>\n\t * <button ng-click=\"bool=true\">Fade In!</button>\n\t * <button ng-click=\"bool=false\">Fade Out!</button>\n\t * ```\n\t *\n\t * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n\t *\n\t * ```css\n\t * /&#42; The starting CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t *\n\t * /&#42; The finishing CSS styles for the enter animation &#42;/\n\t * .fade.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n\t * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n\t * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n\t *\n\t * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n\t *\n\t * ```css\n\t * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n\t * .fade.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   opacity:1;\n\t * }\n\t * .fade.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n\t *\n\t * ```css\n\t * /&#42; there is no need to define anything inside of the destination\n\t * CSS class since the keyframe will take charge of the animation &#42;/\n\t * .fade.ng-leave {\n\t *   animation: my_fade_animation 0.5s linear;\n\t *   -webkit-animation: my_fade_animation 0.5s linear;\n\t * }\n\t *\n\t * @keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t *\n\t * @-webkit-keyframes my_fade_animation {\n\t *   from { opacity:1; }\n\t *   to { opacity:0; }\n\t * }\n\t * ```\n\t *\n\t * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n\t *\n\t * ### CSS Class-based Animations\n\t *\n\t * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n\t * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n\t * and removed.\n\t *\n\t * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n\t *\n\t * ```html\n\t * <div ng-show=\"bool\" class=\"fade\">\n\t *   Show and hide me\n\t * </div>\n\t * <button ng-click=\"bool=!bool\">Toggle</button>\n\t *\n\t * <style>\n\t * .fade.ng-hide {\n\t *   transition:0.5s linear all;\n\t *   opacity:0;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n\t * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n\t *\n\t * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n\t * with CSS styles.\n\t *\n\t * ```html\n\t * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n\t *   Highlight this box\n\t * </div>\n\t * <button ng-click=\"onOff=!onOff\">Toggle</button>\n\t *\n\t * <style>\n\t * .highlight {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .highlight.on-add {\n\t *   background:white;\n\t * }\n\t * .highlight.on {\n\t *   background:yellow;\n\t * }\n\t * .highlight.on-remove {\n\t *   background:black;\n\t * }\n\t * </style>\n\t * ```\n\t *\n\t * We can also make use of CSS keyframes by placing them within the CSS classes.\n\t *\n\t *\n\t * ### CSS Staggering Animations\n\t * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n\t * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n\t * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n\t * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n\t * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n\t *\n\t * ```css\n\t * .my-animation.ng-enter {\n\t *   /&#42; standard transition code &#42;/\n\t *   transition: 1s linear all;\n\t *   opacity:0;\n\t * }\n\t * .my-animation.ng-enter-stagger {\n\t *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n\t *   transition-delay: 0.1s;\n\t *\n\t *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n\t *     to not accidentally inherit a delay property from another CSS class &#42;/\n\t *   transition-duration: 0s;\n\t * }\n\t * .my-animation.ng-enter.ng-enter-active {\n\t *   /&#42; standard transition styles &#42;/\n\t *   opacity:1;\n\t * }\n\t * ```\n\t *\n\t * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n\t * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n\t * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n\t * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n\t *\n\t * The following code will issue the **ng-leave-stagger** event on the element provided:\n\t *\n\t * ```js\n\t * var kids = parent.children();\n\t *\n\t * $animate.leave(kids[0]); //stagger index=0\n\t * $animate.leave(kids[1]); //stagger index=1\n\t * $animate.leave(kids[2]); //stagger index=2\n\t * $animate.leave(kids[3]); //stagger index=3\n\t * $animate.leave(kids[4]); //stagger index=4\n\t *\n\t * window.requestAnimationFrame(function() {\n\t *   //stagger has reset itself\n\t *   $animate.leave(kids[5]); //stagger index=0\n\t *   $animate.leave(kids[6]); //stagger index=1\n\t *\n\t *   $scope.$digest();\n\t * });\n\t * ```\n\t *\n\t * Stagger animations are currently only supported within CSS-defined animations.\n\t *\n\t * ### The `ng-animate` CSS class\n\t *\n\t * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n\t * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n\t *\n\t * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n\t *\n\t * ```css\n\t * .zipper.ng-animate {\n\t *   transition:0.5s linear all;\n\t * }\n\t * .zipper.ng-enter {\n\t *   opacity:0;\n\t * }\n\t * .zipper.ng-enter.ng-enter-active {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave {\n\t *   opacity:1;\n\t * }\n\t * .zipper.ng-leave.ng-leave-active {\n\t *   opacity:0;\n\t * }\n\t * ```\n\t *\n\t * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n\t * the CSS class once an animation has completed.)\n\t *\n\t *\n\t * ### The `ng-[event]-prepare` class\n\t *\n\t * This is a special class that can be used to prevent unwanted flickering / flash of content before\n\t * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n\t * before the actual animation starts (after waiting for a $digest).\n\t * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n\t *\n\t * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n\t * into elements that have class-based animations such as `ngClass`.\n\t *\n\t * ```html\n\t * <div ng-class=\"{red: myProp}\">\n\t *   <div ng-class=\"{blue: myProp}\">\n\t *     <div class=\"message\" ng-if=\"myProp\"></div>\n\t *   </div>\n\t * </div>\n\t * ```\n\t *\n\t * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n\t * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n\t *\n\t * ```css\n\t * .message.ng-enter-prepare {\n\t *   opacity: 0;\n\t * }\n\t *\n\t * ```\n\t *\n\t * ## JavaScript-based Animations\n\t *\n\t * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n\t * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n\t * `module.animation()` module function we can register the animation.\n\t *\n\t * Let's see an example of a enter/leave animation using `ngRepeat`:\n\t *\n\t * ```html\n\t * <div ng-repeat=\"item in items\" class=\"slide\">\n\t *   {{ item }}\n\t * </div>\n\t * ```\n\t *\n\t * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     // make note that other events (like addClass/removeClass)\n\t *     // have different function input parameters\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *\n\t *       // remember to call doneFn so that angular\n\t *       // knows that the animation has concluded\n\t *     },\n\t *\n\t *     move: function(element, doneFn) {\n\t *       jQuery(element).fadeIn(1000, doneFn);\n\t *     },\n\t *\n\t *     leave: function(element, doneFn) {\n\t *       jQuery(element).fadeOut(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n\t * greensock.js and velocity.js.\n\t *\n\t * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n\t * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n\t *\n\t * ```html\n\t * <div ng-class=\"color\" class=\"colorful\">\n\t *   this box is moody\n\t * </div>\n\t * <button ng-click=\"color='red'\">Change to red</button>\n\t * <button ng-click=\"color='blue'\">Change to blue</button>\n\t * <button ng-click=\"color='green'\">Change to green</button>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.colorful', [function() {\n\t *   return {\n\t *     addClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     removeClass: function(element, className, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     },\n\t *     setClass: function(element, addedClass, removedClass, doneFn) {\n\t *       // do some cool animation and call the doneFn\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ## CSS + JS Animations Together\n\t *\n\t * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n\t * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n\t * charge of the animation**:\n\t *\n\t * ```html\n\t * <div ng-if=\"bool\" class=\"slide\">\n\t *   Slide in and out\n\t * </div>\n\t * ```\n\t *\n\t * ```js\n\t * myModule.animation('.slide', [function() {\n\t *   return {\n\t *     enter: function(element, doneFn) {\n\t *       jQuery(element).slideIn(1000, doneFn);\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * ```css\n\t * .slide.ng-enter {\n\t *   transition:0.5s linear all;\n\t *   transform:translateY(-100px);\n\t * }\n\t * .slide.ng-enter.ng-enter-active {\n\t *   transform:translateY(0);\n\t * }\n\t * ```\n\t *\n\t * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n\t * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n\t * our own JS-based animation code:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n\t *\n\t * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n\t * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n\t * data into `$animateCss` directly:\n\t *\n\t * ```js\n\t * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n\t *   return {\n\t *     enter: function(element) {\n\t *       return $animateCss(element, {\n\t *         event: 'enter',\n\t *         structural: true,\n\t *         addClass: 'maroon-setting',\n\t *         from: { height:0 },\n\t *         to: { height: 200 }\n\t *       });\n\t *     }\n\t *   }\n\t * }]);\n\t * ```\n\t *\n\t * Now we can fill in the rest via our transition CSS code:\n\t *\n\t * ```css\n\t * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n\t * .slide.ng-enter { transition:0.5s linear all; }\n\t *\n\t * /&#42; this extra CSS class will be absorbed into the transition\n\t * since the $animateCss code is adding the class &#42;/\n\t * .maroon-setting { background:red; }\n\t * ```\n\t *\n\t * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n\t *\n\t * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n\t *\n\t * ## Animation Anchoring (via `ng-animate-ref`)\n\t *\n\t * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n\t * structural areas of an application (like views) by pairing up elements using an attribute\n\t * called `ng-animate-ref`.\n\t *\n\t * Let's say for example we have two views that are managed by `ng-view` and we want to show\n\t * that there is a relationship between two components situated in within these views. By using the\n\t * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n\t * can then attach an animation, which is triggered when the view changes.\n\t *\n\t * Say for example we have the following template code:\n\t *\n\t * ```html\n\t * <!-- index.html -->\n\t * <div ng-view class=\"view-animation\">\n\t * </div>\n\t *\n\t * <!-- home.html -->\n\t * <a href=\"#/banner-page\">\n\t *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * </a>\n\t *\n\t * <!-- banner-page.html -->\n\t * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n\t * ```\n\t *\n\t * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n\t * HTML contents to see if there is a match reference between any components in the view\n\t * that is leaving and the view that is entering. It will scan both the view which is being\n\t * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n\t * contain a matching ref value.\n\t *\n\t * The two images match since they share the same ref value. ngAnimate will now create a\n\t * transport element (which is a clone of the first image element) and it will then attempt\n\t * to animate to the position of the second image element in the next view. For the animation to\n\t * work a special CSS class called `ng-anchor` will be added to the transported element.\n\t *\n\t * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n\t * ngAnimate will handle the entire transition for us as well as the addition and removal of\n\t * any changes of CSS classes between the elements:\n\t *\n\t * ```css\n\t * .banner.ng-anchor {\n\t *   /&#42; this animation will last for 1 second since there are\n\t *          two phases to the animation (an `in` and an `out` phase) &#42;/\n\t *   transition:0.5s linear all;\n\t * }\n\t * ```\n\t *\n\t * We also **must** include animations for the views that are being entered and removed\n\t * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n\t *\n\t * ```css\n\t * .view-animation.ng-enter, .view-animation.ng-leave {\n\t *   transition:0.5s linear all;\n\t *   position:fixed;\n\t *   left:0;\n\t *   top:0;\n\t *   width:100%;\n\t * }\n\t * .view-animation.ng-enter {\n\t *   transform:translateX(100%);\n\t * }\n\t * .view-animation.ng-leave,\n\t * .view-animation.ng-enter.ng-enter-active {\n\t *   transform:translateX(0%);\n\t * }\n\t * .view-animation.ng-leave.ng-leave-active {\n\t *   transform:translateX(-100%);\n\t * }\n\t * ```\n\t *\n\t * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n\t * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n\t * from its origin. Once that animation is over then the `in` stage occurs which animates the\n\t * element to its destination. The reason why there are two animations is to give enough time\n\t * for the enter animation on the new element to be ready.\n\t *\n\t * The example above sets up a transition for both the in and out phases, but we can also target the out or\n\t * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n\t *\n\t * ```css\n\t * .banner.ng-anchor-out {\n\t *   transition: 0.5s linear all;\n\t *\n\t *   /&#42; the scale will be applied during the out animation,\n\t *          but will be animated away when the in animation runs &#42;/\n\t *   transform: scale(1.2);\n\t * }\n\t *\n\t * .banner.ng-anchor-in {\n\t *   transition: 1s linear all;\n\t * }\n\t * ```\n\t *\n\t *\n\t *\n\t *\n\t * ### Anchoring Demo\n\t *\n\t  <example module=\"anchoringExample\"\n\t           name=\"anchoringExample\"\n\t           id=\"anchoringExample\"\n\t           deps=\"angular-animate.js;angular-route.js\"\n\t           animations=\"true\">\n\t    <file name=\"index.html\">\n\t      <a href=\"#/\">Home</a>\n\t      <hr />\n\t      <div class=\"view-container\">\n\t        <div ng-view class=\"view\"></div>\n\t      </div>\n\t    </file>\n\t    <file name=\"script.js\">\n\t      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n\t        .config(['$routeProvider', function($routeProvider) {\n\t          $routeProvider.when('/', {\n\t            templateUrl: 'home.html',\n\t            controller: 'HomeController as home'\n\t          });\n\t          $routeProvider.when('/profile/:id', {\n\t            templateUrl: 'profile.html',\n\t            controller: 'ProfileController as profile'\n\t          });\n\t        }])\n\t        .run(['$rootScope', function($rootScope) {\n\t          $rootScope.records = [\n\t            { id:1, title: \"Miss Beulah Roob\" },\n\t            { id:2, title: \"Trent Morissette\" },\n\t            { id:3, title: \"Miss Ava Pouros\" },\n\t            { id:4, title: \"Rod Pouros\" },\n\t            { id:5, title: \"Abdul Rice\" },\n\t            { id:6, title: \"Laurie Rutherford Sr.\" },\n\t            { id:7, title: \"Nakia McLaughlin\" },\n\t            { id:8, title: \"Jordon Blanda DVM\" },\n\t            { id:9, title: \"Rhoda Hand\" },\n\t            { id:10, title: \"Alexandrea Sauer\" }\n\t          ];\n\t        }])\n\t        .controller('HomeController', [function() {\n\t          //empty\n\t        }])\n\t        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n\t          var index = parseInt($routeParams.id, 10);\n\t          var record = $rootScope.records[index - 1];\n\t\n\t          this.title = record.title;\n\t          this.id = record.id;\n\t        }]);\n\t    </file>\n\t    <file name=\"home.html\">\n\t      <h2>Welcome to the home page</h1>\n\t      <p>Please click on an element</p>\n\t      <a class=\"record\"\n\t         ng-href=\"#/profile/{{ record.id }}\"\n\t         ng-animate-ref=\"{{ record.id }}\"\n\t         ng-repeat=\"record in records\">\n\t        {{ record.title }}\n\t      </a>\n\t    </file>\n\t    <file name=\"profile.html\">\n\t      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n\t        {{ profile.title }}\n\t      </div>\n\t    </file>\n\t    <file name=\"animations.css\">\n\t      .record {\n\t        display:block;\n\t        font-size:20px;\n\t      }\n\t      .profile {\n\t        background:black;\n\t        color:white;\n\t        font-size:100px;\n\t      }\n\t      .view-container {\n\t        position:relative;\n\t      }\n\t      .view-container > .view.ng-animate {\n\t        position:absolute;\n\t        top:0;\n\t        left:0;\n\t        width:100%;\n\t        min-height:500px;\n\t      }\n\t      .view.ng-enter, .view.ng-leave,\n\t      .record.ng-anchor {\n\t        transition:0.5s linear all;\n\t      }\n\t      .view.ng-enter {\n\t        transform:translateX(100%);\n\t      }\n\t      .view.ng-enter.ng-enter-active, .view.ng-leave {\n\t        transform:translateX(0%);\n\t      }\n\t      .view.ng-leave.ng-leave-active {\n\t        transform:translateX(-100%);\n\t      }\n\t      .record.ng-anchor-out {\n\t        background:red;\n\t      }\n\t    </file>\n\t  </example>\n\t *\n\t * ### How is the element transported?\n\t *\n\t * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n\t * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n\t * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n\t * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n\t * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n\t * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n\t * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n\t * will become visible since the shim class will be removed.\n\t *\n\t * ### How is the morphing handled?\n\t *\n\t * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n\t * what CSS classes differ between the starting element and the destination element. These different CSS classes\n\t * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n\t * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n\t * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n\t * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n\t * the cloned element is placed inside of root element which is likely close to the body element).\n\t *\n\t * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n\t *\n\t *\n\t * ## Using $animate in your directive code\n\t *\n\t * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n\t * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n\t * imagine we have a greeting box that shows and hides itself when the data changes\n\t *\n\t * ```html\n\t * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n\t * ```\n\t *\n\t * ```js\n\t * ngModule.directive('greetingBox', ['$animate', function($animate) {\n\t *   return function(scope, element, attrs) {\n\t *     attrs.$observe('active', function(value) {\n\t *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n\t *     });\n\t *   });\n\t * }]);\n\t * ```\n\t *\n\t * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n\t * in our HTML code then we can trigger a CSS or JS animation to happen.\n\t *\n\t * ```css\n\t * /&#42; normally we would create a CSS class to reference on the element &#42;/\n\t * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n\t * ```\n\t *\n\t * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n\t * possible be sure to visit the {@link ng.$animate $animate service API page}.\n\t *\n\t *\n\t * ## Callbacks and Promises\n\t *\n\t * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n\t * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n\t * ended by chaining onto the returned promise that animation method returns.\n\t *\n\t * ```js\n\t * // somewhere within the depths of the directive\n\t * $animate.enter(element, parent).then(function() {\n\t *   //the animation has completed\n\t * });\n\t * ```\n\t *\n\t * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n\t * anymore.)\n\t *\n\t * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n\t * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n\t * routing controller to hook into that:\n\t *\n\t * ```js\n\t * ngModule.controller('HomePageController', ['$animate', function($animate) {\n\t *   $animate.on('enter', ngViewElement, function(element) {\n\t *     // the animation for this route has completed\n\t *   }]);\n\t * }])\n\t * ```\n\t *\n\t * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n\t */\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $animate\n\t * @kind object\n\t *\n\t * @description\n\t * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n\t *\n\t * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n\t */\n\tangular.module('ngAnimate', [])\n\t  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\t\n\t  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n\t  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\t\n\t  .provider('$$animateQueue', $$AnimateQueueProvider)\n\t  .provider('$$animation', $$AnimationProvider)\n\t\n\t  .provider('$animateCss', $AnimateCssProvider)\n\t  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\t\n\t  .provider('$$animateJs', $$AnimateJsProvider)\n\t  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\t\n\t\n\t})(window, window.angular);\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _services = __webpack_require__(9);\n\t\n\tvar _services2 = _interopRequireDefault(_services);\n\t\n\tvar _BookmarksController = __webpack_require__(12);\n\t\n\tvar _BookmarksController2 = _interopRequireDefault(_BookmarksController);\n\t\n\tvar _edit = __webpack_require__(13);\n\t\n\tvar _edit2 = _interopRequireDefault(_edit);\n\t\n\tvar _create = __webpack_require__(17);\n\t\n\tvar _create2 = _interopRequireDefault(_create);\n\t\n\tvar _routing = __webpack_require__(21);\n\t\n\tvar _routing2 = _interopRequireDefault(_routing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('eggly.bookmarks', [_services2.default, _edit2.default, _create2.default]).controller('bookmarksController', _BookmarksController2.default).config(_routing2.default);\n\t\n\texports.default = 'eggly.bookmarks';\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _CategoriesService = __webpack_require__(10);\n\t\n\tvar _CategoriesService2 = _interopRequireDefault(_CategoriesService);\n\t\n\tvar _BookmarksService = __webpack_require__(11);\n\t\n\tvar _BookmarksService2 = _interopRequireDefault(_BookmarksService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('eggly.services', []).service('bookmarksService', _BookmarksService2.default).service('categoriesService', _CategoriesService2.default);\n\t\n\texports.default = 'eggly.services';\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//import categories from 'json!categories.json';\n\t//console.log (categories);\n\t\n\tvar CategoriesSrv = function () {\n\t\tfunction CategoriesSrv($http, $q) {\n\t\t\t_classCallCheck(this, CategoriesSrv);\n\t\n\t\t\tthis.urlFetch = 'data/categories.json';\n\t\t\tthis.$http = $http;\n\t\t\tthis.$q = $q;\n\t\t\tthis.categories = [];\n\t\t\tthis.currentCategory;\n\t\t}\n\t\n\t\t_createClass(CategoriesSrv, [{\n\t\t\tkey: \"getCategories\",\n\t\t\tvalue: function getCategories() {\n\t\n\t\t\t\tfunction cacheCategories(result) {\n\t\t\t\t\tconsole.log(\"cacheCategories...\");\n\t\t\t\t\tconsole.log(result);\n\t\t\t\t\tvar extract = function extract(result) {\n\t\t\t\t\t\treturn result.data;\n\t\t\t\t\t};\n\t\t\t\t\tthis.categories = extract(result);\n\t\t\t\t\treturn this.categories;\n\t\t\t\t}\n\t\n\t\t\t\tif (this.categories.length) {\n\t\t\t\t\tconsole.log(this.categories);\n\t\t\t\t\treturn this.$q.when(this.categories);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"this.$http...\");\n\t\t\t\t\treturn this.$http.get(this.urlFetch).then(cacheCategories);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getCurrentCategory\",\n\t\t\tvalue: function getCurrentCategory() {\n\t\t\t\treturn this.currentCategory;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getCurrentCategoryName\",\n\t\t\tvalue: function getCurrentCategoryName() {\n\t\t\t\treturn this.currentCategory ? this.currentCategory.name : '';\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"setCurrentCategory\",\n\t\t\tvalue: function setCurrentCategory(category) {\n\t\t\t\tthis.currentCategory = category;\n\t\t\t\treturn this.currentCategory;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"createCategory\",\n\t\t\tvalue: function createCategory(category) {\n\t\t\t\tcategory.id = this.categories.length;\n\t\t\t\tthis.categories.push(category);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"deleteCategory\",\n\t\t\tvalue: function deleteCategory(category) {\n\t\t\t\t_.remove(this.categories, function (c) {\n\t\t\t\t\treturn c.id == category.id;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getBookmarkById\",\n\t\t\tvalue: function getBookmarkById(bookmarkId) {\n\t\t\t\tvar deferred = $q.defer();\n\t\t\t\tvar hasId = function hasId(bookmark) {\n\t\t\t\t\treturn bookmark.id === parseInt(bookmarkId, 10);\n\t\t\t\t};\n\t\t\t\tvar findBookmark = function findBookmark(bookmarkId) {\n\t\t\t\t\treturn _.find(bookmarks, hasId);\n\t\t\t\t};\n\t\t\t\tvar bookmarkFound = findBookmark(bookmarkId);\n\t\n\t\t\t\tif (this.bookmarks) {\n\t\t\t\t\tdeferred.resolve(bookmarkFound);\n\t\t\t\t} else {\n\t\t\t\t\tthis.getBookmarks().then(function () {\n\t\t\t\t\t\treturn deferred.resolve(bookmarkFound);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn deferred.promise;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getCategoryByName\",\n\t\t\tvalue: function getCategoryByName(categoryName) {\n\t\t\t\tvar deferred = $q.defer();\n\t\t\t\tvar hasName = function hasName(category) {\n\t\t\t\t\treturn category.name == categoryName;\n\t\t\t\t};\n\t\t\t\tvar findCategory = function findCategory() {\n\t\t\t\t\treturn _.find(categories, hasName);\n\t\t\t\t};\n\t\t\t\tvar categoryFound = findCategory();\n\t\n\t\t\t\tif (categories) {\n\t\t\t\t\tdeferred.resolve(categoryFound);\n\t\t\t\t} else {\n\t\t\t\t\tthis.getCategories().then(function () {\n\t\t\t\t\t\treturn deferred.resolve(categoryFound);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\treturn deferred.promise;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn CategoriesSrv;\n\t}();\n\t\n\tCategoriesSrv.$inject = ['$http', '$q'];\n\t\n\texports.default = CategoriesSrv;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar BookmarksSrv = function () {\n\t  function BookmarksSrv($http, $q) {\n\t    _classCallCheck(this, BookmarksSrv);\n\t\n\t    this.urlFetch = 'data/bookmarks.json';\n\t    this.$http = $http;\n\t    this.$q = $q;\n\t    this.bookmarks = [];\n\t  }\n\t\n\t  _createClass(BookmarksSrv, [{\n\t    key: 'getBookmarks',\n\t    value: function getBookmarks() {\n\t\n\t      var extract = function extract(result) {\n\t        return result.data;\n\t      };\n\t      var cacheBookmarks = function cacheBookmarks(result) {\n\t        var bookmarks = extract(result);\n\t        return bookmarks;\n\t      };\n\t\n\t      // return always a promise\n\t      if (this.bookmarks) {\n\t        return this.$q.when(this.bookmarks);\n\t      } else {\n\t        return this.$http.get(this.urlFetch).then(cacheBookmarks);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getBookmarkById',\n\t    value: function getBookmarkById(bookmarkId) {\n\t      var deferred = $q.defer();\n\t      var hasId = function hasId(bookmark) {\n\t        return bookmark.id === parseInt(bookmarkId, 10);\n\t      };\n\t      var findBookmark = function findBookmark() {\n\t        return _.find(bookmarks, hasId);\n\t      };\n\t      var bookmarkFound = findBookmark();\n\t\n\t      if (this.bookmarks) {\n\t        deferred.resolve(bookmarkFound);\n\t      } else {\n\t        this.getBookmarks().then(function () {\n\t          return deferred.resolve(bookmarkFound);\n\t        });\n\t      }\n\t      return deferred.promise;\n\t    }\n\t  }, {\n\t    key: 'createBookmark',\n\t    value: function createBookmark(bookmark) {\n\t      var id = this.bookmarks.length;\n\t      this.bookmarks.push({ id: id });\n\t    }\n\t  }, {\n\t    key: 'updateBookmark',\n\t    value: function updateBookmark(bookmark) {\n\t      var index = _.findIndex(this.bookmarks, function (b) {\n\t        return b.id == bookmark.id;\n\t      });\n\t      this.bookmarks[index] = bookmark;\n\t    }\n\t  }, {\n\t    key: 'deleteBookmark',\n\t    value: function deleteBookmark(bookmark) {\n\t      _.remove(this.bookmarks, function (b) {\n\t        return b.id == bookmark.id;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'getBookmarksForCategory',\n\t    value: function getBookmarksForCategory(category) {\n\t      _.filter(bookmarks, function (b) {\n\t        return b.category == category;\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return BookmarksSrv;\n\t}();\n\t\n\tBookmarksSrv.$inject = ['$http', '$q'];\n\t\n\texports.default = BookmarksSrv;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar BookmarksCtrl = function BookmarksCtrl($stateParams, bookmarksSrv, categoriesSrv) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, BookmarksCtrl);\n\t\n\t  categoriesSrv.setCurrentCategory();\n\t\n\t  if ($stateParams.category) {\n\t    categoriesSrv.getCategoryByName($stateParams.category).then(function (category) {\n\t      return categoriesSrv.setCurrentCategory(category);\n\t    });\n\t  }\n\t\n\t  bookmarksSrv.getBookmarks().then(function (result) {\n\t    return _this.bookmarks = result;\n\t  });\n\t\n\t  this.getCurrentCategory = categoriesSrv.getCurrentCategory;\n\t  this.getCurrentCategoryName = categoriesSrv.getCurrentCategoryName;\n\t  this.isSelectedBookmark = function (bookmarkId) {\n\t    return $stateParams.bookmarkId == bookmarkId;\n\t  };\n\t  this.deleteBookmark = bookmarksSrv.deleteBookmark;\n\t};\n\t\n\tBookmarksCtrl.$inject = ['$stateParams', 'bookmarksService', 'categoriesService'];\n\t\n\texports.default = BookmarksCtrl;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularUiRouter = __webpack_require__(5);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _services = __webpack_require__(9);\n\t\n\tvar _services2 = _interopRequireDefault(_services);\n\t\n\tvar _EditController = __webpack_require__(14);\n\t\n\tvar _EditController2 = _interopRequireDefault(_EditController);\n\t\n\tvar _routing = __webpack_require__(15);\n\t\n\tvar _routing2 = _interopRequireDefault(_routing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('eggly.bookmarks.edit', [_angularUiRouter2.default, _services2.default]).controller('editController', _EditController2.default).config(_routing2.default);\n\t\n\texports.default = 'eggly.bookmarks.edit';\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EditCtrl = function EditCtrl(bookmarksSrv, $stateParams, $state) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, EditCtrl);\n\t\n\t  this.isEditing = false;\n\t\n\t  function returnToBookmarks() {\n\t    $state.go('eggly.categories.bookmarks', {\n\t      category: $stateParams.category\n\t    });\n\t  }\n\t\n\t  function setEditState(bookmark) {\n\t    if (bookmark) {\n\t      this.isEditing = true;\n\t      this.bookmark = bookmark;\n\t      this.editedBookmark = angular.copy(this.bookmark);\n\t    } else {\n\t      returnToBookmarks();\n\t    }\n\t  }\n\t\n\t  function updateBookmark() {\n\t    this.bookmark = angular.copy(this.editedBookmark);\n\t    bookmarks.updateBookmark(this.editedBookmark);\n\t    returnToBookmarks();\n\t  }\n\t\n\t  function cancelEditing() {\n\t    this.isEditing = false;\n\t    returnToBookmarks();\n\t  }\n\t\n\t  bookmarksSrv.getBookmarkById($stateParams.bookmarkId).then(setEditState);\n\t\n\t  this.toggleEditing = function () {\n\t    return _this.isEditing = !_this.isEditing;\n\t  };\n\t  this.cancelEditing = cancelEditing;\n\t  this.updateBookmark = updateBookmark;\n\t};\n\t\n\tEditCtrl.$inject = ['bookmarksService', '$stateParams', '$state'];\n\t\n\texports.default = EditCtrl;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _editTpl = __webpack_require__(16);\n\t\n\tvar _editTpl2 = _interopRequireDefault(_editTpl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar controller = 'editController';\n\tvar controllerAs = '$ctrl';\n\t\n\tfunction routing($stateProvider) {\n\t  $stateProvider.state('eggly.categories.bookmarks.edit', {\n\t    url: 'categories/:category',\n\t    views: { '@eggly.categories.bookmarks': { controller: controller, template: _editTpl2.default, controllerAs: controllerAs } }\n\t  });\n\t}\n\t\n\trouting.$inject = ['$stateProvider'];\n\t\n\texports.default = routing;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<h4>Editing {{bookmark.title}}</h4>\\n\\n<form class=\\\"edit-form\\\" ng-show=\\\"isEditing\\\" role=\\\"form\\\" ng-submit=\\\"updateBookmark()\\\" novalidate>\\n    <div class=\\\"form-group\\\">\\n        <label>Bookmark Title</label>\\n        <input type=\\\"text\\\" class=\\\"form-control\\\" ng-model=\\\"editedBookmark.title\\\" placeholder=\\\"Enter title\\\">\\n    </div>\\n    <div class=\\\"form-group\\\">\\n        <label>Bookmark URL</label>\\n        <input type=\\\"text\\\" class=\\\"form-control\\\" ng-model=\\\"editedBookmark.url\\\" placeholder=\\\"Enter URL\\\">\\n    </div>\\n    <button type=\\\"submit\\\" class=\\\"btn btn-info btn-lg\\\">Save</button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-default btn-lg pull-right\\\" ng-click=\\\"cancelEditing()\\\">Cancel</button>\\n</form>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularUiRouter = __webpack_require__(5);\n\t\n\tvar _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);\n\t\n\tvar _services = __webpack_require__(9);\n\t\n\tvar _services2 = _interopRequireDefault(_services);\n\t\n\tvar _CreateController = __webpack_require__(18);\n\t\n\tvar _CreateController2 = _interopRequireDefault(_CreateController);\n\t\n\tvar _routing = __webpack_require__(19);\n\t\n\tvar _routing2 = _interopRequireDefault(_routing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('eggly.bookmarks.edit', [_angularUiRouter2.default, _services2.default]).controller('createController', _CreateController2.default).config(_routing2.default);\n\t\n\texports.default = 'eggly.bookmarks.edit';\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CreateCtrl = function CreateCtrl($stateParams, $state, bookmarksSrv) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, CreateCtrl);\n\t\n\t  this.isCreating = false;\n\t\n\t  function returnToBookmarks() {\n\t    $state.go('eggly.categories.bookmarks', {\n\t      category: $stateParams.category\n\t    });\n\t  }\n\t\n\t  function cancelCreating() {\n\t    this.isCreating = false;\n\t    returnToBookmarks();\n\t  }\n\t\n\t  function createBookmark() {\n\t    bookmarksSrv.createBookmark(this.newBookmark);\n\t    returnToBookmarks();\n\t  }\n\t\n\t  function resetForm() {\n\t    this.newBookmark = {\n\t      title: '',\n\t      url: '',\n\t      category: $stateParams.category\n\t    };\n\t  }\n\t\n\t  this.toggleCreating = function () {\n\t    return _this.isCreating = !_this.isCreating;\n\t  };\n\t  this.cancelCreating = cancelCreating;\n\t  this.createBookmark = createBookmark;\n\t\n\t  resetForm();\n\t  toggleCreating();\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createTpl = __webpack_require__(20);\n\t\n\tvar _createTpl2 = _interopRequireDefault(_createTpl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar controller = 'createController';\n\tvar controllerAs = '$ctrl';\n\t\n\tfunction routing($stateProvider) {\n\t  $stateProvider.state('eggly.categories.bookmarks.create', {\n\t    url: '/bookmarks/create',\n\t    views: { '@eggly.categories.bookmarks': { controller: controller, template: _createTpl2.default, controllerAs: controllerAs } }\n\t  });\n\t}\n\t\n\trouting.$inject = ['$stateProvider'];\n\t\n\texports.default = routing;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"createBookmark\\\">\\n    <form class=\\\"create-form\\\" ng-show=\\\"isCreating\\\" role=\\\"form\\\" ng-submit=\\\"createBookmark()\\\" novalidate>\\n        <div class=\\\"form-group\\\">\\n            <label for=\\\"newBookmarkTitle\\\">Bookmark Title</label>\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"newBookmarkTitle\\\" ng-model=\\\"newBookmark.title\\\" placeholder=\\\"Enter title\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <label for=\\\"newBookmarkURL\\\">Bookmark URL</label>\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"newBookmarkURL\\\" ng-model=\\\"newBookmark.url\\\" placeholder=\\\"Enter URL\\\">\\n        </div>\\n        <button type=\\\"submit\\\" class=\\\"btn btn-info btn-lg\\\">Create</button>\\n        <button type=\\\"button\\\" class=\\\"btn btn-default btn-lg pull-right\\\" ng-click=\\\"cancelCreating()\\\">Cancel</button>\\n    </form>\\n</div>\"\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _bookmarksTpl = __webpack_require__(22);\n\t\n\tvar _bookmarksTpl2 = _interopRequireDefault(_bookmarksTpl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar controller = 'bookmarksController';\n\tvar controllerAs = '$ctrl';\n\t\n\tfunction routing($stateProvider) {\n\t  $stateProvider.state('eggly.categories.bookmarks', {\n\t    url: 'categories/:category',\n\t    views: { 'bookmarks@': { controller: controller, template: _bookmarksTpl2.default, controllerAs: controllerAs } }\n\t  });\n\t}\n\t\n\trouting.$inject = ['$stateProvider'];\n\t\n\texports.default = routing;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ui-sref-active=\\\"editing\\\" bookmark=\\\"bookmark\\\" ng-class=\\\"{active: isSelectedBookmark(bookmark.id)}\\\"  ng-repeat=\\\"bookmark in bookmarks | filter:{category:getCurrentCategoryName()}\\\">\\n\\n  <button type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"deleteBookmark(bookmark)\\\">&times;</button>\\n  <button type=\\\"button\\\" class=\\\"btn btn-link\\\" ui-sref=\\\"eggly.categories.bookmarks.edit({category:bookmark.category, bookmarkId:bookmark.id})\\\"><span class=\\\"glyphicon glyphicon-pencil\\\"></span>\\n  </button>\\n  <a href=\\\"{{bookmark.url}}\\\" target=\\\"_blank\\\">{{bookmark.title}}</a>\\n</div>\\n<hr/>\\n\\n<ui-view>\\n  <div ng-if=\\\"getCurrentCategory()\\\">\\n    <button type=\\\"button\\\" class=\\\"btn btn-link\\\"\\n            ui-sref=\\\"eggly.categories.bookmarks.create({category:getCurrentCategoryName()})\\\"><span\\n        class=\\\"glyphicon glyphicon-plus\\\"></span>\\n      Create Bookmark\\n    </button>\\n  </div>\\n</ui-view>\\n\\n\"\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _services = __webpack_require__(9);\n\t\n\tvar _services2 = _interopRequireDefault(_services);\n\t\n\tvar _CategoriesController = __webpack_require__(24);\n\t\n\tvar _CategoriesController2 = _interopRequireDefault(_CategoriesController);\n\t\n\tvar _routing = __webpack_require__(25);\n\t\n\tvar _routing2 = _interopRequireDefault(_routing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_angular2.default.module('eggly.categories', [_services2.default]).controller('categoriesController', _CategoriesController2.default).config(_routing2.default);\n\t\n\texports.default = 'eggly.categories';\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CategoriesCtrl = function CategoriesCtrl(categoriesSrv) {\n\t\tvar _this = this;\n\t\n\t\t_classCallCheck(this, CategoriesCtrl);\n\t\n\t\tthis.getCurrentCategoryName = categoriesSrv.getCurrentCategoryName;\n\t\n\t\tcategoriesSrv.getCategories().then(function (result) {\n\t\t\treturn _this.categories = result;\n\t\t});\n\t\n\t\tthis.isCurrentCategory = function (category) {\n\t\t\treturn category.name === _this.getCurrentCategoryName();\n\t\t};\n\t};\n\t\n\tCategoriesCtrl.$inject = ['categoriesService'];\n\t\n\texports.default = CategoriesCtrl;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _categoriesTpl = __webpack_require__(26);\n\t\n\tvar _categoriesTpl2 = _interopRequireDefault(_categoriesTpl);\n\t\n\tvar _bookmarksTpl = __webpack_require__(22);\n\t\n\tvar _bookmarksTpl2 = _interopRequireDefault(_bookmarksTpl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar categoriesCtrl = 'categoriesController';\n\t\n\tvar bookmarksCtrl = 'bookmarksController';\n\t\n\tfunction routing($stateProvider) {\n\t  $stateProvider.state('eggly.categories', {\n\t    url: '/',\n\t    views: {\n\t      'categories@': {\n\t        controller: categoriesCtrl,\n\t        template: _categoriesTpl2.default,\n\t        controllerAs: '$ctrl'\n\t      },\n\t      'bookmarks@': {\n\t        controller: bookmarksCtrl,\n\t        template: _bookmarksTpl2.default,\n\t        controllerAs: '$ctrl'\n\t      }\n\t    }\n\t  });\n\t}\n\t\n\trouting.$inject = ['$stateProvider'];\n\t\n\texports.default = routing;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<p>hello!!!  {{ $ctrl.categories.length }}</p>\\n<a href=\\\"#/\\\"><img class=\\\"logo\\\" src=\\\"assets/img/eggly-logo.png\\\"></a>\\n<ul class=\\\"nav nav-sidebar\\\">\\n    <li ng-repeat=\\\"category in $ctrl.categories\\\" ng-class=\\\"{'active':$ctrl.isCurrentCategory(category)}\\\">\\n      <a ui-sref=\\\"eggly.categories.bookmarks({category: category.name})\\\">\\n        category: {{category.name}}\\n      </a></li>\\n</ul>\\n\"\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar url = '';\n\tvar abstract = true;\n\t\n\tfunction routing($stateProvider, $urlRouterProvider) {\n\t  $stateProvider.state('eggly', { url: url, abstract: abstract });\n\t  $urlRouterProvider.otherwise('/');\n\t};\n\t\n\trouting.$inject = ['$stateProvider', '$urlRouterProvider'];\n\t\n\texports.default = routing;\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** js/app.9724907e62399a3bd84f.js\n **/","// Styles\nimport 'bootstrap/dist/css/bootstrap.css';\nimport '../assets/css/app.scss';\n\n// JS App\nimport angular from 'angular';\nimport ngUiRoute from 'angular-ui-router';\nimport ngAnimate from 'angular-animate';\n\nimport bookmarks from './bookmarks';\nimport categories from './categories';\nimport services from './services';\n\nimport bookmarksEdit from './bookmarks/edit';\nimport bookmarksCreate from './bookmarks/create';\n\nimport routing from './routing.js';\n\nangular.module('Eggly', [\n\t\tngAnimate,\n\t\tngUiRoute,\n\t\tservices,\n\t\tcategories,\n\t\tbookmarks,\n\t\tbookmarksEdit,\n\t\tbookmarksCreate\n\t])\n  .config( routing );\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/app.js\n **/","/*!\n * State-based routing for AngularJS\n * @version v1.0.0-alpha.5\n * @link http://angular-ui.github.com/ui-router\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"angular-ui-router\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-ui-router\"] = factory();\n\telse\n\t\troot[\"angular-ui-router\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Main entry point for angular 1.x build\n\t * @module ng1\n\t */\n\t/** for typedoc */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\t__export(__webpack_require__(53));\n\t__export(__webpack_require__(54));\n\t__export(__webpack_require__(56));\n\t__webpack_require__(57);\n\t__webpack_require__(58);\n\t__webpack_require__(59);\n\t__webpack_require__(60);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = \"ui.router\";\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module common */ /** */\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(2));\n\t__export(__webpack_require__(20));\n\t__export(__webpack_require__(44));\n\t__export(__webpack_require__(40));\n\t__export(__webpack_require__(17));\n\t__export(__webpack_require__(13));\n\t__export(__webpack_require__(45));\n\t__export(__webpack_require__(49));\n\t__export(__webpack_require__(51));\n\tvar router_1 = __webpack_require__(52);\n\texports.UIRouter = router_1.UIRouter;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module common */ /** for typedoc */\n\t__export(__webpack_require__(3));\n\t__export(__webpack_require__(6));\n\t__export(__webpack_require__(7));\n\t__export(__webpack_require__(5));\n\t__export(__webpack_require__(4));\n\t__export(__webpack_require__(8));\n\t__export(__webpack_require__(9));\n\t__export(__webpack_require__(12));\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Random utility functions used in the UI-Router code\n\t *\n\t * @preferred @module common\n\t */ /** for typedoc */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\tvar w = typeof window === 'undefined' ? {} : window;\n\tvar angular = w.angular || {};\n\texports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\n\texports.toJson = angular.toJson || JSON.stringify.bind(JSON);\n\texports.copy = angular.copy || _copy;\n\texports.forEach = angular.forEach || _forEach;\n\texports.extend = angular.extend || _extend;\n\texports.equals = angular.equals || _equals;\n\texports.identity = function (x) { return x; };\n\texports.noop = function () { return undefined; };\n\texports.abstractKey = 'abstract';\n\t/**\n\t * Binds and copies functions onto an object\n\t *\n\t * Takes functions from the 'from' object, binds those functions to the _this object, and puts the bound functions\n\t * on the 'to' object.\n\t *\n\t * This example creates an new class instance whose functions are prebound to the new'd object.\n\t * @example\n\t * ```\n\t *\n\t * class Foo {\n\t *   constructor(data) {\n\t *     // Binds all functions from Foo.prototype to 'this',\n\t *     // then copies them to 'this'\n\t *     bindFunctions(Foo.prototype, this, this);\n\t *     this.data = data;\n\t *   }\n\t *\n\t *   log() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * let myFoo = new Foo([1,2,3]);\n\t * var logit = myFoo.log;\n\t * logit(); // logs [1, 2, 3] from the myFoo 'this' instance\n\t * ```\n\t *\n\t * This example creates a bound version of a service function, and copies it to another object\n\t * @example\n\t * ```\n\t *\n\t * var SomeService = {\n\t *   this.data = [3, 4, 5];\n\t *   this.log = function() {\n\t *     console.log(this.data);\n\t *   }\n\t * }\n\t *\n\t * // Constructor fn\n\t * function OtherThing() {\n\t *   // Binds all functions from SomeService to SomeService,\n\t *   // then copies them to 'this'\n\t *   bindFunctions(SomeService, this, SomeService);\n\t * }\n\t *\n\t * let myOtherThing = new OtherThing();\n\t * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'\n\t * ```\n\t *\n\t * @param from The object which contains the functions to be bound\n\t * @param to The object which will receive the bound functions\n\t * @param bindTo The object which the functions will be bound to\n\t * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)\n\t */\n\tfunction bindFunctions(from, to, bindTo, fnNames) {\n\t    if (fnNames === void 0) { fnNames = Object.keys(from); }\n\t    return fnNames.filter(function (name) { return typeof from[name] === 'function'; })\n\t        .forEach(function (name) { return to[name] = from[name].bind(bindTo); });\n\t}\n\texports.bindFunctions = bindFunctions;\n\t/**\n\t * prototypal inheritance helper.\n\t * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n\t */\n\texports.inherit = function (parent, extra) {\n\t    return exports.extend(new (exports.extend(function () { }, { prototype: parent }))(), extra);\n\t};\n\t/**\n\t * Given an arguments object, converts the arguments at index idx and above to an array.\n\t * This is similar to es6 rest parameters.\n\t *\n\t * Optionally, the argument at index idx may itself already be an array.\n\t *\n\t * For example,\n\t * given either:\n\t *        arguments = [ obj, \"foo\", \"bar\" ]\n\t * or:\n\t *        arguments = [ obj, [\"foo\", \"bar\"] ]\n\t * then:\n\t *        restArgs(arguments, 1) == [\"foo\", \"bar\"]\n\t *\n\t * This allows functions like pick() to be implemented such that it allows either a bunch\n\t * of string arguments (like es6 rest parameters), or a single array of strings:\n\t *\n\t * given:\n\t *        var obj = { foo: 1, bar: 2, baz: 3 };\n\t * then:\n\t *        pick(obj, \"foo\", \"bar\");   // returns { foo: 1, bar: 2 }\n\t *        pick(obj, [\"foo\", \"bar\"]); // returns { foo: 1, bar: 2 }\n\t */\n\tvar restArgs = function (args, idx) {\n\t    if (idx === void 0) { idx = 0; }\n\t    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));\n\t};\n\t/** Given an array, returns true if the object is found in the array, (using indexOf) */\n\tvar inArray = function (array, obj) { return array.indexOf(obj) !== -1; };\n\t/** Given an array, and an item, if the item is found in the array, it removes it (in-place).  The same array is returned */\n\texports.removeFrom = hof_1.curry(function (array, obj) {\n\t    var idx = array.indexOf(obj);\n\t    if (idx >= 0)\n\t        array.splice(idx, 1);\n\t    return array;\n\t});\n\t/**\n\t * Applies a set of defaults to an options object.  The options object is filtered\n\t * to only those properties of the objects in the defaultsList.\n\t * Earlier objects in the defaultsList take precedence when applying defaults.\n\t */\n\tfunction defaults(opts) {\n\t    if (opts === void 0) { opts = {}; }\n\t    var defaultsList = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        defaultsList[_i - 1] = arguments[_i];\n\t    }\n\t    var defaults = merge.apply(null, [{}].concat(defaultsList));\n\t    return exports.extend({}, defaults, pick(opts || {}, Object.keys(defaults)));\n\t}\n\texports.defaults = defaults;\n\t/**\n\t * Merges properties from the list of objects to the destination object.\n\t * If a property already exists in the destination object, then it is not overwritten.\n\t */\n\tfunction merge(dst) {\n\t    var objs = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        objs[_i - 1] = arguments[_i];\n\t    }\n\t    exports.forEach(objs, function (obj) {\n\t        exports.forEach(obj, function (value, key) {\n\t            if (!dst.hasOwnProperty(key))\n\t                dst[key] = value;\n\t        });\n\t    });\n\t    return dst;\n\t}\n\texports.merge = merge;\n\t/** Reduce function that merges each element of the list into a single object, using extend */\n\texports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t    var path = [];\n\t    for (var n in first.path) {\n\t        if (first.path[n] !== second.path[n])\n\t            break;\n\t        path.push(first.path[n]);\n\t    }\n\t    return path;\n\t}\n\texports.ancestors = ancestors;\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t    if (keys === void 0) { keys = Object.keys(a); }\n\t    for (var i = 0; i < keys.length; i++) {\n\t        var k = keys[i];\n\t        if (a[k] != b[k])\n\t            return false; // Not '===', values aren't necessarily normalized\n\t    }\n\t    return true;\n\t}\n\texports.equalForKeys = equalForKeys;\n\tfunction pickOmitImpl(predicate, obj) {\n\t    var objCopy = {}, keys = restArgs(arguments, 2);\n\t    for (var key in obj) {\n\t        if (predicate(keys, key))\n\t            objCopy[key] = obj[key];\n\t    }\n\t    return objCopy;\n\t}\n\t/** Return a copy of the object only containing the whitelisted properties. */\n\tfunction pick(obj) { return pickOmitImpl.apply(null, [inArray].concat(restArgs(arguments))); }\n\texports.pick = pick;\n\t/** Return a copy of the object omitting the blacklisted properties. */\n\tfunction omit(obj) { return pickOmitImpl.apply(null, [hof_1.not(inArray)].concat(restArgs(arguments))); }\n\texports.omit = omit;\n\t/**\n\t * Maps an array, or object to a property (by name)\n\t */\n\tfunction pluck(collection, propName) {\n\t    return map(collection, hof_1.prop(propName));\n\t}\n\texports.pluck = pluck;\n\t/** Filters an Array or an Object's properties based on a predicate */\n\tfunction filter(collection, callback) {\n\t    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n\t    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n\t    exports.forEach(collection, function (item, i) {\n\t        if (callback(item, i))\n\t            accept(item, i);\n\t    });\n\t    return result;\n\t}\n\texports.filter = filter;\n\t/** Finds an object from an array, or a property of an object, that matches a predicate */\n\tfunction find(collection, callback) {\n\t    var result;\n\t    exports.forEach(collection, function (item, i) {\n\t        if (result)\n\t            return;\n\t        if (callback(item, i))\n\t            result = item;\n\t    });\n\t    return result;\n\t}\n\texports.find = find;\n\t/** Given an object, returns a new object, where each property is transformed by the callback function */\n\texports.mapObj = map;\n\t/** Maps an array or object properties using a callback function */\n\tfunction map(collection, callback) {\n\t    var result = predicates_1.isArray(collection) ? [] : {};\n\t    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n\t    return result;\n\t}\n\texports.map = map;\n\t/**\n\t * Given an object, return its enumerable property values\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = { a: 1, b: 2, c: 3 }\n\t * let vals = values(foo); // [ 1, 2, 3 ]\n\t * ```\n\t */\n\texports.values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };\n\t/**\n\t * Reduce function that returns true if all of the values are truthy.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let vals = [ 1, true, {}, \"hello world\"];\n\t * vals.reduce(allTrueR, true); // true\n\t *\n\t * vals.push(0);\n\t * vals.reduce(allTrueR, true); // false\n\t * ```\n\t */\n\texports.allTrueR = function (memo, elem) { return memo && elem; };\n\t/**\n\t * Reduce function that returns true if any of the values are truthy.\n\t *\n\t *  * @example\n\t * ```\n\t *\n\t * let vals = [ 0, null, undefined ];\n\t * vals.reduce(anyTrueR, true); // false\n\t *\n\t * vals.push(\"hello world\");\n\t * vals.reduce(anyTrueR, true); // true\n\t * ```\n\t */\n\texports.anyTrueR = function (memo, elem) { return memo || elem; };\n\t/**\n\t * Reduce function which un-nests a single level of arrays\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnestR = function (memo, elem) { return memo.concat(elem); };\n\t/**\n\t * Reduce function which recursively un-nests all arrays\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flattenR = function (memo, elem) { return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem); };\n\t/** Reduce function that pushes an object to an array, then returns the array.  Mostly just for [[flattenR]] */\n\tfunction pushR(arr, obj) { arr.push(obj); return arr; }\n\t/**\n\t * Return a new array with a single level of arrays unnested.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n\t * ```\n\t */\n\texports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n\t/**\n\t * Return a completely flattened version of an array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n\t * flatten(input) // [ \"a\", \"b\", \"c\", \"d\", \"double, \"nested\" ]\n\t * ```\n\t */\n\texports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n\t/**\n\t * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n\t * @example\n\t * ```\n\t *\n\t * let isNumber = (obj) => typeof(obj) === 'number';\n\t * let allNumbers = [ 1, 2, 3, 4, 5 ];\n\t * allNumbers.filter(assertPredicate(isNumber)); //OK\n\t *\n\t * let oneString = [ 1, 2, 3, 4, \"5\" ];\n\t * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n\t * ```\n\t */\n\tfunction assertPredicate(predicate, errMsg) {\n\t    if (errMsg === void 0) { errMsg = \"assert failure\"; }\n\t    return function (obj) {\n\t        if (!predicate(obj)) {\n\t            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n\t        }\n\t        return true;\n\t    };\n\t}\n\texports.assertPredicate = assertPredicate;\n\t/**\n\t * Like _.pairs: Given an object, returns an array of key/value pairs\n\t *\n\t * @example\n\t * ```\n\t *\n\t * pairs({ foo: \"FOO\", bar: \"BAR }) // [ [ \"foo\", \"FOO\" ], [ \"bar\": \"BAR\" ] ]\n\t * ```\n\t */\n\texports.pairs = function (object) { return Object.keys(object).map(function (key) { return [key, object[key]]; }); };\n\t/**\n\t * Given two or more parallel arrays, returns an array of tuples where\n\t * each tuple is composed of [ a[i], b[i], ... z[i] ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * let foo = [ 0, 2, 4, 6 ];\n\t * let bar = [ 1, 3, 5, 7 ];\n\t * let baz = [ 10, 30, 50, 70 ];\n\t * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n\t * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n\t * ```\n\t */\n\tfunction arrayTuples() {\n\t    var arrayArgs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        arrayArgs[_i - 0] = arguments[_i];\n\t    }\n\t    if (arrayArgs.length === 0)\n\t        return [];\n\t    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53  1 aka Number.MAX_SAFE_INTEGER\n\t    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }); });\n\t}\n\texports.arrayTuples = arrayTuples;\n\t/**\n\t * Reduce function which builds an object from an array of [key, value] pairs.\n\t *\n\t * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n\t *\n\t * Each keyValueTuple should be an array with values [ key: string, value: any ]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\t *\n\t * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t *\n\t * // Or, more simply:\n\t * var pairsToObj = pairs.reduce(applyPairs, {})\n\t * // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\t * ```\n\t */\n\tfunction applyPairs(memo, keyValTuple) {\n\t    var key, value;\n\t    if (predicates_1.isArray(keyValTuple))\n\t        key = keyValTuple[0], value = keyValTuple[1];\n\t    if (!predicates_1.isString(key))\n\t        throw new Error(\"invalid parameters to applyPairs\");\n\t    memo[key] = value;\n\t    return memo;\n\t}\n\texports.applyPairs = applyPairs;\n\t/** Get the last element of an array */\n\tfunction tail(arr) {\n\t    return arr.length && arr[arr.length - 1] || undefined;\n\t}\n\texports.tail = tail;\n\t/**\n\t * shallow copy from src to dest\n\t *\n\t * note: This is a shallow copy, while angular.copy is a deep copy.\n\t * ui-router uses `copy` only to make copies of state parameters.\n\t */\n\tfunction _copy(src, dest) {\n\t    if (dest)\n\t        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n\t    if (!dest)\n\t        dest = {};\n\t    return exports.extend(dest, src);\n\t}\n\tfunction _forEach(obj, cb, _this) {\n\t    if (predicates_1.isArray(obj))\n\t        return obj.forEach(cb, _this);\n\t    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n\t}\n\tfunction _copyProps(to, from) { Object.keys(from).forEach(function (key) { return to[key] = from[key]; }); return to; }\n\tfunction _extend(toObj, rest) {\n\t    return restArgs(arguments, 1).filter(exports.identity).reduce(_copyProps, toObj);\n\t}\n\tfunction _equals(o1, o2) {\n\t    if (o1 === o2)\n\t        return true;\n\t    if (o1 === null || o2 === null)\n\t        return false;\n\t    if (o1 !== o1 && o2 !== o2)\n\t        return true; // NaN === NaN\n\t    var t1 = typeof o1, t2 = typeof o2;\n\t    if (t1 !== t2 || t1 !== 'object')\n\t        return false;\n\t    var tup = [o1, o2];\n\t    if (hof_1.all(predicates_1.isArray)(tup))\n\t        return _arraysEq(o1, o2);\n\t    if (hof_1.all(predicates_1.isDate)(tup))\n\t        return o1.getTime() === o2.getTime();\n\t    if (hof_1.all(predicates_1.isRegExp)(tup))\n\t        return o1.toString() === o2.toString();\n\t    if (hof_1.all(predicates_1.isFunction)(tup))\n\t        return true; // meh\n\t    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n\t    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n\t        return false;\n\t    var key, keys = {};\n\t    for (key in o1) {\n\t        if (!_equals(o1[key], o2[key]))\n\t            return false;\n\t        keys[key] = true;\n\t    }\n\t    for (key in o2) {\n\t        if (!keys[key])\n\t            return false;\n\t    }\n\t    return true;\n\t}\n\tfunction _arraysEq(a1, a2) {\n\t    if (a1.length !== a2.length)\n\t        return false;\n\t    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n\t}\n\t//\n\t//const _addToGroup = (result, keyFn) => (item) =>\n\t//  (result[keyFn(item)] = result[keyFn(item)] || []).push(item) && result;\n\t//const groupBy = (array, keyFn) => array.reduce((memo, item) => _addToGroup(memo, keyFn), {});\n\t//\n\t//\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** Predicates @module common_predicates */ /** */\n\tvar hof_1 = __webpack_require__(5);\n\tvar toStr = Object.prototype.toString;\n\tvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\n\texports.isUndefined = tis('undefined');\n\texports.isDefined = hof_1.not(exports.isUndefined);\n\texports.isNull = function (o) { return o === null; };\n\texports.isFunction = tis('function');\n\texports.isNumber = tis('number');\n\texports.isString = tis('string');\n\texports.isObject = function (x) { return x !== null && typeof x === 'object'; };\n\texports.isArray = Array.isArray;\n\texports.isDate = function (x) { return toStr.call(x) === '[object Date]'; };\n\texports.isRegExp = function (x) { return toStr.call(x) === '[object RegExp]'; };\n\t/**\n\t * Predicate which checks if a value is injectable\n\t *\n\t * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n\t * where all the elements in the array are Strings, except the last one, which is a Function\n\t */\n\tfunction isInjectable(val) {\n\t    if (exports.isArray(val) && val.length) {\n\t        var head = val.slice(0, -1), tail = val.slice(-1);\n\t        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n\t    }\n\t    return exports.isFunction(val);\n\t}\n\texports.isInjectable = isInjectable;\n\t/**\n\t * Predicate which checks if a value looks like a Promise\n\t *\n\t * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n\t */\n\texports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Higher order functions\n\t *\n\t * @module common_hof\n\t */\n\t\"use strict\";\n\t/**\n\t * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n\t *\n\t * Given a function with N parameters, returns a new function that supports partial application.\n\t * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n\t * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n\t * accept more parameters until all N parameters have been supplied.\n\t *\n\t *\n\t * This contrived example uses a partially applied function as an predicate, which returns true\n\t * if an object is found in both arrays.\n\t * @example\n\t * ```\n\t * // returns true if an object is in both of the two arrays\n\t * function inBoth(array1, array2, object) {\n\t *   return array1.indexOf(object) !== -1 &&\n\t *          array2.indexOf(object) !== 1;\n\t * }\n\t * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n\t * let foos = [obj1, obj3]\n\t * let bars = [obj3, obj4, obj5]\n\t *\n\t * // A curried \"copy\" of inBoth\n\t * let curriedInBoth = curry(inBoth);\n\t * // Partially apply both the array1 and array2\n\t * let inFoosAndBars = curriedInBoth(foos, bars);\n\t *\n\t * // Supply the final argument; since all arguments are\n\t * // supplied, the original inBoth function is then called.\n\t * let obj1InBoth = inFoosAndBars(obj1); // false\n\t *\n\t * // Use the inFoosAndBars as a predicate.\n\t * // Filter, on each iteration, supplies the final argument\n\t * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n\t * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n\t *\n\t * ```\n\t *\n\t * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n\t *\n\t * @param fn\n\t * @returns {*|function(): (*|any)}\n\t */\n\tfunction curry(fn) {\n\t    var initial_args = [].slice.apply(arguments, [1]);\n\t    var func_args_length = fn.length;\n\t    function curried(args) {\n\t        if (args.length >= func_args_length)\n\t            return fn.apply(null, args);\n\t        return function () {\n\t            return curried(args.concat([].slice.apply(arguments)));\n\t        };\n\t    }\n\t    return curried(initial_args);\n\t}\n\texports.curry = curry;\n\t/**\n\t * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n\t * given: f(x), g(x), h(x)\n\t * let composed = compose(f,g,h)\n\t * then, composed is: f(g(h(x)))\n\t */\n\tfunction compose() {\n\t    var args = arguments;\n\t    var start = args.length - 1;\n\t    return function () {\n\t        var i = start, result = args[start].apply(this, arguments);\n\t        while (i--)\n\t            result = args[i].call(this, result);\n\t        return result;\n\t    };\n\t}\n\texports.compose = compose;\n\t/**\n\t * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n\t * given: f(x), g(x), h(x)\n\t * let piped = pipe(f,g,h);\n\t * then, piped is: h(g(f(x)))\n\t */\n\tfunction pipe() {\n\t    var funcs = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        funcs[_i - 0] = arguments[_i];\n\t    }\n\t    return compose.apply(null, [].slice.call(arguments).reverse());\n\t}\n\texports.pipe = pipe;\n\t/**\n\t * Given a property name, returns a function that returns that property from an object\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = prop(\"name\");\n\t * getName(obj) === \"blarg\"\n\t */\n\texports.prop = function (name) { return function (obj) { return obj && obj[name]; }; };\n\t/**\n\t * Given a property name and a value, returns a function that returns a boolean based on whether\n\t * the passed object has a property that matches the value\n\t * let obj = { foo: 1, name: \"blarg\" };\n\t * let getName = propEq(\"name\", \"blarg\");\n\t * getName(obj) === true\n\t */\n\texports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n\t/**\n\t * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n\t * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n\t * let getName = prop(\"nestedObj.name\");\n\t * getName(obj) === \"blarg\"\n\t * let propNotFound = prop(\"this.property.doesnt.exist\");\n\t * propNotFound(obj) === undefined\n\t */\n\texports.parse = function (name) { return pipe.apply(null, name.split(\".\").map(exports.prop)); };\n\t/**\n\t * Given a function that returns a truthy or falsey value, returns a\n\t * function that returns the opposite (falsey or truthy) value given the same inputs\n\t */\n\texports.not = function (fn) { return function () {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i - 0] = arguments[_i];\n\t    }\n\t    return !fn.apply(null, args);\n\t}; };\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if both functions return truthy for the given arguments\n\t */\n\tfunction and(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) && fn2.apply(null, args);\n\t    };\n\t}\n\texports.and = and;\n\t/**\n\t * Given two functions that return truthy or falsey values, returns a function that returns truthy\n\t * if at least one of the functions returns truthy for the given arguments\n\t */\n\tfunction or(fn1, fn2) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        return fn1.apply(null, args) || fn2.apply(null, args);\n\t    };\n\t}\n\texports.or = or;\n\t/**\n\t * Check if all the elements of an array match a predicate function\n\t *\n\t * @param fn1 a predicate function `fn1`\n\t * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n\t */\n\texports.all = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); }; };\n\texports.any = function (fn1) { return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); }; };\n\texports.none = exports.not(exports.any);\n\t/** Given a class, returns a Predicate function that returns true if the object is of that class */\n\texports.is = function (ctor) { return function (obj) { return (obj != null && obj.constructor === ctor || obj instanceof ctor); }; };\n\t/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\n\texports.eq = function (val) { return function (other) { return val === other; }; };\n\t/** Given a value, returns a function which returns the value */\n\texports.val = function (v) { return function () { return v; }; };\n\tfunction invoke(fnName, args) {\n\t    return function (obj) { return obj[fnName].apply(obj, args); };\n\t}\n\texports.invoke = invoke;\n\t/**\n\t * Sorta like Pattern Matching (a functional programming conditional construct)\n\t *\n\t * See http://c2.com/cgi/wiki?PatternMatching\n\t *\n\t * This is a conditional construct which allows a series of predicates and output functions\n\t * to be checked and then applied.  Each predicate receives the input.  If the predicate\n\t * returns truthy, then its matching output function (mapping function) is provided with\n\t * the input and, then the result is returned.\n\t *\n\t * Each combination (2-tuple) of predicate + output function should be placed in an array\n\t * of size 2: [ predicate, mapFn ]\n\t *\n\t * These 2-tuples should be put in an outer array.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * // Here's a 2-tuple where the first element is the isString predicate\n\t * // and the second element is a function that returns a description of the input\n\t * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\t *\n\t * // Second tuple: predicate \"isNumber\", mapfn returns a description\n\t * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\t *\n\t * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\t *\n\t * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\t *\n\t * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\t *\n\t * console.log(descriptionOf(undefined)); // 'notdefined'\n\t * console.log(descriptionOf(55)); // '(55) That's a number!'\n\t * console.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n\t * ```\n\t *\n\t * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n\t * with a Predicate and a mapping/output function\n\t * @returns {function(any): *}\n\t */\n\tfunction pattern(struct) {\n\t    return function (x) {\n\t        for (var i = 0; i < struct.length; i++) {\n\t            if (struct[i][0](x))\n\t                return struct[i][1](x);\n\t        }\n\t    };\n\t}\n\texports.pattern = pattern;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This module is a stub for core services such as Dependency Injection or Browser Location.\n\t * Core services may be implemented by a specific framework, such as ng1 or ng2, or be pure javascript.\n\t *\n\t * @module common\n\t */\n\t\"use strict\";\n\t/** for typedoc */\n\t//import {IQService} from \"angular\";\n\t//import {IInjectorService} from \"angular\";\n\tvar notImplemented = function (fnname) { return function () {\n\t    throw new Error(fnname + \"(): No coreservices implementation for UI-Router is loaded. You should include one of: ['angular1.js']\");\n\t}; };\n\tvar services = {\n\t    $q: undefined,\n\t    $injector: undefined,\n\t    location: {},\n\t    locationConfig: {},\n\t    template: {}\n\t};\n\texports.services = services;\n\t[\"replace\", \"url\", \"path\", \"search\", \"hash\", \"onChange\"]\n\t    .forEach(function (key) { return services.location[key] = notImplemented(key); });\n\t[\"port\", \"protocol\", \"host\", \"baseHref\", \"html5Mode\", \"hashPrefix\"]\n\t    .forEach(function (key) { return services.locationConfig[key] = notImplemented(key); });\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar Glob = (function () {\n\t    function Glob(text) {\n\t        this.text = text;\n\t        this.glob = text.split('.');\n\t    }\n\t    Glob.prototype.matches = function (name) {\n\t        var segments = name.split('.');\n\t        // match single stars\n\t        for (var i = 0, l = this.glob.length; i < l; i++) {\n\t            if (this.glob[i] === '*')\n\t                segments[i] = '*';\n\t        }\n\t        // match greedy starts\n\t        if (this.glob[0] === '**') {\n\t            segments = segments.slice(segments.indexOf(this.glob[1]));\n\t            segments.unshift('**');\n\t        }\n\t        // match greedy ends\n\t        if (this.glob[this.glob.length - 1] === '**') {\n\t            segments.splice(segments.indexOf(this.glob[this.glob.length - 2]) + 1, Number.MAX_VALUE);\n\t            segments.push('**');\n\t        }\n\t        if (this.glob.length != segments.length)\n\t            return false;\n\t        return segments.join('') === this.glob.join('');\n\t    };\n\t    Glob.is = function (text) {\n\t        return text.indexOf('*') > -1;\n\t    };\n\t    Glob.fromString = function (text) {\n\t        if (!this.is(text))\n\t            return null;\n\t        return new Glob(text);\n\t    };\n\t    return Glob;\n\t}());\n\texports.Glob = Glob;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/** @module common */ /** for typedoc */\n\t\"use strict\";\n\tvar Queue = (function () {\n\t    function Queue(_items, _limit) {\n\t        if (_items === void 0) { _items = []; }\n\t        if (_limit === void 0) { _limit = null; }\n\t        this._items = _items;\n\t        this._limit = _limit;\n\t    }\n\t    Queue.prototype.enqueue = function (item) {\n\t        var items = this._items;\n\t        items.push(item);\n\t        if (this._limit && items.length > this._limit)\n\t            items.shift();\n\t        return item;\n\t    };\n\t    Queue.prototype.dequeue = function () {\n\t        if (this.size())\n\t            return this._items.splice(0, 1)[0];\n\t    };\n\t    Queue.prototype.clear = function () {\n\t        var current = this._items;\n\t        this._items = [];\n\t        return current;\n\t    };\n\t    Queue.prototype.size = function () {\n\t        return this._items.length;\n\t    };\n\t    Queue.prototype.remove = function (item) {\n\t        var idx = this._items.indexOf(item);\n\t        return idx > -1 && this._items.splice(idx, 1)[0];\n\t    };\n\t    Queue.prototype.peekTail = function () {\n\t        return this._items[this._items.length - 1];\n\t    };\n\t    Queue.prototype.peekHead = function () {\n\t        if (this.size())\n\t            return this._items[0];\n\t    };\n\t    return Queue;\n\t}());\n\texports.Queue = Queue;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module common_strings */ /** */\n\t\"use strict\";\n\tvar predicates_1 = __webpack_require__(4);\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar transition_1 = __webpack_require__(11);\n\tvar resolvable_1 = __webpack_require__(32);\n\t/**\n\t * Returns a string shortened to a maximum length\n\t *\n\t * If the string is already less than the `max` length, return the string.\n\t * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n\t *\n\t * @param max the maximum length of the string to return\n\t * @param str the input string\n\t */\n\tfunction maxLength(max, str) {\n\t    if (str.length <= max)\n\t        return str;\n\t    return str.substr(0, max - 3) + \"...\";\n\t}\n\texports.maxLength = maxLength;\n\t/**\n\t * Returns a string, with spaces added to the end, up to a desired str length\n\t *\n\t * If the string is already longer than the desired length, return the string.\n\t * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n\t *\n\t * @param length the desired length of the string to return\n\t * @param str the input string\n\t */\n\tfunction padString(length, str) {\n\t    while (str.length < length)\n\t        str += \" \";\n\t    return str;\n\t}\n\texports.padString = padString;\n\tfunction kebobString(camelCase) {\n\t    return camelCase\n\t        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n\t        .replace(/([A-Z])/g, function ($1) { return \"-\" + $1.toLowerCase(); }); // replace rest\n\t}\n\texports.kebobString = kebobString;\n\tfunction _toJson(obj) {\n\t    return JSON.stringify(obj);\n\t}\n\tfunction _fromJson(json) {\n\t    return predicates_1.isString(json) ? JSON.parse(json) : json;\n\t}\n\tfunction promiseToString(p) {\n\t    return \"Promise(\" + JSON.stringify(p) + \")\";\n\t}\n\tfunction functionToString(fn) {\n\t    var fnStr = fnToString(fn);\n\t    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\t    return namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\t}\n\texports.functionToString = functionToString;\n\tfunction fnToString(fn) {\n\t    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n\t    return _fn && _fn.toString() || \"undefined\";\n\t}\n\texports.fnToString = fnToString;\n\tvar isTransitionRejectionPromise = rejectFactory_1.Rejection.isTransitionRejectionPromise;\n\tvar stringifyPattern = hof_1.pattern([\n\t    [hof_1.not(predicates_1.isDefined), hof_1.val(\"undefined\")],\n\t    [predicates_1.isNull, hof_1.val(\"null\")],\n\t    [predicates_1.isPromise, promiseToString],\n\t    [isTransitionRejectionPromise, function (x) { return x._transitionRejection.toString(); }],\n\t    [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke(\"toString\")],\n\t    [hof_1.is(transition_1.Transition), hof_1.invoke(\"toString\")],\n\t    [hof_1.is(resolvable_1.Resolvable), hof_1.invoke(\"toString\")],\n\t    [predicates_1.isInjectable, functionToString],\n\t    [hof_1.val(true), common_1.identity]\n\t]);\n\tfunction stringify(o) {\n\t    var seen = [];\n\t    function format(val) {\n\t        if (predicates_1.isObject(val)) {\n\t            if (seen.indexOf(val) !== -1)\n\t                return '[circular ref]';\n\t            seen.push(val);\n\t        }\n\t        return stringifyPattern(val);\n\t    }\n\t    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\\"/g, '\"');\n\t}\n\texports.stringify = stringify;\n\t/** Returns a function that splits a string on a character or substring */\n\texports.beforeAfterSubstr = function (char) { return function (str) {\n\t    if (!str)\n\t        return [\"\", \"\"];\n\t    var idx = str.indexOf(char);\n\t    if (idx === -1)\n\t        return [str, \"\"];\n\t    return [str.substr(0, idx), str.substr(idx + 1)];\n\t}; };\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module transition */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar strings_1 = __webpack_require__(9);\n\t(function (RejectType) {\n\t    RejectType[RejectType[\"SUPERSEDED\"] = 2] = \"SUPERSEDED\";\n\t    RejectType[RejectType[\"ABORTED\"] = 3] = \"ABORTED\";\n\t    RejectType[RejectType[\"INVALID\"] = 4] = \"INVALID\";\n\t    RejectType[RejectType[\"IGNORED\"] = 5] = \"IGNORED\";\n\t})(exports.RejectType || (exports.RejectType = {}));\n\tvar RejectType = exports.RejectType;\n\tvar Rejection = (function () {\n\t    function Rejection(type, message, detail) {\n\t        this.type = type;\n\t        this.message = message;\n\t        this.detail = detail;\n\t    }\n\t    Rejection.prototype.toString = function () {\n\t        var detailString = function (d) { return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d); };\n\t        var type = this.type, message = this.message, detail = detailString(this.detail);\n\t        return \"TransitionRejection(type: \" + type + \", message: \" + message + \", detail: \" + detail + \")\";\n\t    };\n\t    Rejection.prototype.toPromise = function () {\n\t        return common_1.extend(coreservices_1.services.$q.reject(this), { _transitionRejection: this });\n\t    };\n\t    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n\t    Rejection.isTransitionRejectionPromise = function (obj) {\n\t        return obj && (typeof obj.then === 'function') && obj._transitionRejection instanceof Rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to transition superseded */\n\t    Rejection.superseded = function (detail, options) {\n\t        var message = \"The transition has been superseded by a different transition (see detail).\";\n\t        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n\t        if (options && options.redirected) {\n\t            rejection.redirected = true;\n\t        }\n\t        return rejection;\n\t    };\n\t    /** Returns a TransitionRejection due to redirected transition */\n\t    Rejection.redirected = function (detail) {\n\t        return Rejection.superseded(detail, { redirected: true });\n\t    };\n\t    /** Returns a TransitionRejection due to invalid transition */\n\t    Rejection.invalid = function (detail) {\n\t        var message = \"This transition is invalid (see detail)\";\n\t        return new Rejection(RejectType.INVALID, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to ignored transition */\n\t    Rejection.ignored = function (detail) {\n\t        var message = \"The transition was ignored.\";\n\t        return new Rejection(RejectType.IGNORED, message, detail);\n\t    };\n\t    /** Returns a TransitionRejection due to aborted transition */\n\t    Rejection.aborted = function (detail) {\n\t        // TODO think about how to encapsulate an Error() object\n\t        var message = \"The transition has been aborted.\";\n\t        return new Rejection(RejectType.ABORTED, message, detail);\n\t    };\n\t    return Rejection;\n\t}());\n\texports.Rejection = Rejection;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module transition */ /** for typedoc */\n\tvar trace_1 = __webpack_require__(12);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\tvar module_1 = __webpack_require__(13);\n\tvar node_1 = __webpack_require__(39);\n\tvar pathFactory_1 = __webpack_require__(38);\n\tvar module_2 = __webpack_require__(17);\n\tvar module_3 = __webpack_require__(20);\n\tvar module_4 = __webpack_require__(40);\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar transitionCount = 0;\n\tvar stateSelf = hof_1.prop(\"self\");\n\t/**\n\t * The representation of a transition between two states.\n\t *\n\t * Contains all contextual information about the to/from states, parameters, resolves, as well as the\n\t * list of states being entered and exited as a result of this transition.\n\t */\n\tvar Transition = (function () {\n\t    /**\n\t     * Creates a new Transition object.\n\t     *\n\t     * If the target state is not valid, an error is thrown.\n\t     *\n\t     * @param fromPath The path of [[Node]]s from which the transition is leaving.  The last node in the `fromPath`\n\t     *        encapsulates the \"from state\".\n\t     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n\t     * @param _transitionService The Transition Service instance\n\t     */\n\t    function Transition(fromPath, targetState, _transitionService) {\n\t        var _this = this;\n\t        this._transitionService = _transitionService;\n\t        this._deferred = coreservices_1.services.$q.defer();\n\t        /**\n\t         * This promise is resolved or rejected based on the outcome of the Transition.\n\t         *\n\t         * When the transition is successful, the promise is resolved\n\t         * When the transition is unsuccessful, the promise is rejected with the [[TransitionRejection]] or javascript error\n\t         */\n\t        this.promise = this._deferred.promise;\n\t        this.treeChanges = function () { return _this._treeChanges; };\n\t        this.isActive = function () { return _this === _this._options.current(); };\n\t        if (!targetState.valid()) {\n\t            throw new Error(targetState.error());\n\t        }\n\t        // Makes the Transition instance a hook registry (onStart, etc)\n\t        module_1.HookRegistry.mixin(new module_1.HookRegistry(), this);\n\t        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n\t        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n\t        this.$id = transitionCount++;\n\t        var toPath = pathFactory_1.PathFactory.buildToPath(fromPath, targetState);\n\t        toPath = pathFactory_1.PathFactory.applyViewConfigs(_transitionService.$view, toPath);\n\t        this._treeChanges = pathFactory_1.PathFactory.treeChanges(fromPath, toPath, this._options.reloadState);\n\t        pathFactory_1.PathFactory.bindTransitionResolve(this._treeChanges, this);\n\t    }\n\t    Transition.prototype.$from = function () {\n\t        return common_1.tail(this._treeChanges.from).state;\n\t    };\n\t    Transition.prototype.$to = function () {\n\t        return common_1.tail(this._treeChanges.to).state;\n\t    };\n\t    /**\n\t     * Returns the \"from state\"\n\t     *\n\t     * @returns The state object for the Transition's \"from state\".\n\t     */\n\t    Transition.prototype.from = function () {\n\t        return this.$from().self;\n\t    };\n\t    /**\n\t     * Returns the \"to state\"\n\t     *\n\t     * @returns The state object for the Transition's target state (\"to state\").\n\t     */\n\t    Transition.prototype.to = function () {\n\t        return this.$to().self;\n\t    };\n\t    /**\n\t     * Determines whether two transitions are equivalent.\n\t     */\n\t    Transition.prototype.is = function (compare) {\n\t        if (compare instanceof Transition) {\n\t            // TODO: Also compare parameters\n\t            return this.is({ to: compare.$to().name, from: compare.$from().name });\n\t        }\n\t        return !((compare.to && !module_1.matchState(this.$to(), compare.to)) ||\n\t            (compare.from && !module_1.matchState(this.$from(), compare.from)));\n\t    };\n\t    /**\n\t     * Gets transition parameter values\n\t     *\n\t     * @param pathname Pick which treeChanges path to get parameters for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @returns transition parameter values for the desired path.\n\t     */\n\t    Transition.prototype.params = function (pathname) {\n\t        if (pathname === void 0) { pathname = \"to\"; }\n\t        return this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {});\n\t    };\n\t    /**\n\t     * Get resolved data\n\t     *\n\t     * @returns an object (key/value pairs) where keys are resolve names and values are any settled resolve data,\n\t     *    or `undefined` for pending resolve data\n\t     */\n\t    Transition.prototype.resolves = function () {\n\t        return common_1.map(common_1.tail(this._treeChanges.to).resolveContext.getResolvables(), function (res) { return res.data; });\n\t    };\n\t    /**\n\t     * Adds new resolves to this transition.\n\t     *\n\t     * @param resolves an [[ResolveDeclarations]] object which describes the new resolves\n\t     * @param state the state in the \"to path\" which should receive the new resolves (otherwise, the root state)\n\t     */\n\t    Transition.prototype.addResolves = function (resolves, state) {\n\t        if (state === void 0) { state = \"\"; }\n\t        var stateName = (typeof state === \"string\") ? state : state.name;\n\t        var topath = this._treeChanges.to;\n\t        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n\t        common_1.tail(topath).resolveContext.addResolvables(module_4.Resolvable.makeResolvables(resolves), targetNode.state);\n\t    };\n\t    /**\n\t     * Gets the previous transition, from which this transition was redirected.\n\t     *\n\t     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n\t     */\n\t    Transition.prototype.previous = function () {\n\t        return this._options.previous || null;\n\t    };\n\t    /**\n\t     * Get the transition options\n\t     *\n\t     * @returns the options for this Transition.\n\t     */\n\t    Transition.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    /**\n\t     * Gets the states being entered.\n\t     *\n\t     * @returns an array of states that will be entered during this transition.\n\t     */\n\t    Transition.prototype.entering = function () {\n\t        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Gets the states being exited.\n\t     *\n\t     * @returns an array of states that will be exited during this transition.\n\t     */\n\t    Transition.prototype.exiting = function () {\n\t        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n\t    };\n\t    /**\n\t     * Gets the states being retained.\n\t     *\n\t     * @returns an array of states that are already entered from a previous Transition, that will not be\n\t     *    exited during this Transition\n\t     */\n\t    Transition.prototype.retained = function () {\n\t        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n\t    };\n\t    /**\n\t     * Get the [[ViewConfig]]s associated with this Transition\n\t     *\n\t     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n\t     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n\t     *\n\t     * @param pathname the name of the path to fetch views for:\n\t     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n\t     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n\t     *\n\t     * @returns a list of ViewConfig objects for the given path.\n\t     */\n\t    Transition.prototype.views = function (pathname, state) {\n\t        if (pathname === void 0) { pathname = \"entering\"; }\n\t        var path = this._treeChanges[pathname];\n\t        path = !state ? path : path.filter(hof_1.propEq('state', state));\n\t        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.type:Transition#redirect\n\t     * @methodOf ui.router.state.type:Transition\n\t     *\n\t     * @description\n\t     * Creates a new transition that is a redirection of the current one. This transition can\n\t     * be returned from a `$transitionsProvider` hook, `$state` event, or other method, to\n\t     * redirect a transition to a new state and/or set of parameters.\n\t     *\n\t     * @returns {Transition} Returns a new `Transition` instance.\n\t     */\n\t    Transition.prototype.redirect = function (targetState) {\n\t        var newOptions = common_1.extend({}, this.options(), targetState.options(), { previous: this });\n\t        targetState = new module_2.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);\n\t        var redirectTo = new Transition(this._treeChanges.from, targetState, this._transitionService);\n\t        var reloadState = targetState.options().reloadState;\n\t        // If the current transition has already resolved any resolvables which are also in the redirected \"to path\", then\n\t        // add those resolvables to the redirected transition.  Allows you to define a resolve at a parent level, wait for\n\t        // the resolve, then redirect to a child state based on the result, and not have to re-fetch the resolve.\n\t        var redirectedPath = this.treeChanges().to;\n\t        var copyResolvesFor = node_1.Node.matching(redirectTo.treeChanges().to, redirectedPath)\n\t            .filter(function (node) { return !reloadState || !reloadState.includes[node.state.name]; });\n\t        var includeResolve = function (resolve, key) { return ['$stateParams', '$transition$'].indexOf(key) === -1; };\n\t        copyResolvesFor.forEach(function (node, idx) { return common_1.extend(node.resolves, common_1.filter(redirectedPath[idx].resolves, includeResolve)); });\n\t        return redirectTo;\n\t    };\n\t    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n\t    Transition.prototype._changedParams = function () {\n\t        var _a = this._treeChanges, to = _a.to, from = _a.from;\n\t        if (this._options.reload || common_1.tail(to).state !== common_1.tail(from).state)\n\t            return undefined;\n\t        var nodeSchemas = to.map(function (node) { return node.paramSchema; });\n\t        var _b = [to, from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _b[0], fromValues = _b[1];\n\t        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n\t        return tuples.map(function (_a) {\n\t            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n\t            return module_3.Param.changed(schema, toVals, fromVals);\n\t        }).reduce(common_1.unnestR, []);\n\t    };\n\t    /**\n\t     * Returns true if the transition is dynamic.\n\t     *\n\t     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n\t     *\n\t     * @returns true if the Transition is dynamic\n\t     */\n\t    Transition.prototype.dynamic = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n\t    };\n\t    /**\n\t     * Returns true if the transition is ignored.\n\t     *\n\t     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n\t     *\n\t     * @returns true if the Transition is ignored.\n\t     */\n\t    Transition.prototype.ignored = function () {\n\t        var changes = this._changedParams();\n\t        return !changes ? false : changes.length === 0;\n\t    };\n\t    /**\n\t     * @hidden\n\t     */\n\t    Transition.prototype.hookBuilder = function () {\n\t        return new module_1.HookBuilder(this._transitionService, this, {\n\t            transition: this,\n\t            current: this._options.current\n\t        });\n\t    };\n\t    /**\n\t     * Runs the transition\n\t     *\n\t     * This method is generally called from the [[StateService.transitionTo]]\n\t     *\n\t     * @returns a promise for a successful transition.\n\t     */\n\t    Transition.prototype.run = function () {\n\t        var _this = this;\n\t        var hookBuilder = this.hookBuilder();\n\t        var runSynchronousHooks = module_1.TransitionHook.runSynchronousHooks;\n\t        // TODO: nuke these in favor of chaining off the promise, i.e.,\n\t        // $transitions.onBefore({}, $transition$ => {$transition$.promise.then()}\n\t        var runSuccessHooks = function () { return runSynchronousHooks(hookBuilder.getOnSuccessHooks(), {}, true); };\n\t        var runErrorHooks = function ($error$) { return runSynchronousHooks(hookBuilder.getOnErrorHooks(), { $error$: $error$ }, true); };\n\t        // Run the success/error hooks *after* the Transition promise is settled.\n\t        this.promise.then(runSuccessHooks, runErrorHooks);\n\t        var syncResult = runSynchronousHooks(hookBuilder.getOnBeforeHooks());\n\t        if (rejectFactory_1.Rejection.isTransitionRejectionPromise(syncResult)) {\n\t            syncResult.catch(function () { return 0; }); // issue #2676\n\t            var rejectReason = syncResult._transitionRejection;\n\t            this._deferred.reject(rejectReason);\n\t            return this.promise;\n\t        }\n\t        if (!this.valid()) {\n\t            var error = new Error(this.error());\n\t            this._deferred.reject(error);\n\t            return this.promise;\n\t        }\n\t        if (this.ignored()) {\n\t            trace_1.trace.traceTransitionIgnored(this);\n\t            this._deferred.reject(rejectFactory_1.Rejection.ignored());\n\t            return this.promise;\n\t        }\n\t        // When the chain is complete, then resolve or reject the deferred\n\t        var resolve = function () {\n\t            _this.success = true;\n\t            _this._deferred.resolve(_this);\n\t            trace_1.trace.traceSuccess(_this.$to(), _this);\n\t        };\n\t        var reject = function (error) {\n\t            _this.success = false;\n\t            _this._deferred.reject(error);\n\t            trace_1.trace.traceError(error, _this);\n\t            return coreservices_1.services.$q.reject(error);\n\t        };\n\t        trace_1.trace.traceTransitionStart(this);\n\t        var chain = hookBuilder.asyncHooks().reduce(function (_chain, step) { return _chain.then(step.invokeHook.bind(step)); }, syncResult);\n\t        chain.then(resolve, reject);\n\t        return this.promise;\n\t    };\n\t    /**\n\t     * Checks if the Transition is valid\n\t     *\n\t     * @returns true if the Transition is valid\n\t     */\n\t    Transition.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    /**\n\t     * The reason the Transition is invalid\n\t     *\n\t     * @returns an error message explaining why the transition is invalid\n\t     */\n\t    Transition.prototype.error = function () {\n\t        var state = this.$to();\n\t        if (state.self[common_1.abstractKey])\n\t            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n\t        if (!module_3.Param.validates(state.parameters(), this.params()))\n\t            return \"Param values not valid for state '\" + state.name + \"'\";\n\t    };\n\t    /**\n\t     * A string representation of the Transition\n\t     *\n\t     * @returns A string representation of the Transition\n\t     */\n\t    Transition.prototype.toString = function () {\n\t        var fromStateOrName = this.from();\n\t        var toStateOrName = this.to();\n\t        var avoidEmptyHash = function (params) {\n\t            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, \"#\");\n\t        };\n\t        // (X) means the to state is invalid.\n\t        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));\n\t        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n\t    };\n\t    return Transition;\n\t}());\n\texports.Transition = Transition;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * UI-Router Transition Tracing\n\t *\n\t * Enable transition tracing to print transition information to the console, in order to help debug your application.\n\t * Tracing logs detailed information about each Transition to your console.\n\t *\n\t * To enable tracing, import the [[trace]] singleton and enable one or more categories.\n\t *\n\t * ES6\n\t * ```\n\t *\n\t * import {trace} from \"ui-router-ng2\"; // or \"angular-ui-router\"\n\t * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n\t * ```\n\t *\n\t * CJS\n\t * ```\n\t *\n\t * let trace = require(\"angular-ui-router\").trace; // or \"ui-router-ng2\"\n\t * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n\t * ```\n\t *\n\t * Globals\n\t * ```\n\t *\n\t * let trace = window[\"angular-ui-router\"].trace; // or \"ui-router-ng2\"\n\t * trace.enable(); // Trace everything (very verbose)\n\t * ```\n\t *\n\t * @module trace\n\t */ /** for typedoc */\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar strings_1 = __webpack_require__(9);\n\t/** @hidden */\n\tfunction uiViewString(viewData) {\n\t    if (!viewData)\n\t        return 'ui-view (defunct)';\n\t    return \"[ui-view#\" + viewData.id + \" tag in template from '\" + (viewData.creationContext.name || '(root)') + \"' state]: fqn: '\" + viewData.fqn + \"', name: '\" + viewData.name + \"@\" + viewData.creationContext + \"')\";\n\t}\n\t/** @hidden */\n\tvar viewConfigString = function (viewConfig) {\n\t    return (\"[ViewConfig from '\" + (viewConfig.viewDecl.$context.name || '(root)') + \"' state]: target ui-view: '\" + viewConfig.viewDecl.$uiViewName + \"@\" + viewConfig.viewDecl.$uiViewContextAnchor + \"'\");\n\t};\n\t/** @hidden */\n\tfunction normalizedCat(input) {\n\t    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n\t}\n\t/**\n\t * Trace categories\n\t *\n\t * [[Trace.enable]] or [[Trace.disable]] a category\n\t *\n\t * `trace.enable(Category.TRANSITION)`\n\t *\n\t * These can also be provided using a matching string, or position ordinal\n\t *\n\t * `trace.enable(\"TRANSITION\")`\n\t *\n\t * `trace.enable(1)`\n\t */\n\t(function (Category) {\n\t    Category[Category[\"RESOLVE\"] = 0] = \"RESOLVE\";\n\t    Category[Category[\"TRANSITION\"] = 1] = \"TRANSITION\";\n\t    Category[Category[\"HOOK\"] = 2] = \"HOOK\";\n\t    Category[Category[\"INVOKE\"] = 3] = \"INVOKE\";\n\t    Category[Category[\"UIVIEW\"] = 4] = \"UIVIEW\";\n\t    Category[Category[\"VIEWCONFIG\"] = 5] = \"VIEWCONFIG\";\n\t})(exports.Category || (exports.Category = {}));\n\tvar Category = exports.Category;\n\t/**\n\t * Prints UI-Router Transition trace information to the console.\n\t */\n\tvar Trace = (function () {\n\t    function Trace() {\n\t        /** @hidden */\n\t        this._enabled = {};\n\t        this.approximateDigests = 0;\n\t    }\n\t    /** @hidden */\n\t    Trace.prototype._set = function (enabled, categories) {\n\t        var _this = this;\n\t        if (!categories.length) {\n\t            categories = Object.keys(Category)\n\t                .filter(function (k) { return isNaN(parseInt(k, 10)); })\n\t                .map(function (key) { return Category[key]; });\n\t        }\n\t        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n\t    };\n\t    /**\n\t     * Enables a trace [[Category]]\n\t     *\n\t     * ```\n\t     * trace.enable(\"TRANSITION\");\n\t     * ```\n\t     *\n\t     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.enable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i - 0] = arguments[_i];\n\t        }\n\t        this._set(true, categories);\n\t    };\n\t    /**\n\t     * Disables a trace [[Category]]\n\t     *\n\t     * ```\n\t     * trace.disable(\"VIEWCONFIG\");\n\t     * ```\n\t     *\n\t     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.\n\t     *        Also takes strings (category name) or ordinal (category position)\n\t     */\n\t    Trace.prototype.disable = function () {\n\t        var categories = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            categories[_i - 0] = arguments[_i];\n\t        }\n\t        this._set(false, categories);\n\t    };\n\t    /**\n\t     * Retrieves the enabled stateus of a [[Category]]\n\t     *\n\t     * ```\n\t     * trace.enabled(\"VIEWCONFIG\"); // true or false\n\t     * ```\n\t     *\n\t     * @returns boolean true if the category is enabled\n\t     */\n\t    Trace.prototype.enabled = function (category) {\n\t        return !!this._enabled[normalizedCat(category)];\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceTransitionStart = function (transition) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": Started  -> \" + transitionStr);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceTransitionIgnored = function (transition) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": Ignored  <> \" + transitionStr);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceHookInvocation = function (step, options) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.functionToString(step.fn);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":   Hook -> \" + event + \" context: \" + context + \", \" + strings_1.maxLength(200, name));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceHookResult = function (hookResult, transitionResult, transitionOptions) {\n\t        if (!this.enabled(Category.HOOK))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(transitionOptions), digest = this.approximateDigests, hookResultStr = strings_1.stringify(hookResult), transitionResultStr = strings_1.stringify(transitionResult);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":   <- Hook returned: \" + strings_1.maxLength(200, hookResultStr) + \", transition result: \" + strings_1.maxLength(200, transitionResultStr));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceResolvePath = function (path, options) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, pathStr = path && path.toString(), policyStr = options && options.resolvePolicy;\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Resolving \" + pathStr + \" (\" + policyStr + \")\");\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceResolvePathElement = function (pathElement, resolvablePromises, options) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        if (!resolvablePromises.length)\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvablePromisesStr = Object.keys(resolvablePromises).join(\", \"), pathElementStr = pathElement && pathElement.toString(), policyStr = options && options.resolvePolicy;\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Resolve \" + pathElementStr + \" resolvables: [\" + resolvablePromisesStr + \"] (\" + policyStr + \")\");\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceResolveResolvable = function (resolvable, options) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString();\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":               Resolving -> \" + resolvableStr);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceResolvableResolved = function (resolvable, options) {\n\t        if (!this.enabled(Category.RESOLVE))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, resolvableStr = resolvable && resolvable.toString(), result = strings_1.stringify(resolvable.data);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":               <- Resolved  \" + resolvableStr + \" to: \" + strings_1.maxLength(200, result));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.tracePathElementInvoke = function (node, fn, deps, options) {\n\t        if (!this.enabled(Category.INVOKE))\n\t            return;\n\t        var tid = hof_1.parse(\"transition.$id\")(options), digest = this.approximateDigests, stateName = node && node.state && node.state.toString(), fnName = strings_1.functionToString(fn);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \":         Invoke \" + options.when + \": context: \" + stateName + \" \" + strings_1.maxLength(200, fnName));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceError = function (error, transition) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = transition.$id, digest = this.approximateDigests, transitionStr = strings_1.stringify(transition);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": <- Rejected \" + transitionStr + \", reason: \" + error);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceSuccess = function (finalState, transition) {\n\t        if (!this.enabled(Category.TRANSITION))\n\t            return;\n\t        var tid = transition.$id, digest = this.approximateDigests, state = finalState.name, transitionStr = strings_1.stringify(transition);\n\t        console.log(\"Transition #\" + tid + \" Digest #\" + digest + \": <- Success  \" + transitionStr + \", final state: \" + state);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceUiViewEvent = function (event, viewData, extra) {\n\t        if (extra === void 0) { extra = \"\"; }\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        console.log(\"ui-view: \" + strings_1.padString(30, event) + \" \" + uiViewString(viewData) + extra);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceUiViewConfigUpdated = function (viewData, context) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUiViewEvent(\"Updating\", viewData, \" with ViewConfig from context='\" + context + \"'\");\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceUiViewScopeCreated = function (viewData, newScope) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUiViewEvent(\"Created scope for\", viewData, \", scope #\" + newScope.$id);\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceUiViewFill = function (viewData, html) {\n\t        if (!this.enabled(Category.UIVIEW))\n\t            return;\n\t        this.traceUiViewEvent(\"Fill\", viewData, \" with: \" + strings_1.maxLength(200, html));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + viewConfigString(viewConfig));\n\t    };\n\t    /** called by ui-router code */\n\t    Trace.prototype.traceViewServiceUiViewEvent = function (event, viewData) {\n\t        if (!this.enabled(Category.VIEWCONFIG))\n\t            return;\n\t        console.log(\"VIEWCONFIG: \" + event + \" \" + uiViewString(viewData));\n\t    };\n\t    return Trace;\n\t}());\n\texports.Trace = Trace;\n\t/**\n\t * The [[Trace]] singleton\n\t *\n\t * @example\n\t * ```js\n\t *\n\t * import {trace} from \"angular-ui-router\";\n\t * trace.enable(1, 5);\n\t * ```\n\t */\n\tvar trace = new Trace();\n\texports.trace = trace;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * This module contains APIs related to a Transition.\n\t *\n\t * See [[Transition]], [[$transitions]]\n\t *\n\t * @module transition\n\t * @preferred\n\t */\n\t/** for typedoc */\n\t__export(__webpack_require__(14));\n\t__export(__webpack_require__(15));\n\t__export(__webpack_require__(10));\n\t__export(__webpack_require__(11));\n\t__export(__webpack_require__(16));\n\t__export(__webpack_require__(43));\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module transition */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(13);\n\t/**\n\t * This class returns applicable TransitionHooks for a specific Transition instance.\n\t *\n\t * Hooks (IEventHook) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n\t * myTransition.onEnter(...).  The HookBuilder finds matching IEventHooks (where the match criteria is\n\t * determined by the type of hook)\n\t *\n\t * The HookBuilder also converts IEventHooks objects to TransitionHook objects, which are used to run a Transition.\n\t *\n\t * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n\t * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n\t * in the Transition class, so we must also provide the Transition's _treeChanges)\n\t *\n\t */\n\tvar HookBuilder = (function () {\n\t    function HookBuilder($transitions, transition, baseHookOptions) {\n\t        var _this = this;\n\t        this.$transitions = $transitions;\n\t        this.transition = transition;\n\t        this.baseHookOptions = baseHookOptions;\n\t        // TODO: These get* methods are returning different cardinalities of hooks\n\t        // onBefore/onStart/onFinish/onSuccess/onError returns an array of hooks\n\t        // onExit/onRetain/onEnter returns an array of arrays of hooks\n\t        this.getOnBeforeHooks = function () { return _this._buildNodeHooks(\"onBefore\", \"to\", tupleSort(), undefined, { async: false }); };\n\t        this.getOnStartHooks = function () { return _this._buildNodeHooks(\"onStart\", \"to\", tupleSort()); };\n\t        this.getOnExitHooks = function () { return _this._buildNodeHooks(\"onExit\", \"exiting\", tupleSort(true), function (node) { return ({ $state$: node.state }); }); };\n\t        this.getOnRetainHooks = function () { return _this._buildNodeHooks(\"onRetain\", \"retained\", tupleSort(), function (node) { return ({ $state$: node.state }); }); };\n\t        this.getOnEnterHooks = function () { return _this._buildNodeHooks(\"onEnter\", \"entering\", tupleSort(), function (node) { return ({ $state$: node.state }); }); };\n\t        this.getOnFinishHooks = function () { return _this._buildNodeHooks(\"onFinish\", \"to\", tupleSort(), function (node) { return ({ $treeChanges$: _this.treeChanges }); }); };\n\t        this.getOnSuccessHooks = function () { return _this._buildNodeHooks(\"onSuccess\", \"to\", tupleSort(), undefined, { async: false, rejectIfSuperseded: false }); };\n\t        this.getOnErrorHooks = function () { return _this._buildNodeHooks(\"onError\", \"to\", tupleSort(), undefined, { async: false, rejectIfSuperseded: false }); };\n\t        this.treeChanges = transition.treeChanges();\n\t        this.toState = common_1.tail(this.treeChanges.to).state;\n\t        this.fromState = common_1.tail(this.treeChanges.from).state;\n\t        this.transitionOptions = transition.options();\n\t    }\n\t    HookBuilder.prototype.asyncHooks = function () {\n\t        var onStartHooks = this.getOnStartHooks();\n\t        var onExitHooks = this.getOnExitHooks();\n\t        var onRetainHooks = this.getOnRetainHooks();\n\t        var onEnterHooks = this.getOnEnterHooks();\n\t        var onFinishHooks = this.getOnFinishHooks();\n\t        var asyncHooks = [onStartHooks, onExitHooks, onRetainHooks, onEnterHooks, onFinishHooks];\n\t        return asyncHooks.reduce(common_1.unnestR, []).filter(common_1.identity);\n\t    };\n\t    /**\n\t     * Returns an array of newly built TransitionHook objects.\n\t     *\n\t     * - Finds all IEventHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n\t     * - Finds [[Node]] (or `Node[]`) to use as the TransitionHook context(s)\n\t     * - For each of the [[Node]]s, creates a TransitionHook\n\t     *\n\t     * @param hookType the name of the hook registration function, e.g., 'onEnter', 'onFinish'.\n\t     * @param matchingNodesProp selects which [[Node]]s from the [[IMatchingNodes]] object to create hooks for.\n\t     * @param getLocals a function which accepts a [[Node]] and returns additional locals to provide to the hook as injectables\n\t     * @param sortHooksFn a function which compares two HookTuple and returns <1, 0, or >1\n\t     * @param options any specific Transition Hook Options\n\t     */\n\t    HookBuilder.prototype._buildNodeHooks = function (hookType, matchingNodesProp, sortHooksFn, getLocals, options) {\n\t        var _this = this;\n\t        if (getLocals === void 0) { getLocals = function (node) { return ({}); }; }\n\t        // Find all the matching registered hooks for a given hook type\n\t        var matchingHooks = this._matchingHooks(hookType, this.treeChanges);\n\t        if (!matchingHooks)\n\t            return [];\n\t        var makeTransitionHooks = function (hook) {\n\t            // Fetch the Nodes that caused this hook to match.\n\t            var matches = hook.matches(_this.treeChanges);\n\t            // Select the Node[] that will be used as TransitionHook context objects\n\t            var nodes = matches[matchingNodesProp];\n\t            // Return an array of HookTuples\n\t            return nodes.map(function (node) {\n\t                var _options = common_1.extend({ bind: hook.bind, traceData: { hookType: hookType, context: node } }, _this.baseHookOptions, options);\n\t                var transitionHook = new module_1.TransitionHook(hook.callback, getLocals(node), node.resolveContext, _options);\n\t                return { hook: hook, node: node, transitionHook: transitionHook };\n\t            });\n\t        };\n\t        return matchingHooks.map(makeTransitionHooks)\n\t            .reduce(common_1.unnestR, [])\n\t            .sort(sortHooksFn)\n\t            .map(function (tuple) { return tuple.transitionHook; });\n\t    };\n\t    /**\n\t     * Finds all IEventHooks from:\n\t     * - The Transition object instance hook registry\n\t     * - The TransitionService ($transitions) global hook registry\n\t     *\n\t     * which matched:\n\t     * - the eventType\n\t     * - the matchCriteria (to, from, exiting, retained, entering)\n\t     *\n\t     * @returns an array of matched [[IEventHook]]s\n\t     */\n\t    HookBuilder.prototype._matchingHooks = function (hookName, treeChanges) {\n\t        return [this.transition, this.$transitions] // Instance and Global hook registries\n\t            .map(function (reg) { return reg.getHooks(hookName); }) // Get named hooks from registries\n\t            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookName)) // Sanity check\n\t            .reduce(common_1.unnestR, []) // Un-nest IEventHook[][] to IEventHook[] array\n\t            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n\t    };\n\t    return HookBuilder;\n\t}());\n\texports.HookBuilder = HookBuilder;\n\t/**\n\t * A factory for a sort function for HookTuples.\n\t *\n\t * The sort function first compares the Node depth (how deep in the state tree a node is), then compares\n\t * the EventHook priority.\n\t *\n\t * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n\t * @returns a tuple sort function\n\t */\n\tfunction tupleSort(reverseDepthSort) {\n\t    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n\t    return function nodeDepthThenPriority(l, r) {\n\t        var factor = reverseDepthSort ? -1 : 1;\n\t        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n\t        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n\t    };\n\t}\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module transition */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar glob_1 = __webpack_require__(7);\n\t/**\n\t * Determines if the given state matches the matchCriteria\n\t * @param state a State Object to test against\n\t * @param criterion\n\t * - If a string, matchState uses the string as a glob-matcher against the state name\n\t * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n\t *   and returns a positive match if any of the globs match.\n\t * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n\t * @returns {boolean}\n\t */\n\tfunction matchState(state, criterion) {\n\t    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n\t    function matchGlobs(_state) {\n\t        var globStrings = toMatch;\n\t        for (var i = 0; i < globStrings.length; i++) {\n\t            var glob = glob_1.Glob.fromString(globStrings[i]);\n\t            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n\t    return !!matchFn(state);\n\t}\n\texports.matchState = matchState;\n\tvar EventHook = (function () {\n\t    function EventHook(matchCriteria, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        this.callback = callback;\n\t        this.matchCriteria = common_1.extend({ to: true, from: true, exiting: true, retained: true, entering: true }, matchCriteria);\n\t        this.priority = options.priority || 0;\n\t        this.bind = options.bind || null;\n\t    }\n\t    EventHook._matchingNodes = function (nodes, criterion) {\n\t        if (criterion === true)\n\t            return nodes;\n\t        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n\t        return matching.length ? matching : null;\n\t    };\n\t    /**\n\t     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n\t     *\n\t     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n\t     * are the matching [[Node]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n\t     */\n\t    EventHook.prototype.matches = function (treeChanges) {\n\t        var mc = this.matchCriteria, _matchingNodes = EventHook._matchingNodes;\n\t        var matches = {\n\t            to: _matchingNodes([common_1.tail(treeChanges.to)], mc.to),\n\t            from: _matchingNodes([common_1.tail(treeChanges.from)], mc.from),\n\t            exiting: _matchingNodes(treeChanges.exiting, mc.exiting),\n\t            retained: _matchingNodes(treeChanges.retained, mc.retained),\n\t            entering: _matchingNodes(treeChanges.entering, mc.entering),\n\t        };\n\t        // Check if all the criteria matched the TreeChanges object\n\t        var allMatched = [\"to\", \"from\", \"exiting\", \"retained\", \"entering\"]\n\t            .map(function (prop) { return matches[prop]; })\n\t            .reduce(common_1.allTrueR, true);\n\t        return allMatched ? matches : null;\n\t    };\n\t    return EventHook;\n\t}());\n\texports.EventHook = EventHook;\n\t// Return a registration function of the requested type.\n\tfunction makeHookRegistrationFn(hooks, name) {\n\t    return function (matchObject, callback, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var eventHook = new EventHook(matchObject, callback, options);\n\t        hooks[name].push(eventHook);\n\t        return function deregisterEventHook() {\n\t            common_1.removeFrom(hooks[name])(eventHook);\n\t        };\n\t    };\n\t}\n\tvar HookRegistry = (function () {\n\t    function HookRegistry() {\n\t        var _this = this;\n\t        this._transitionEvents = {\n\t            onBefore: [], onStart: [], onEnter: [], onRetain: [], onExit: [], onFinish: [], onSuccess: [], onError: []\n\t        };\n\t        this.getHooks = function (name) { return _this._transitionEvents[name]; };\n\t        this.onBefore = makeHookRegistrationFn(this._transitionEvents, \"onBefore\");\n\t        this.onStart = makeHookRegistrationFn(this._transitionEvents, \"onStart\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onEnter\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from' states,\n\t         * when the matched 'to' state is being entered. This function is injected with the entering state's resolves.\n\t         *\n\t         * This function can be injected with two additional special value:\n\t         * - **`$transition$`**: The current transition\n\t         * - **`$state$`**: The state being entered\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         */\n\t        this.onEnter = makeHookRegistrationFn(this._transitionEvents, \"onEnter\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onRetain\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,\n\t         * when the matched 'from' state is already active and is not being exited nor entered.\n\t         *\n\t         * This function can be injected with two additional special value:\n\t         * - **`$transition$`**: The current transition\n\t         * - **`$state$`**: The state that is retained\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         */\n\t        this.onRetain = makeHookRegistrationFn(this._transitionEvents, \"onRetain\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onExit\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,\n\t         * when the matched 'from' state is being exited. This function is in injected with the exiting state's resolves.\n\t         *\n\t         * This function can be injected with two additional special value:\n\t         * - **`$transition$`**: The current transition\n\t         * - **`$state$`**: The state being entered\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         */\n\t        this.onExit = makeHookRegistrationFn(this._transitionEvents, \"onExit\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onFinish\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked when a transition is finished entering/exiting all states.\n\t         *\n\t         * This function can be injected with:\n\t         * - **`$transition$`**: The current transition\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         */\n\t        this.onFinish = makeHookRegistrationFn(this._transitionEvents, \"onFinish\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onSuccess\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked when a transition has successfully completed between the matched\n\t         * 'to' and 'from' state is being exited.\n\t         * This function is in injected with the 'to' state's resolves (note: `JIT` resolves are not injected).\n\t         *\n\t         * This function can be injected with two additional special value:\n\t         * - **`$transition$`**: The current transition\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.\n\t         *   The function's return value is ignored.\n\t         */\n\t        this.onSuccess = makeHookRegistrationFn(this._transitionEvents, \"onSuccess\");\n\t        /**\n\t         * @ngdoc function\n\t         * @name ui.router.state.$transitionsProvider#onError\n\t         * @methodOf ui.router.state.$transitionsProvider\n\t         *\n\t         * @description\n\t         * Registers a function to be injected and invoked when a transition has failed for any reason between the matched\n\t         * 'to' and 'from' state. The transition rejection reason is injected as `$error$`.\n\t         *\n\t         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.\n\t         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.\n\t         *   The function's return value is ignored.\n\t         */\n\t        this.onError = makeHookRegistrationFn(this._transitionEvents, \"onError\");\n\t    }\n\t    HookRegistry.mixin = function (source, target) {\n\t        Object.keys(source._transitionEvents).concat([\"getHooks\"]).forEach(function (key) { return target[key] = source[key]; });\n\t    };\n\t    return HookRegistry;\n\t}());\n\texports.HookRegistry = HookRegistry;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar strings_1 = __webpack_require__(9);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\tvar trace_1 = __webpack_require__(12);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar module_1 = __webpack_require__(17);\n\tvar defaultOptions = {\n\t    async: true,\n\t    rejectIfSuperseded: true,\n\t    current: common_1.noop,\n\t    transition: null,\n\t    traceData: {},\n\t    bind: null\n\t};\n\tvar TransitionHook = (function () {\n\t    function TransitionHook(fn, locals, resolveContext, options) {\n\t        var _this = this;\n\t        this.fn = fn;\n\t        this.locals = locals;\n\t        this.resolveContext = resolveContext;\n\t        this.options = options;\n\t        this.isSuperseded = function () { return _this.options.current() !== _this.options.transition; };\n\t        this.options = common_1.defaults(options, defaultOptions);\n\t    }\n\t    TransitionHook.prototype.invokeHook = function (moreLocals) {\n\t        var _this = this;\n\t        var _a = this, options = _a.options, fn = _a.fn, resolveContext = _a.resolveContext;\n\t        var locals = common_1.extend({}, this.locals, moreLocals);\n\t        trace_1.trace.traceHookInvocation(this, options);\n\t        if (options.rejectIfSuperseded && this.isSuperseded()) {\n\t            return rejectFactory_1.Rejection.superseded(options.current()).toPromise();\n\t        }\n\t        // TODO: Need better integration of returned promises in synchronous code.\n\t        if (!options.async) {\n\t            var hookResult = resolveContext.invokeNow(fn, locals, options);\n\t            return this.handleHookResult(hookResult);\n\t        }\n\t        return resolveContext.invokeLater(fn, locals, options).then(function (val) { return _this.handleHookResult(val); });\n\t    };\n\t    ;\n\t    /**\n\t     * This method handles the return value of a Transition Hook.\n\t     *\n\t     * A hook can return false, a redirect (TargetState), or a promise (which may resolve to false or a redirect)\n\t     */\n\t    TransitionHook.prototype.handleHookResult = function (hookResult) {\n\t        var _this = this;\n\t        if (!predicates_1.isDefined(hookResult))\n\t            return undefined;\n\t        /**\n\t         * Handles transition superseded, transition aborted and transition redirect.\n\t         */\n\t        var mapHookResult = hof_1.pattern([\n\t            // Transition is no longer current\n\t            [this.isSuperseded, function () { return rejectFactory_1.Rejection.superseded(_this.options.current()).toPromise(); }],\n\t            // If the hook returns false, abort the current Transition\n\t            [hof_1.eq(false), function () { return rejectFactory_1.Rejection.aborted(\"Hook aborted transition\").toPromise(); }],\n\t            // If the hook returns a Transition, halt the current Transition and redirect to that Transition.\n\t            [hof_1.is(module_1.TargetState), function (target) { return rejectFactory_1.Rejection.redirected(target).toPromise(); }],\n\t            // A promise was returned, wait for the promise and then chain another hookHandler\n\t            [predicates_1.isPromise, function (promise) { return promise.then(_this.handleHookResult.bind(_this)); }]\n\t        ]);\n\t        var transitionResult = mapHookResult(hookResult);\n\t        if (transitionResult)\n\t            trace_1.trace.traceHookResult(hookResult, transitionResult, this.options);\n\t        return transitionResult;\n\t    };\n\t    TransitionHook.prototype.toString = function () {\n\t        var _a = this, options = _a.options, fn = _a.fn;\n\t        var event = hof_1.parse(\"traceData.hookType\")(options) || \"internal\", context = hof_1.parse(\"traceData.context.state.name\")(options) || hof_1.parse(\"traceData.context\")(options) || \"unknown\", name = strings_1.fnToString(fn);\n\t        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n\t    };\n\t    /**\n\t     * Given an array of TransitionHooks, runs each one synchronously and sequentially.\n\t     *\n\t     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call\n\t     */\n\t    TransitionHook.runSynchronousHooks = function (hooks, locals, swallowExceptions) {\n\t        if (locals === void 0) { locals = {}; }\n\t        if (swallowExceptions === void 0) { swallowExceptions = false; }\n\t        var results = [];\n\t        for (var i = 0; i < hooks.length; i++) {\n\t            try {\n\t                results.push(hooks[i].invokeHook(locals));\n\t            }\n\t            catch (exception) {\n\t                if (!swallowExceptions) {\n\t                    return rejectFactory_1.Rejection.aborted(exception).toPromise();\n\t                }\n\t                console.error(\"Swallowed exception during synchronous hook handler: \" + exception); // TODO: What to do here?\n\t            }\n\t        }\n\t        var rejections = results.filter(rejectFactory_1.Rejection.isTransitionRejectionPromise);\n\t        if (rejections.length)\n\t            return rejections[0];\n\t        return results\n\t            .filter(predicates_1.isPromise)\n\t            .reduce(function (chain, promise) { return chain.then(hof_1.val(promise)); }, coreservices_1.services.$q.when());\n\t    };\n\t    return TransitionHook;\n\t}());\n\texports.TransitionHook = TransitionHook;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module state */ /** for typedoc */\n\t__export(__webpack_require__(18));\n\t__export(__webpack_require__(19));\n\t__export(__webpack_require__(26));\n\t__export(__webpack_require__(33));\n\t__export(__webpack_require__(34));\n\t__export(__webpack_require__(35));\n\t__export(__webpack_require__(36));\n\t__export(__webpack_require__(37));\n\t__export(__webpack_require__(27));\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(4);\n\tvar common_1 = __webpack_require__(3);\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\tvar StateProvider = (function () {\n\t    function StateProvider(stateRegistry) {\n\t        this.stateRegistry = stateRegistry;\n\t        this.invalidCallbacks = [];\n\t        common_1.bindFunctions(StateProvider.prototype, this, this);\n\t    }\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$stateProvider#decorator\n\t     * @methodOf ui.router.state.$stateProvider\n\t     *\n\t     * @description\n\t     * Allows you to extend (carefully) or override (at your own peril) the\n\t     * `stateBuilder` object used internally by `$stateProvider`. This can be used\n\t     * to add custom functionality to ui-router, for example inferring templateUrl\n\t     * based on the state name.\n\t     *\n\t     * When passing only a name, it returns the current (original or decorated) builder\n\t     * function that matches `name`.\n\t     *\n\t     * The builder functions that can be decorated are listed below. Though not all\n\t     * necessarily have a good use case for decoration, that is up to you to decide.\n\t     *\n\t     * In addition, users can attach custom decorators, which will generate new\n\t     * properties within the state's internal definition. There is currently no clear\n\t     * use-case for this beyond accessing internal states (i.e. $state.$current),\n\t     * however, expect this to become increasingly relevant as we introduce additional\n\t     * meta-programming features.\n\t     *\n\t     * **Warning**: Decorators should not be interdependent because the order of\n\t     * execution of the builder functions in non-deterministic. Builder functions\n\t     * should only be dependent on the state definition object and super function.\n\t     *\n\t     *\n\t     * Existing builder functions and current return values:\n\t     *\n\t     * - **parent** `{object}` - returns the parent state object.\n\t     * - **data** `{object}` - returns state data, including any inherited data that is not\n\t     *   overridden by own values (if any).\n\t     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t     *   or `null`.\n\t     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n\t     *   navigable).\n\t     * - **params** `{object}` - returns an array of state params that are ensured to\n\t     *   be a super-set of parent's params.\n\t     * - **views** `{object}` - returns a views object where each key is an absolute view\n\t     *   name (i.e. \"viewName@stateName\") and each value is the config object\n\t     *   (template, controller) for the view. Even when you don't use the views object\n\t     *   explicitly on a state config, one is still created for you internally.\n\t     *   So by decorating this builder function you have access to decorating template\n\t     *   and controller properties.\n\t     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n\t     *   not including any params defined by ancestor states.\n\t     * - **path** `{string}` - returns the full path from the root down to this state.\n\t     *   Needed for state activation.\n\t     * - **includes** `{object}` - returns an object that includes every state that\n\t     *   would pass a `$state.includes()` test.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * // Override the internal 'views' builder with a function that takes the state\n\t     * // definition, and a reference to the internal function being overridden:\n\t     * $stateProvider.decorator('views', function (state, parent) {\n\t     *   let result = {},\n\t     *       views = parent(state);\n\t     *\n\t     *   angular.forEach(views, function (config, name) {\n\t     *     let autoName = (state.name + '.' + name).replace('.', '/');\n\t     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t     *     result[name] = config;\n\t     *   });\n\t     *   return result;\n\t     * });\n\t     *\n\t     * $stateProvider.state('home', {\n\t     *   views: {\n\t     *     'contact.list': { controller: 'ListController' },\n\t     *     'contact.item': { controller: 'ItemController' }\n\t     *   }\n\t     * });\n\t     *\n\t     * // ...\n\t     *\n\t     * $state.go('home');\n\t     * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t     * // and /partials/home/contact/item.html, respectively.\n\t     * </pre>\n\t     *\n\t     * @param {string} name The name of the builder function to decorate.\n\t     * @param {object} func A function that is responsible for decorating the original\n\t     * builder function. The function receives two parameters:\n\t     *\n\t     *   - `{object}` - state - The state config object.\n\t     *   - `{object}` - super - The original builder function.\n\t     *\n\t     * @return {object} $stateProvider - $stateProvider instance\n\t     */\n\t    StateProvider.prototype.decorator = function (name, func) {\n\t        return this.stateRegistry.decorator(name, func) || this;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$stateProvider#state\n\t     * @methodOf ui.router.state.$stateProvider\n\t     *\n\t     * @description\n\t     * Registers a state configuration under a given state name. The stateConfig object\n\t     * has the following acceptable properties.\n\t     *\n\t     * <a id='template'></a>\n\t     *\n\t     * - **`template`** - {string|function=} - html template as a string or a function that returns\n\t     *   an html template as a string which should be used by the uiView directives. This property\n\t     *   takes precedence over templateUrl.\n\t     *\n\t     *   If `template` is a function, it will be called with the following parameters:\n\t     *\n\t     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t     *     applying the current state\n\t     *\n\t     * <a id='templateUrl'></a>\n\t     *\n\t     * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html\n\t     *   template that should be used by uiView.\n\t     *\n\t     *   If `templateUrl` is a function, it will be called with the following parameters:\n\t     *\n\t     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t     *     applying the current state\n\t     *\n\t     * <a id='templateProvider'></a>\n\t     *\n\t     * - **`templateProvider`** - {function=} - Provider function that returns HTML content\n\t     *   string.\n\t     *\n\t     * <a id='controller'></a>\n\t     *\n\t     * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly\n\t     *   related scope or the name of a registered controller if passed as a string.\n\t     *\n\t     * <a id='controllerProvider'></a>\n\t     *\n\t     * - **`controllerProvider`** - {function=} - Injectable provider function that returns\n\t     *   the actual controller or string.\n\t     *\n\t     * <a id='controllerAs'></a>\n\t     *\n\t     * - **`controllerAs`**  {string=}  A controller alias name. If present the controller will be\n\t     *   published to scope under the controllerAs name.\n\t     *\n\t     * <a id='resolve'></a>\n\t     *\n\t     * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which\n\t     *   should be injected into the controller. If any of these dependencies are promises,\n\t     *   the router will wait for them all to be resolved or one to be rejected before the\n\t     *   controller is instantiated. If all the promises are resolved successfully, the values\n\t     *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any\n\t     *   of the promises are rejected the $stateChangeError event is fired. The map object is:\n\t     *\n\t     *   - key - {string}: name of dependency to be injected into controller\n\t     *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,\n\t     *     it is injected and return value it treated as dependency. If result is a promise, it is\n\t     *     resolved before its value is injected into controller.\n\t     *\n\t     * <a id='url'></a>\n\t     *\n\t     * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\n\t     *   transitioned to, the `$stateParams` service will be populated with any\n\t     *   parameters that were passed.\n\t     *\n\t     * <a id='params'></a>\n\t     *\n\t     * - **`params`** - {object=} - An array of parameter names or regular expressions. Only\n\t     *   use this within a state if you are not using url. Otherwise you can specify your\n\t     *   parameters within the url. When a state is navigated or transitioned to, the\n\t     *   $stateParams service will be populated with any parameters that were passed.\n\t     *\n\t     * <a id='views'></a>\n\t     *\n\t     * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\n\t     *   manually/explicitly.\n\t     *\n\t     * <a id='abstract'></a>\n\t     *\n\t     * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,\n\t     *   but can provide inherited properties to its common children states.\n\t     *\n\t     * <a id='onEnter'></a>\n\t     *\n\t     * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\n\t     *   to trigger an action or dispatch an event, such as opening a dialog.\n\t     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t     *\n\t     * <a id='onExit'></a>\n\t     *\n\t     * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\n\t     *   trigger an action or dispatch an event, such as opening a dialog.\n\t     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\n\t     *\n\t     * <a id='reloadOnSearch'></a>\n\t     *\n\t     * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state\n\t     *   just because a search/query parameter has changed (via $location.search() or $location.hash()).\n\t     *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t     *\n\t     * <a id='data'></a>\n\t     *\n\t     * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * // Some state name examples\n\t     *\n\t     * // stateName can be a single top-level name (must be unique).\n\t     * $stateProvider.state(\"home\", {});\n\t     *\n\t     * // Or it can be a nested state name. This state is a child of the\n\t     * // above \"home\" state.\n\t     * $stateProvider.state(\"home.newest\", {});\n\t     *\n\t     * // Nest states as deeply as needed.\n\t     * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t     *\n\t     * // state() returns $stateProvider, so you can chain state declarations.\n\t     * $stateProvider\n\t     *   .state(\"home\", {})\n\t     *   .state(\"about\", {})\n\t     *   .state(\"contacts\", {});\n\t     * </pre>\n\t     *\n\t     * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t     * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t     * @param {object} definition State configuration object.\n\t     */\n\t    StateProvider.prototype.state = function (name, definition) {\n\t        if (predicates_1.isObject(name)) {\n\t            definition = name;\n\t        }\n\t        else {\n\t            definition.name = name;\n\t        }\n\t        this.stateRegistry.register(definition);\n\t        return this;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$stateProvider#onInvalid\n\t     * @methodOf ui.router.state.$stateProvider\n\t     *\n\t     * @description\n\t     * Registers a function to be injected and invoked when transitionTo has been called with an invalid\n\t     * state reference parameter\n\t     *\n\t     * This function can be injected with one some special values:\n\t     * - **`$to$`**: TargetState\n\t     * - **`$from$`**: TargetState\n\t     *\n\t     * @param {function} callback\n\t     *   The function which will be injected and invoked, when a matching transition is started.\n\t     *   The function may optionally return a {TargetState} or a Promise for a TargetState.  If one\n\t     *   is returned, it is treated as a redirect.\n\t     */\n\t    StateProvider.prototype.onInvalid = function (callback) {\n\t        this.invalidCallbacks.push(callback);\n\t    };\n\t    return StateProvider;\n\t}());\n\texports.StateProvider = StateProvider;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\tvar module_1 = __webpack_require__(20);\n\tvar parseUrl = function (url) {\n\t    if (!predicates_1.isString(url))\n\t        return false;\n\t    var root = url.charAt(0) === '^';\n\t    return { val: root ? url.substring(1) : url, root: root };\n\t};\n\t/**\n\t * @internalapi A internal global service\n\t *\n\t * StateBuilder is a factory for the internal [[State]] objects.\n\t *\n\t * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n\t * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n\t * [[State]] object, which has an API and is used internally.\n\t *\n\t * Custom properties or API may be added to the internal [[State]] object by registering a decorator function\n\t * using the [[builder]] method.\n\t */\n\tvar StateBuilder = (function () {\n\t    function StateBuilder(matcher, $urlMatcherFactoryProvider) {\n\t        this.matcher = matcher;\n\t        var self = this;\n\t        var isRoot = function (state) { return state.name === \"\"; };\n\t        var root = function () { return matcher.find(\"\"); };\n\t        this.builders = {\n\t            self: [function (state) {\n\t                    state.self.$$state = function () { return state; };\n\t                    return state.self;\n\t                }],\n\t            parent: [function (state) {\n\t                    if (isRoot(state))\n\t                        return null;\n\t                    return matcher.find(self.parentName(state)) || root();\n\t                }],\n\t            data: [function (state) {\n\t                    if (state.parent && state.parent.data) {\n\t                        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n\t                    }\n\t                    return state.data;\n\t                }],\n\t            // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t            url: [function (state) {\n\t                    var stateDec = state;\n\t                    var parsed = parseUrl(stateDec.url), parent = state.parent;\n\t                    var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n\t                        params: state.params || {},\n\t                        paramMap: function (paramConfig, isSearch) {\n\t                            if (stateDec.reloadOnSearch === false && isSearch)\n\t                                paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n\t                            return paramConfig;\n\t                        }\n\t                    });\n\t                    if (!url)\n\t                        return null;\n\t                    if (!$urlMatcherFactoryProvider.isMatcher(url))\n\t                        throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t                    return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n\t                }],\n\t            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t            navigable: [function (state) {\n\t                    return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n\t                }],\n\t            params: [function (state) {\n\t                    var makeConfigParam = function (config, id) { return module_1.Param.fromConfig(id, null, config); };\n\t                    var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n\t                    var nonUrlParams = common_1.values(common_1.map(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n\t                    return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n\t                }],\n\t            // Each framework-specific ui-router implementation should define its own `views` builder\n\t            // e.g., src/ng1/viewsBuilder.ts\n\t            views: [],\n\t            // Keep a full path from the root down to this state as this is needed for state activation.\n\t            path: [function (state) {\n\t                    return state.parent ? state.parent.path.concat(state) : [state];\n\t                }],\n\t            // Speed up $state.includes() as it's used a lot\n\t            includes: [function (state) {\n\t                    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n\t                    includes[state.name] = true;\n\t                    return includes;\n\t                }]\n\t        };\n\t    }\n\t    /**\n\t     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).\n\t     * More than one BuilderFunction can be registered for a given property.\n\t     *\n\t     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.\n\t     *\n\t     * @param name The name of the State property being registered for.\n\t     * @param fn The BuilderFunction which will be used to build the State property\n\t     * @returns a function which deregisters the BuilderFunction\n\t     */\n\t    StateBuilder.prototype.builder = function (name, fn) {\n\t        var builders = this.builders;\n\t        var array = builders[name] || [];\n\t        // Backwards compat: if only one builder exists, return it, else return whole arary.\n\t        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n\t            return array.length > 1 ? array : array[0];\n\t        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n\t            return;\n\t        builders[name] = array;\n\t        builders[name].push(fn);\n\t        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n\t    };\n\t    /**\n\t     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n\t     * properties and API built.\n\t     *\n\t     * @param state an uninitialized State object\n\t     * @returns the built State object\n\t     */\n\t    StateBuilder.prototype.build = function (state) {\n\t        var _a = this, matcher = _a.matcher, builders = _a.builders;\n\t        var parent = this.parentName(state);\n\t        if (parent && !matcher.find(parent))\n\t            return null;\n\t        for (var key in builders) {\n\t            if (!builders.hasOwnProperty(key))\n\t                continue;\n\t            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n\t            state[key] = chain(state);\n\t        }\n\t        return state;\n\t    };\n\t    StateBuilder.prototype.parentName = function (state) {\n\t        var name = state.name || \"\";\n\t        if (name.indexOf('.') !== -1)\n\t            return name.substring(0, name.lastIndexOf('.'));\n\t        if (!state.parent)\n\t            return \"\";\n\t        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t    };\n\t    StateBuilder.prototype.name = function (state) {\n\t        var name = state.name;\n\t        if (name.indexOf('.') !== -1 || !state.parent)\n\t            return name;\n\t        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n\t        return parentName ? parentName + \".\" + name : name;\n\t    };\n\t    return StateBuilder;\n\t}());\n\texports.StateBuilder = StateBuilder;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/**\n\t * This module contains code for State Parameters.\n\t *\n\t * See [[ParamDeclaration]]\n\t * @module params\n\t * @preferred doc\n\t */\n\t/** for typedoc */\n\t__export(__webpack_require__(21));\n\t__export(__webpack_require__(24));\n\t__export(__webpack_require__(25));\n\t__export(__webpack_require__(23));\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar urlMatcherConfig_1 = __webpack_require__(22);\n\tvar type_1 = __webpack_require__(23);\n\tvar paramTypes_1 = __webpack_require__(24);\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar isShorthand = function (cfg) { return [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(hasOwn.bind(cfg || {})).length === 0; };\n\t(function (DefType) {\n\t    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n\t    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n\t    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n\t})(exports.DefType || (exports.DefType = {}));\n\tvar DefType = exports.DefType;\n\tfunction unwrapShorthand(cfg) {\n\t    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n\t    return common_1.extend(cfg, {\n\t        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : function () { return cfg.value; }\n\t    });\n\t}\n\tfunction getType(cfg, urlType, location, id) {\n\t    if (cfg.type && urlType && urlType.name !== 'string')\n\t        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n\t    if (cfg.type && urlType && urlType.name === 'string' && paramTypes_1.paramTypes.type(cfg.type))\n\t        return paramTypes_1.paramTypes.type(cfg.type);\n\t    if (urlType)\n\t        return urlType;\n\t    if (!cfg.type)\n\t        return (location === DefType.CONFIG ? paramTypes_1.paramTypes.type(\"any\") : paramTypes_1.paramTypes.type(\"string\"));\n\t    return cfg.type instanceof type_1.Type ? cfg.type : paramTypes_1.paramTypes.type(cfg.type);\n\t}\n\t/**\n\t * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t */\n\tfunction getSquashPolicy(config, isOptional) {\n\t    var squash = config.squash;\n\t    if (!isOptional || squash === false)\n\t        return false;\n\t    if (!predicates_1.isDefined(squash) || squash == null)\n\t        return urlMatcherConfig_1.matcherConfig.defaultSquashPolicy();\n\t    if (squash === true || predicates_1.isString(squash))\n\t        return squash;\n\t    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t}\n\tfunction getReplace(config, arrayMode, isOptional, squash) {\n\t    var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t    ];\n\t    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n\t    if (predicates_1.isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t    configuredKeys = common_1.map(replace, hof_1.prop(\"from\"));\n\t    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n\t}\n\tvar Param = (function () {\n\t    function Param(id, type, config, location) {\n\t        config = unwrapShorthand(config);\n\t        type = getType(config, type, location, id);\n\t        var arrayMode = getArrayMode();\n\t        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n\t        var isOptional = config.value !== undefined;\n\t        var dynamic = config.dynamic === true;\n\t        var squash = getSquashPolicy(config, isOptional);\n\t        var replace = getReplace(config, arrayMode, isOptional, squash);\n\t        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t        function getArrayMode() {\n\t            var arrayDefaults = { array: (location === DefType.SEARCH ? \"auto\" : false) };\n\t            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t        }\n\t        common_1.extend(this, { id: id, type: type, location: location, squash: squash, replace: replace, isOptional: isOptional, dynamic: dynamic, config: config, array: arrayMode });\n\t    }\n\t    Param.prototype.isDefaultValue = function (value) {\n\t        return this.isOptional && this.type.equals(this.value(), value);\n\t    };\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    Param.prototype.value = function (value) {\n\t        var _this = this;\n\t        /**\n\t         * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t         */\n\t        var $$getDefaultValue = function () {\n\t            if (!coreservices_1.services.$injector)\n\t                throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n\t            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n\t                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of Type (\" + _this.type.name + \")\");\n\t            return defaultValue;\n\t        };\n\t        var $replace = function (val) {\n\t            var replacement = common_1.map(common_1.filter(_this.replace, hof_1.propEq('from', val)), hof_1.prop(\"to\"));\n\t            return replacement.length ? replacement[0] : val;\n\t        };\n\t        value = $replace(value);\n\t        return !predicates_1.isDefined(value) ? $$getDefaultValue() : this.type.$normalize(value);\n\t    };\n\t    Param.prototype.isSearch = function () {\n\t        return this.location === DefType.SEARCH;\n\t    };\n\t    Param.prototype.validates = function (value) {\n\t        // There was no parameter value, but the param is optional\n\t        if ((!predicates_1.isDefined(value) || value === null) && this.isOptional)\n\t            return true;\n\t        // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        var normalized = this.type.$normalize(value);\n\t        if (!this.type.is(normalized))\n\t            return false;\n\t        // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t        var encoded = this.type.encode(normalized);\n\t        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n\t    };\n\t    Param.prototype.toString = function () {\n\t        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n\t    };\n\t    /** Creates a new [[Param]] from a CONFIG block */\n\t    Param.fromConfig = function (id, type, config) {\n\t        return new Param(id, type, config, DefType.CONFIG);\n\t    };\n\t    /** Creates a new [[Param]] from a url PATH */\n\t    Param.fromPath = function (id, type, config) {\n\t        return new Param(id, type, config, DefType.PATH);\n\t    };\n\t    /** Creates a new [[Param]] from a url SEARCH */\n\t    Param.fromSearch = function (id, type, config) {\n\t        return new Param(id, type, config, DefType.SEARCH);\n\t    };\n\t    Param.values = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return [param.id, param.value(values[param.id])]; }).reduce(common_1.applyPairs, {});\n\t    };\n\t    /**\n\t     * Finds [[Param]] objects which have different param values\n\t     *\n\t     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n\t     *\n\t     * @param params: The list of Param objects to filter\n\t     * @param values1: The first set of parameter values\n\t     * @param values2: the second set of parameter values\n\t     *\n\t     * @returns any Param objects whose values were different between values1 and values2\n\t     */\n\t    Param.changed = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n\t    };\n\t    /**\n\t     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n\t     *\n\t     * @param params The list of [[Param]] objects to check\n\t     * @param values1 The first set of param values\n\t     * @param values2 The second set of param values\n\t     *\n\t     * @returns true if the param values in values1 and values2 are equal\n\t     */\n\t    Param.equals = function (params, values1, values2) {\n\t        if (values1 === void 0) { values1 = {}; }\n\t        if (values2 === void 0) { values2 = {}; }\n\t        return Param.changed(params, values1, values2).length === 0;\n\t    };\n\t    /** Returns true if a the parameter values are valid, according to the Param definitions */\n\t    Param.validates = function (params, values) {\n\t        if (values === void 0) { values = {}; }\n\t        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n\t    };\n\t    return Param;\n\t}());\n\texports.Param = Param;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module url */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(4);\n\tvar MatcherConfig = (function () {\n\t    function MatcherConfig() {\n\t        this._isCaseInsensitive = false;\n\t        this._isStrictMode = true;\n\t        this._defaultSquashPolicy = false;\n\t    }\n\t    MatcherConfig.prototype.caseInsensitive = function (value) {\n\t        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n\t    };\n\t    MatcherConfig.prototype.strictMode = function (value) {\n\t        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n\t    };\n\t    MatcherConfig.prototype.defaultSquashPolicy = function (value) {\n\t        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n\t            throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n\t    };\n\t    return MatcherConfig;\n\t}());\n\texports.MatcherConfig = MatcherConfig;\n\t// TODO: Do not export global instance; create one in UIRouter() constructor\n\texports.matcherConfig = new MatcherConfig();\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\t/**\n\t * Wraps up a `Type` object to handle array values.\n\t */\n\tfunction ArrayType(type, mode) {\n\t    var _this = this;\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t        switch (val.length) {\n\t            case 0: return undefined;\n\t            case 1: return mode === \"auto\" ? val[0] : val;\n\t            default: return val;\n\t        }\n\t    }\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t        return function handleArray(val) {\n\t            if (predicates_1.isArray(val) && val.length === 0)\n\t                return val;\n\t            var arr = arrayWrap(val);\n\t            var result = common_1.map(arr, callback);\n\t            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n\t        };\n\t    }\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t        return function handleArray(val1, val2) {\n\t            var left = arrayWrap(val1), right = arrayWrap(val2);\n\t            if (left.length !== right.length)\n\t                return false;\n\t            for (var i = 0; i < left.length; i++) {\n\t                if (!callback(left[i], right[i]))\n\t                    return false;\n\t            }\n\t            return true;\n\t        };\n\t    }\n\t    ['encode', 'decode', 'equals', '$normalize'].map(function (name) {\n\t        _this[name] = (name === 'equals' ? arrayEqualsHandler : arrayHandler)(type[name].bind(type));\n\t    });\n\t    common_1.extend(this, {\n\t        name: type.name,\n\t        pattern: type.pattern,\n\t        is: arrayHandler(type.is.bind(type), true),\n\t        $arrayMode: mode\n\t    });\n\t}\n\t/**\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by [[UrlMatcher]]\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See [[UrlMatcherFactory.type]] for more information on registering custom types.\n\t *\n\t * @example\n\t * ```\n\t *\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * ```\n\t */\n\tvar Type = (function () {\n\t    /**\n\t     * @param def  A configuration object which contains the custom type definition.  The object's\n\t     *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t     * @returns a new Type object\n\t     */\n\t    function Type(def) {\n\t        this.pattern = /.*/;\n\t        common_1.extend(this, def);\n\t    }\n\t    // consider these four methods to be \"abstract methods\" that should be overridden\n\t    /** @inheritdoc */\n\t    Type.prototype.is = function (val, key) { return true; };\n\t    /** @inheritdoc */\n\t    Type.prototype.encode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    Type.prototype.decode = function (val, key) { return val; };\n\t    /** @inheritdoc */\n\t    Type.prototype.equals = function (a, b) { return a == b; };\n\t    Type.prototype.$subPattern = function () {\n\t        var sub = this.pattern.toString();\n\t        return sub.substr(1, sub.length - 2);\n\t    };\n\t    Type.prototype.toString = function () {\n\t        return \"{Type:\" + this.name + \"}\";\n\t    };\n\t    /** Given an encoded string, or a decoded object, returns a decoded object */\n\t    Type.prototype.$normalize = function (val) {\n\t        return this.is(val) ? val : this.decode(val);\n\t    };\n\t    /**\n\t     * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t     * e.g.:\n\t     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t     * - url: \"/path?queryParam=1&queryParam=2\n\t     * - $stateParams.queryParam will be [1, 2]\n\t     * if `mode` is \"auto\", then\n\t     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t     */\n\t    Type.prototype.$asArray = function (mode, isSearch) {\n\t        if (!mode)\n\t            return this;\n\t        if (mode === \"auto\" && !isSearch)\n\t            throw new Error(\"'auto' array mode is for query parameters only\");\n\t        return new ArrayType(this, mode);\n\t    };\n\t    return Type;\n\t}());\n\texports.Type = Type;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar type_1 = __webpack_require__(23);\n\t// Use tildes to pre-encode slashes.\n\t// If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t// and bidirectional encoding/decoding fails.\n\t// Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\tfunction valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\tfunction valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\tvar ParamTypes = (function () {\n\t    function ParamTypes() {\n\t        this.enqueue = true;\n\t        this.typeQueue = [];\n\t        this.defaultTypes = {\n\t            \"hash\": {\n\t                encode: valToString,\n\t                decode: valFromString,\n\t                is: hof_1.is(String),\n\t                pattern: /.*/,\n\t                equals: function (a, b) { return a == b; } // allow coersion for null/undefined/\"\"\n\t            },\n\t            \"string\": {\n\t                encode: valToString,\n\t                decode: valFromString,\n\t                is: hof_1.is(String),\n\t                pattern: /[^/]*/\n\t            },\n\t            \"int\": {\n\t                encode: valToString,\n\t                decode: function (val) { return parseInt(val, 10); },\n\t                is: function (val) { return predicates_1.isDefined(val) && this.decode(val.toString()) === val; },\n\t                pattern: /-?\\d+/\n\t            },\n\t            \"bool\": {\n\t                encode: function (val) { return val && 1 || 0; },\n\t                decode: function (val) { return parseInt(val, 10) !== 0; },\n\t                is: hof_1.is(Boolean),\n\t                pattern: /0|1/\n\t            },\n\t            \"date\": {\n\t                encode: function (val) {\n\t                    return !this.is(val) ? undefined : [\n\t                        val.getFullYear(),\n\t                        ('0' + (val.getMonth() + 1)).slice(-2),\n\t                        ('0' + val.getDate()).slice(-2)\n\t                    ].join(\"-\");\n\t                },\n\t                decode: function (val) {\n\t                    if (this.is(val))\n\t                        return val;\n\t                    var match = this.capture.exec(val);\n\t                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t                },\n\t                is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t                equals: function (l, r) {\n\t                    return ['getFullYear', 'getMonth', 'getDate']\n\t                        .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n\t                },\n\t                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t            },\n\t            \"json\": {\n\t                encode: common_1.toJson,\n\t                decode: common_1.fromJson,\n\t                is: hof_1.is(Object),\n\t                equals: common_1.equals,\n\t                pattern: /[^/]*/\n\t            },\n\t            \"any\": {\n\t                encode: common_1.identity,\n\t                decode: common_1.identity,\n\t                equals: common_1.equals,\n\t                pattern: /.*/\n\t            }\n\t        };\n\t        // Register default types. Store them in the prototype of this.types.\n\t        var makeType = function (definition, name) { return new type_1.Type(common_1.extend({ name: name }, definition)); };\n\t        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n\t    }\n\t    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n\t        if (!predicates_1.isDefined(definition))\n\t            return this.types[name];\n\t        if (this.types.hasOwnProperty(name))\n\t            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t        this.types[name] = new type_1.Type(common_1.extend({ name: name }, definition));\n\t        if (definitionFn) {\n\t            this.typeQueue.push({ name: name, def: definitionFn });\n\t            if (!this.enqueue)\n\t                this._flushTypeQueue();\n\t        }\n\t        return this;\n\t    };\n\t    ParamTypes.prototype._flushTypeQueue = function () {\n\t        while (this.typeQueue.length) {\n\t            var type = this.typeQueue.shift();\n\t            if (type.pattern)\n\t                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n\t        }\n\t    };\n\t    return ParamTypes;\n\t}());\n\texports.ParamTypes = ParamTypes;\n\texports.paramTypes = new ParamTypes();\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module params */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar StateParams = (function () {\n\t    function StateParams(params) {\n\t        if (params === void 0) { params = {}; }\n\t        common_1.extend(this, params);\n\t    }\n\t    /**\n\t     * Merges a set of parameters with all parameters inherited between the common parents of the\n\t     * current state and a given destination state.\n\t     *\n\t     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t     * @param {Object} $current Internal definition of object representing the current state.\n\t     * @param {Object} $to Internal definition of object representing state to transition to.\n\t     */\n\t    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n\t        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t        for (var i in parents) {\n\t            if (!parents[i] || !parents[i].params)\n\t                continue;\n\t            parentParams = Object.keys(parents[i].params);\n\t            if (!parentParams.length)\n\t                continue;\n\t            for (var j in parentParams) {\n\t                if (inheritList.indexOf(parentParams[j]) >= 0)\n\t                    continue;\n\t                inheritList.push(parentParams[j]);\n\t                inherited[parentParams[j]] = this[parentParams[j]];\n\t            }\n\t        }\n\t        return common_1.extend({}, inherited, newParams);\n\t    };\n\t    ;\n\t    return StateParams;\n\t}());\n\texports.StateParams = StateParams;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar targetState_1 = __webpack_require__(27);\n\tvar viewHooks_1 = __webpack_require__(28);\n\tvar enterExitHooks_1 = __webpack_require__(29);\n\tvar resolveHooks_1 = __webpack_require__(30);\n\tvar coreservices_1 = __webpack_require__(6);\n\t/**\n\t * This class:\n\t *\n\t * * Takes a blank transition object and adds all the hooks necessary for it to behave like a state transition.\n\t *\n\t * * Runs the transition, returning a chained promise which:\n\t *   * transforms the resolved Transition.promise to the final destination state.\n\t *   * manages the rejected Transition.promise, checking for Dynamic or Redirected transitions\n\t *\n\t * * Registers a handler to update global $state data such as \"active transitions\" and \"current state/params\"\n\t *\n\t * * Registers view hooks, which maintain the list of active view configs and sync with/update the ui-views\n\t *\n\t * * Registers onEnter/onRetain/onExit hooks which delegate to the state's hooks of the same name, at the appropriate time\n\t *\n\t * * Registers eager and lazy resolve hooks\n\t */\n\tvar TransitionManager = (function () {\n\t    function TransitionManager(transition, $transitions, $urlRouter, $view, // service\n\t        $state, globals) {\n\t        this.transition = transition;\n\t        this.$transitions = $transitions;\n\t        this.$urlRouter = $urlRouter;\n\t        this.$view = $view;\n\t        this.$state = $state;\n\t        this.globals = globals;\n\t        this.$q = coreservices_1.services.$q;\n\t        this.viewHooks = new viewHooks_1.ViewHooks(transition, $view);\n\t        this.enterExitHooks = new enterExitHooks_1.EnterExitHooks(transition);\n\t        this.resolveHooks = new resolveHooks_1.ResolveHooks(transition);\n\t        this.treeChanges = transition.treeChanges();\n\t        this.registerUpdateGlobalState();\n\t        this.viewHooks.registerHooks();\n\t        this.enterExitHooks.registerHooks();\n\t        this.resolveHooks.registerHooks();\n\t    }\n\t    TransitionManager.prototype.runTransition = function () {\n\t        var _this = this;\n\t        this.globals.transitionHistory.enqueue(this.transition);\n\t        return this.transition.run()\n\t            .then(function (trans) { return trans.to(); }) // resolve to the final state (TODO: good? bad?)\n\t            .catch(function (error) { return _this.transRejected(error); }); // if rejected, handle dynamic and redirect\n\t    };\n\t    TransitionManager.prototype.registerUpdateGlobalState = function () {\n\t        // After globals.current is updated at priority: 10000\n\t        this.transition.onSuccess({}, this.updateUrl.bind(this), { priority: 9999 });\n\t    };\n\t    TransitionManager.prototype.transRejected = function (error) {\n\t        var _a = this, transition = _a.transition, $state = _a.$state, $q = _a.$q;\n\t        // Handle redirect and abort\n\t        if (error instanceof rejectFactory_1.Rejection) {\n\t            if (error.type === rejectFactory_1.RejectType.IGNORED) {\n\t                this.$urlRouter.update();\n\t                return $state.current;\n\t            }\n\t            if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && error.detail instanceof targetState_1.TargetState) {\n\t                return this._redirectMgr(transition.redirect(error.detail)).runTransition();\n\t            }\n\t            if (error.type === rejectFactory_1.RejectType.ABORTED) {\n\t                this.$urlRouter.update();\n\t            }\n\t        }\n\t        this.$transitions.defaultErrorHandler()(error);\n\t        return $q.reject(error);\n\t    };\n\t    TransitionManager.prototype.updateUrl = function () {\n\t        var transition = this.transition;\n\t        var _a = this, $urlRouter = _a.$urlRouter, $state = _a.$state;\n\t        var options = transition.options();\n\t        if (options.location && $state.$current.navigable) {\n\t            $urlRouter.push($state.$current.navigable.url, $state.params, { replace: options.location === 'replace' });\n\t        }\n\t        $urlRouter.update(true);\n\t    };\n\t    TransitionManager.prototype._redirectMgr = function (redirect) {\n\t        var _a = this, $transitions = _a.$transitions, $urlRouter = _a.$urlRouter, $view = _a.$view, $state = _a.$state, globals = _a.globals;\n\t        return new TransitionManager(redirect, $transitions, $urlRouter, $view, $state, globals);\n\t    };\n\t    return TransitionManager;\n\t}());\n\texports.TransitionManager = TransitionManager;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t/** @module state */ /** for typedoc */\n\t\"use strict\";\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.type:TargetState\n\t *\n\t * @description\n\t * Encapsulate the desired target of a transition.\n\t * Wraps an identifier for a state, a set of parameters, and transition options with the definition of the state.\n\t *\n\t * @param {StateOrName} _identifier  An identifier for a state. Either a fully-qualified path, or the object\n\t *            used to define the state.\n\t * @param {IState} _definition The `State` object definition.\n\t * @param {ParamsOrArray} _params Parameters for the target state\n\t * @param {TransitionOptions} _options Transition options.\n\t */\n\tvar TargetState = (function () {\n\t    function TargetState(_identifier, _definition, _params, _options) {\n\t        if (_params === void 0) { _params = {}; }\n\t        if (_options === void 0) { _options = {}; }\n\t        this._identifier = _identifier;\n\t        this._definition = _definition;\n\t        this._options = _options;\n\t        this._params = _params || {};\n\t    }\n\t    TargetState.prototype.name = function () {\n\t        return this._definition && this._definition.name || this._identifier;\n\t    };\n\t    TargetState.prototype.identifier = function () {\n\t        return this._identifier;\n\t    };\n\t    TargetState.prototype.params = function () {\n\t        return this._params;\n\t    };\n\t    TargetState.prototype.$state = function () {\n\t        return this._definition;\n\t    };\n\t    TargetState.prototype.state = function () {\n\t        return this._definition && this._definition.self;\n\t    };\n\t    TargetState.prototype.options = function () {\n\t        return this._options;\n\t    };\n\t    TargetState.prototype.exists = function () {\n\t        return !!(this._definition && this._definition.self);\n\t    };\n\t    TargetState.prototype.valid = function () {\n\t        return !this.error();\n\t    };\n\t    TargetState.prototype.error = function () {\n\t        var base = this.options().relative;\n\t        if (!this._definition && !!base) {\n\t            var stateName = base.name ? base.name : base;\n\t            return \"Could not resolve '\" + this.name() + \"' from state '\" + stateName + \"'\";\n\t        }\n\t        if (!this._definition)\n\t            return \"No such state '\" + this.name() + \"'\";\n\t        if (!this._definition.self)\n\t            return \"State '\" + this.name() + \"' has an invalid definition\";\n\t    };\n\t    return TargetState;\n\t}());\n\texports.TargetState = TargetState;\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar ViewHooks = (function () {\n\t    function ViewHooks(transition, $view) {\n\t        this.transition = transition;\n\t        this.$view = $view;\n\t        this.treeChanges = transition.treeChanges();\n\t        this.enteringViews = transition.views(\"entering\");\n\t        this.exitingViews = transition.views(\"exiting\");\n\t    }\n\t    ViewHooks.prototype.loadAllEnteringViews = function () {\n\t        return coreservices_1.services.$q.all(this.enteringViews.map(function (view) { return view.load(); })).then(common_1.noop);\n\t    };\n\t    ViewHooks.prototype.updateViews = function () {\n\t        var $view = this.$view;\n\t        this.exitingViews.forEach(function (viewConfig) { return $view.deactivateViewConfig(viewConfig); });\n\t        this.enteringViews.forEach(function (viewConfig) { return $view.activateViewConfig(viewConfig); });\n\t        $view.sync();\n\t    };\n\t    ViewHooks.prototype.registerHooks = function () {\n\t        if (this.enteringViews.length) {\n\t            this.transition.onStart({}, this.loadAllEnteringViews.bind(this));\n\t        }\n\t        if (this.exitingViews.length || this.enteringViews.length)\n\t            this.transition.onSuccess({}, this.updateViews.bind(this));\n\t    };\n\t    return ViewHooks;\n\t}());\n\texports.ViewHooks = ViewHooks;\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar EnterExitHooks = (function () {\n\t    function EnterExitHooks(transition) {\n\t        this.transition = transition;\n\t    }\n\t    EnterExitHooks.prototype.registerHooks = function () {\n\t        this.registerOnEnterHooks();\n\t        this.registerOnRetainHooks();\n\t        this.registerOnExitHooks();\n\t    };\n\t    EnterExitHooks.prototype.registerOnEnterHooks = function () {\n\t        var _this = this;\n\t        this.transition.entering().filter(function (state) { return !!state.onEnter; })\n\t            .forEach(function (state) { return _this.transition.onEnter({ entering: state.name }, state.onEnter); });\n\t    };\n\t    EnterExitHooks.prototype.registerOnRetainHooks = function () {\n\t        var _this = this;\n\t        this.transition.retained().filter(function (state) { return !!state.onRetain; })\n\t            .forEach(function (state) { return _this.transition.onRetain({ retained: state.name }, state.onRetain); });\n\t    };\n\t    EnterExitHooks.prototype.registerOnExitHooks = function () {\n\t        var _this = this;\n\t        this.transition.exiting().filter(function (state) { return !!state.onExit; })\n\t            .forEach(function (state) { return _this.transition.onExit({ exiting: state.name }, state.onExit); });\n\t    };\n\t    return EnterExitHooks;\n\t}());\n\texports.EnterExitHooks = EnterExitHooks;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar interface_1 = __webpack_require__(31);\n\tvar hof_2 = __webpack_require__(5);\n\tvar resolvable_1 = __webpack_require__(32);\n\tvar LAZY = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];\n\tvar EAGER = interface_1.ResolvePolicy[interface_1.ResolvePolicy.EAGER];\n\t/**\n\t * Registers Eager and Lazy (for entering states) resolve hooks\n\t *\n\t * * registers a hook that resolves EAGER resolves, for the To Path, onStart of the transition\n\t * * registers a hook that resolves LAZY resolves, for each state, before it is entered\n\t */\n\tvar ResolveHooks = (function () {\n\t    function ResolveHooks(transition) {\n\t        this.transition = transition;\n\t    }\n\t    ResolveHooks.prototype.registerHooks = function () {\n\t        var treeChanges = this.transition.treeChanges();\n\t        /** a function which resolves any EAGER Resolvables for a Path */\n\t        $eagerResolvePath.$inject = ['$transition$'];\n\t        function $eagerResolvePath($transition$) {\n\t            return common_1.tail(treeChanges.to).resolveContext.resolvePath(common_1.extend({ transition: $transition$ }, { resolvePolicy: EAGER }));\n\t        }\n\t        /** Returns a function which pre-resolves any LAZY Resolvables for a Node in a Path */\n\t        $lazyResolveEnteringState.$inject = ['$state$', '$transition$'];\n\t        function $lazyResolveEnteringState($state$, $transition$) {\n\t            var node = common_1.find(treeChanges.entering, hof_1.propEq('state', $state$));\n\t            // A new Resolvable contains all the resolved data in this context as a single object, for injection as `$resolve$`\n\t            var context = node.resolveContext;\n\t            var $resolve$ = new resolvable_1.Resolvable(\"$resolve$\", function () { return common_1.map(context.getResolvables(), function (r) { return r.data; }); });\n\t            var options = common_1.extend({ transition: $transition$ }, { resolvePolicy: LAZY });\n\t            // Resolve all the LAZY resolves, then resolve the `$resolve$` object, then add `$resolve$` to the context\n\t            return context.resolvePathElement(node.state, options)\n\t                .then(function () { return $resolve$.resolveResolvable(context); })\n\t                .then(function () { return context.addResolvables({ $resolve$: $resolve$ }, node.state); });\n\t        }\n\t        // Resolve eager resolvables before when the transition starts\n\t        this.transition.onStart({}, $eagerResolvePath, { priority: 1000 });\n\t        // Resolve lazy resolvables before each state is entered\n\t        this.transition.onEnter({ entering: hof_2.val(true) }, $lazyResolveEnteringState, { priority: 1000 });\n\t    };\n\t    return ResolveHooks;\n\t}());\n\texports.ResolveHooks = ResolveHooks;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// Defines the available policies and their ordinals.\n\t(function (ResolvePolicy) {\n\t    ResolvePolicy[ResolvePolicy[\"JIT\"] = 0] = \"JIT\";\n\t    ResolvePolicy[ResolvePolicy[\"LAZY\"] = 1] = \"LAZY\";\n\t    ResolvePolicy[ResolvePolicy[\"EAGER\"] = 2] = \"EAGER\"; // Eager resolves are resolved before the transition starts.\n\t})(exports.ResolvePolicy || (exports.ResolvePolicy = {}));\n\tvar ResolvePolicy = exports.ResolvePolicy;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar trace_1 = __webpack_require__(12);\n\t/**\n\t * The basic building block for the resolve system.\n\t *\n\t * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n\t * and the unwrapped-when-complete (.data) result of the resolveFn.\n\t *\n\t * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n\t * resolveFn) and returns the resulting promise.\n\t *\n\t * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n\t * parameter to those fns.\n\t */\n\tvar Resolvable = (function () {\n\t    function Resolvable(name, resolveFn, preResolvedData) {\n\t        this.promise = undefined;\n\t        common_1.extend(this, {\n\t            name: name,\n\t            resolveFn: resolveFn,\n\t            deps: coreservices_1.services.$injector.annotate(resolveFn, coreservices_1.services.$injector.strictDi),\n\t            data: preResolvedData\n\t        });\n\t    }\n\t    // synchronous part:\n\t    // - sets up the Resolvable's promise\n\t    // - retrieves dependencies' promises\n\t    // - returns promise for async part\n\t    // asynchronous part:\n\t    // - wait for dependencies promises to resolve\n\t    // - invoke the resolveFn\n\t    // - wait for resolveFn promise to resolve\n\t    // - store unwrapped data\n\t    // - resolve the Resolvable's promise\n\t    Resolvable.prototype.resolveResolvable = function (resolveContext, options) {\n\t        var _this = this;\n\t        if (options === void 0) { options = {}; }\n\t        var _a = this, name = _a.name, deps = _a.deps, resolveFn = _a.resolveFn;\n\t        trace_1.trace.traceResolveResolvable(this, options);\n\t        // First, set up an overall deferred/promise for this Resolvable\n\t        var deferred = coreservices_1.services.$q.defer();\n\t        this.promise = deferred.promise;\n\t        // Load a map of all resolvables for this state from the context path\n\t        // Omit the current Resolvable from the result, so we don't try to inject this into this\n\t        var ancestorsByName = resolveContext.getResolvables(null, { omitOwnLocals: [name] });\n\t        // Limit the ancestors Resolvables map to only those that the current Resolvable fn's annotations depends on\n\t        var depResolvables = common_1.pick(ancestorsByName, deps);\n\t        // Get promises (or synchronously invoke resolveFn) for deps\n\t        var depPromises = common_1.map(depResolvables, function (resolvable) { return resolvable.get(resolveContext, options); });\n\t        // Return a promise chain that waits for all the deps to resolve, then invokes the resolveFn passing in the\n\t        // dependencies as locals, then unwraps the resulting promise's data.\n\t        return coreservices_1.services.$q.all(depPromises).then(function (locals) {\n\t            try {\n\t                var result = coreservices_1.services.$injector.invoke(resolveFn, null, locals);\n\t                deferred.resolve(result);\n\t            }\n\t            catch (error) {\n\t                deferred.reject(error);\n\t            }\n\t            return _this.promise;\n\t        }).then(function (data) {\n\t            _this.data = data;\n\t            trace_1.trace.traceResolvableResolved(_this, options);\n\t            return _this.promise;\n\t        });\n\t    };\n\t    Resolvable.prototype.get = function (resolveContext, options) {\n\t        return this.promise || this.resolveResolvable(resolveContext, options);\n\t    };\n\t    Resolvable.prototype.toString = function () {\n\t        return \"Resolvable(name: \" + this.name + \", requires: [\" + this.deps + \"])\";\n\t    };\n\t    /**\n\t     * Validates the result map as a \"resolve:\" style object, then transforms the resolves into Resolvables\n\t     */\n\t    Resolvable.makeResolvables = function (resolves) {\n\t        // If a hook result is an object, it should be a map of strings to functions.\n\t        var invalid = common_1.filter(resolves, hof_1.not(predicates_1.isInjectable)), keys = Object.keys(invalid);\n\t        if (keys.length)\n\t            throw new Error(\"Invalid resolve key/value: \" + keys[0] + \"/\" + invalid[keys[0]]);\n\t        return common_1.map(resolves, function (fn, name) { return new Resolvable(name, fn); });\n\t    };\n\t    return Resolvable;\n\t}());\n\texports.Resolvable = Resolvable;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module state */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.type:State\n\t *\n\t * @description\n\t * Definition object for states. Includes methods for manipulating the state heirarchy.\n\t *\n\t * @param {Object} config  A configuration object hash that includes the results of user-supplied\n\t *        values, as well as values from `StateBuilder`.\n\t *\n\t * @returns {Object}  Returns a new `State` object.\n\t */\n\tvar State = (function () {\n\t    function State(config) {\n\t        common_1.extend(this, config);\n\t        // Object.freeze(this);\n\t    }\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.type:State#is\n\t     * @methodOf ui.router.state.type:State\n\t     *\n\t     * @description\n\t     * Compares the identity of the state against the passed value, which is either an object\n\t     * reference to the actual `State` instance, the original definition object passed to\n\t     * `$stateProvider.state()`, or the fully-qualified name.\n\t     *\n\t     * @param {Object} ref Can be one of (a) a `State` instance, (b) an object that was passed\n\t     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n\t     * @returns {boolean} Returns `true` if `ref` matches the current `State` instance.\n\t     */\n\t    State.prototype.is = function (ref) {\n\t        return this === ref || this.self === ref || this.fqn() === ref;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.type:State#fqn\n\t     * @methodOf ui.router.state.type:State\n\t     *\n\t     * @description\n\t     * Returns the fully-qualified name of the state, based on its current position in the tree.\n\t     *\n\t     * @returns {string} Returns a dot-separated name of the state.\n\t     */\n\t    State.prototype.fqn = function () {\n\t        if (!this.parent || !(this.parent instanceof this.constructor))\n\t            return this.name;\n\t        var name = this.parent.fqn();\n\t        return name ? name + \".\" + this.name : this.name;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.type:State#root\n\t     * @methodOf ui.router.state.type:State\n\t     *\n\t     * @description\n\t     * Returns the root node of this state's tree.\n\t     *\n\t     * @returns {State} The root of this state's tree.\n\t     */\n\t    State.prototype.root = function () {\n\t        return this.parent && this.parent.root() || this;\n\t    };\n\t    State.prototype.parameters = function (opts) {\n\t        opts = common_1.defaults(opts, { inherit: true });\n\t        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n\t        return inherited.concat(common_1.values(this.params));\n\t    };\n\t    State.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        return (this.url && this.url.parameter(id, opts) ||\n\t            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n\t            opts.inherit && this.parent && this.parent.parameter(id));\n\t    };\n\t    State.prototype.toString = function () {\n\t        return this.fqn();\n\t    };\n\t    return State;\n\t}());\n\texports.State = State;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(4);\n\tvar StateMatcher = (function () {\n\t    function StateMatcher(_states) {\n\t        this._states = _states;\n\t    }\n\t    StateMatcher.prototype.isRelative = function (stateName) {\n\t        stateName = stateName || \"\";\n\t        return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t    };\n\t    StateMatcher.prototype.find = function (stateOrName, base) {\n\t        if (!stateOrName && stateOrName !== \"\")\n\t            return undefined;\n\t        var isStr = predicates_1.isString(stateOrName);\n\t        var name = isStr ? stateOrName : stateOrName.name;\n\t        if (this.isRelative(name))\n\t            name = this.resolvePath(name, base);\n\t        var state = this._states[name];\n\t        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t            return state;\n\t        }\n\t        return undefined;\n\t    };\n\t    StateMatcher.prototype.resolvePath = function (name, base) {\n\t        if (!base)\n\t            throw new Error(\"No reference point given for path '\" + name + \"'\");\n\t        var baseState = this.find(base);\n\t        var splitName = name.split(\".\"), i = 0, pathLength = splitName.length, current = baseState;\n\t        for (; i < pathLength; i++) {\n\t            if (splitName[i] === \"\" && i === 0) {\n\t                current = baseState;\n\t                continue;\n\t            }\n\t            if (splitName[i] === \"^\") {\n\t                if (!current.parent)\n\t                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n\t                current = current.parent;\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t        var relName = splitName.slice(i).join(\".\");\n\t        return current.name + (current.name && relName ? \".\" : \"\") + relName;\n\t    };\n\t    return StateMatcher;\n\t}());\n\texports.StateMatcher = StateMatcher;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(17);\n\tvar StateQueueManager = (function () {\n\t    function StateQueueManager(states, builder, $urlRouterProvider) {\n\t        this.states = states;\n\t        this.builder = builder;\n\t        this.$urlRouterProvider = $urlRouterProvider;\n\t        this.queue = [];\n\t    }\n\t    StateQueueManager.prototype.register = function (config) {\n\t        var _a = this, states = _a.states, queue = _a.queue, $state = _a.$state;\n\t        // Wrap a new object around the state so we can store our private details easily.\n\t        // @TODO: state = new State(extend({}, config, { ... }))\n\t        var state = common_1.inherit(new module_1.State(), common_1.extend({}, config, {\n\t            self: config,\n\t            resolve: config.resolve || {},\n\t            toString: function () { return config.name; }\n\t        }));\n\t        if (!predicates_1.isString(state.name))\n\t            throw new Error(\"State must have a valid name\");\n\t        if (states.hasOwnProperty(state.name) || common_1.pluck(queue, 'name').indexOf(state.name) !== -1)\n\t            throw new Error(\"State '\" + state.name + \"' is already defined\");\n\t        queue.push(state);\n\t        if (this.$state) {\n\t            this.flush($state);\n\t        }\n\t        return state;\n\t    };\n\t    StateQueueManager.prototype.flush = function ($state) {\n\t        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n\t        var result, state, orphans = [], orphanIdx, previousQueueLength = {};\n\t        while (queue.length > 0) {\n\t            state = queue.shift();\n\t            result = builder.build(state);\n\t            orphanIdx = orphans.indexOf(state);\n\t            if (result) {\n\t                if (states.hasOwnProperty(state.name))\n\t                    throw new Error(\"State '\" + name + \"' is already defined\");\n\t                states[state.name] = state;\n\t                this.attachRoute($state, state);\n\t                if (orphanIdx >= 0)\n\t                    orphans.splice(orphanIdx, 1);\n\t                continue;\n\t            }\n\t            var prev = previousQueueLength[state.name];\n\t            previousQueueLength[state.name] = queue.length;\n\t            if (orphanIdx >= 0 && prev === queue.length) {\n\t                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n\t                // throw new Error(`Cannot register orphaned state '${state.name}'`);\n\t                return states;\n\t            }\n\t            else if (orphanIdx < 0) {\n\t                orphans.push(state);\n\t            }\n\t            queue.push(state);\n\t        }\n\t        return states;\n\t    };\n\t    StateQueueManager.prototype.autoFlush = function ($state) {\n\t        this.$state = $state;\n\t        this.flush($state);\n\t    };\n\t    StateQueueManager.prototype.attachRoute = function ($state, state) {\n\t        var $urlRouterProvider = this.$urlRouterProvider;\n\t        if (state[common_1.abstractKey] || !state.url)\n\t            return;\n\t        $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t                if ($state.$current.navigable !== state || !common_1.equalForKeys($match, $stateParams)) {\n\t                    $state.transitionTo(state, $match, { inherit: true, location: false });\n\t                }\n\t            }]);\n\t    };\n\t    return StateQueueManager;\n\t}());\n\texports.StateQueueManager = StateQueueManager;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module state */ /** for typedoc */\n\t\"use strict\";\n\tvar stateMatcher_1 = __webpack_require__(34);\n\tvar stateBuilder_1 = __webpack_require__(19);\n\tvar stateQueueManager_1 = __webpack_require__(35);\n\tvar StateRegistry = (function () {\n\t    function StateRegistry(urlMatcherFactory, urlRouterProvider) {\n\t        this.states = {};\n\t        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n\t        this.builder = new stateBuilder_1.StateBuilder(this.matcher, urlMatcherFactory);\n\t        this.stateQueue = new stateQueueManager_1.StateQueueManager(this.states, this.builder, urlRouterProvider);\n\t        var rootStateDef = {\n\t            name: '',\n\t            url: '^',\n\t            views: null,\n\t            params: {\n\t                '#': { value: null, type: 'hash', dynamic: true }\n\t            },\n\t            abstract: true\n\t        };\n\t        var _root = this._root = this.stateQueue.register(rootStateDef);\n\t        _root.navigable = null;\n\t    }\n\t    StateRegistry.prototype.root = function () {\n\t        return this._root;\n\t    };\n\t    StateRegistry.prototype.register = function (stateDefinition) {\n\t        return this.stateQueue.register(stateDefinition);\n\t    };\n\t    StateRegistry.prototype.get = function (stateOrName, base) {\n\t        var _this = this;\n\t        if (arguments.length === 0)\n\t            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n\t        var found = this.matcher.find(stateOrName, base);\n\t        return found && found.self || null;\n\t    };\n\t    StateRegistry.prototype.decorator = function (name, func) {\n\t        return this.builder.builder(name, func);\n\t    };\n\t    return StateRegistry;\n\t}());\n\texports.StateRegistry = StateRegistry;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module state */ /** */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar queue_1 = __webpack_require__(8);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar pathFactory_1 = __webpack_require__(38);\n\tvar node_1 = __webpack_require__(39);\n\tvar transitionService_1 = __webpack_require__(43);\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar targetState_1 = __webpack_require__(27);\n\tvar transitionManager_1 = __webpack_require__(26);\n\tvar param_1 = __webpack_require__(21);\n\tvar glob_1 = __webpack_require__(7);\n\tvar common_2 = __webpack_require__(3);\n\tvar common_3 = __webpack_require__(3);\n\tvar StateService = (function () {\n\t    function StateService($view, $urlRouter, $transitions, stateRegistry, stateProvider, globals) {\n\t        this.$view = $view;\n\t        this.$urlRouter = $urlRouter;\n\t        this.$transitions = $transitions;\n\t        this.stateRegistry = stateRegistry;\n\t        this.stateProvider = stateProvider;\n\t        this.globals = globals;\n\t        var getters = ['current', '$current', 'params', 'transition'];\n\t        var boundFns = Object.keys(StateService.prototype).filter(function (key) { return getters.indexOf(key) === -1; });\n\t        common_3.bindFunctions(StateService.prototype, this, this, boundFns);\n\t    }\n\t    Object.defineProperty(StateService.prototype, \"transition\", {\n\t        get: function () { return this.globals.transition; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"params\", {\n\t        get: function () { return this.globals.params; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"current\", {\n\t        get: function () { return this.globals.current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(StateService.prototype, \"$current\", {\n\t        get: function () { return this.globals.$current; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    /**\n\t     * Invokes the onInvalid callbacks, in natural order.  Each callback's return value is checked in sequence\n\t     * until one of them returns an instance of TargetState.   The results of the callbacks are wrapped\n\t     * in $q.when(), so the callbacks may return promises.\n\t     *\n\t     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and\n\t     * the result returned.\n\t     */\n\t    StateService.prototype._handleInvalidTargetState = function (fromPath, $to$) {\n\t        var _this = this;\n\t        var latestThing = function () { return _this.globals.transitionHistory.peekTail(); };\n\t        var latest = latestThing();\n\t        var $from$ = pathFactory_1.PathFactory.makeTargetState(fromPath);\n\t        var callbackQueue = new queue_1.Queue([].concat(this.stateProvider.invalidCallbacks));\n\t        var $q = coreservices_1.services.$q, $injector = coreservices_1.services.$injector;\n\t        var invokeCallback = function (callback) { return $q.when($injector.invoke(callback, null, { $to$: $to$, $from$: $from$ })); };\n\t        var checkForRedirect = function (result) {\n\t            if (!(result instanceof targetState_1.TargetState)) {\n\t                return;\n\t            }\n\t            var target = result;\n\t            // Recreate the TargetState, in case the state is now defined.\n\t            target = _this.target(target.identifier(), target.params(), target.options());\n\t            if (!target.valid())\n\t                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n\t            if (latestThing() !== latest)\n\t                return rejectFactory_1.Rejection.superseded().toPromise();\n\t            return _this.transitionTo(target.identifier(), target.params(), target.options());\n\t        };\n\t        function invokeNextCallback() {\n\t            var nextCallback = callbackQueue.dequeue();\n\t            if (nextCallback === undefined)\n\t                return rejectFactory_1.Rejection.invalid($to$.error()).toPromise();\n\t            return invokeCallback(nextCallback).then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n\t        }\n\t        return invokeNextCallback();\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state, or a partial state hierarchy. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, {\n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} reloadState - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n\t     * //and current state is 'contacts.detail.item'\n\t     * let app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    StateService.prototype.reload = function (reloadState) {\n\t        return this.transitionTo(this.current, this.params, {\n\t            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n\t            inherit: false,\n\t            notify: false\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls\n\t     * `$state.transitionTo` internally but automatically sets options to\n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.\n\t     * This allows you to easily use an absolute or relative to path and specify\n\t     * only the parameters you'd like to update (while letting unspecified parameters\n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently\n\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params\n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    StateService.prototype.go = function (to, params, options) {\n\t        var defautGoOpts = { relative: this.$current, inherit: true };\n\t        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n\t        return this.transitionTo(to, params, transOpts);\n\t    };\n\t    ;\n\t    /** Factory method for creating a TargetState */\n\t    StateService.prototype.target = function (identifier, params, options) {\n\t        if (options === void 0) { options = {}; }\n\t        // If we're reloading, find the state object to reload from\n\t        if (predicates_1.isObject(options.reload) && !options.reload.name)\n\t            throw new Error('Invalid reload state object');\n\t        options.reloadState = options.reload === true ? this.stateRegistry.root() : this.stateRegistry.matcher.find(options.reload, options.relative);\n\t        if (options.reload && !options.reloadState)\n\t            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        var stateDefinition = this.stateRegistry.matcher.find(identifier, options.relative);\n\t        return new targetState_1.TargetState(identifier, stateDefinition, params, options);\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * let app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params\n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    StateService.prototype.transitionTo = function (to, toParams, options) {\n\t        var _this = this;\n\t        if (toParams === void 0) { toParams = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var transHistory = this.globals.transitionHistory;\n\t        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n\t        options = common_1.extend(options, { current: transHistory.peekTail.bind(transHistory) });\n\t        var ref = this.target(to, toParams, options);\n\t        var latestSuccess = this.globals.successfulTransitions.peekTail();\n\t        var rootPath = function () { return pathFactory_1.PathFactory.bindTransNodesToPath([new node_1.Node(_this.stateRegistry.root())]); };\n\t        var currentPath = latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n\t        if (!ref.exists())\n\t            return this._handleInvalidTargetState(currentPath, ref);\n\t        if (!ref.valid())\n\t            return coreservices_1.services.$q.reject(ref.error());\n\t        var transition = this.$transitions.create(currentPath, ref);\n\t        var tMgr = new transitionManager_1.TransitionManager(transition, this.$transitions, this.$urlRouter, this.$view, this, this.globals);\n\t        var transitionPromise = tMgr.runTransition();\n\t        // Return a promise for the transition, which also has the transition object on it.\n\t        return common_1.extend(transitionPromise, { transition: transition });\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    StateService.prototype.is = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (this.$current !== state)\n\t            return false;\n\t        return predicates_1.isDefined(params) && params !== null ? param_1.Param.equals(state.parameters(), this.params, params) : true;\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    StateService.prototype.includes = function (stateOrName, params, options) {\n\t        options = common_1.defaults(options, { relative: this.$current });\n\t        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n\t        if (glob) {\n\t            if (!glob.matches(this.$current.name))\n\t                return false;\n\t            stateOrName = this.$current.name;\n\t        }\n\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n\t        if (!predicates_1.isDefined(state))\n\t            return undefined;\n\t        if (!predicates_1.isDefined(include[state.name]))\n\t            return false;\n\t        // @TODO Replace with Param.equals() ?\n\t        return params ? common_2.equalForKeys(param_1.Param.values(state.parameters(), params), this.params, Object.keys(params)) : true;\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),\n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} compiled state url\n\t     */\n\t    StateService.prototype.href = function (stateOrName, params, options) {\n\t        var defaultHrefOpts = {\n\t            lossy: true,\n\t            inherit: true,\n\t            absolute: false,\n\t            relative: this.$current\n\t        };\n\t        options = common_1.defaults(options, defaultHrefOpts);\n\t        var state = this.stateRegistry.matcher.find(stateOrName, options.relative);\n\t        if (!predicates_1.isDefined(state))\n\t            return null;\n\t        if (options.inherit)\n\t            params = this.params.$inherit(params || {}, this.$current, state);\n\t        var nav = (state && options.lossy) ? state.navigable : state;\n\t        if (!nav || nav.url === undefined || nav.url === null) {\n\t            return null;\n\t        }\n\t        return this.$urlRouter.href(nav.url, param_1.Param.values(state.parameters(), params), {\n\t            absolute: options.absolute\n\t        });\n\t    };\n\t    ;\n\t    StateService.prototype.get = function (stateOrName, base) {\n\t        if (arguments.length === 0)\n\t            return this.stateRegistry.get();\n\t        return this.stateRegistry.get(stateOrName, base || this.$current);\n\t    };\n\t    return StateService;\n\t}());\n\texports.StateService = StateService;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module path */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar module_1 = __webpack_require__(17);\n\tvar node_1 = __webpack_require__(39);\n\tvar module_2 = __webpack_require__(40);\n\t/**\n\t * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n\t */\n\tvar PathFactory = (function () {\n\t    function PathFactory() {\n\t    }\n\t    /** Given a Node[], create an TargetState */\n\t    PathFactory.makeTargetState = function (path) {\n\t        var state = common_1.tail(path).state;\n\t        return new module_1.TargetState(state, state, path.map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n\t    };\n\t    PathFactory.buildPath = function (targetState) {\n\t        var toParams = targetState.params();\n\t        return targetState.$state().path.map(function (state) { return new node_1.Node(state).applyRawParams(toParams); });\n\t    };\n\t    /** Given a fromPath: Node[] and a TargetState, builds a toPath: Node[] */\n\t    PathFactory.buildToPath = function (fromPath, targetState) {\n\t        var toPath = PathFactory.buildPath(targetState);\n\t        if (targetState.options().inherit) {\n\t            return PathFactory.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n\t        }\n\t        return toPath;\n\t    };\n\t    PathFactory.applyViewConfigs = function ($view, path) {\n\t        return path.map(function (node) {\n\t            var viewDecls = common_1.values(node.state.views || {});\n\t            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(node, view); }).reduce(common_1.unnestR, []);\n\t            return common_1.extend(node, { views: viewConfigs });\n\t        });\n\t    };\n\t    /**\n\t     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n\t     *\n\t     * For a parameter in a node to be inherited from the from path:\n\t     * - The toPath's node must have a matching node in the fromPath (by state).\n\t     * - The parameter name must not be found in the toKeys parameter array.\n\t     *\n\t     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n\t     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n\t     * it is not inherited from the fromPath.\n\t     */\n\t    PathFactory.inheritParams = function (fromPath, toPath, toKeys) {\n\t        if (toKeys === void 0) { toKeys = []; }\n\t        function nodeParamVals(path, state) {\n\t            var node = common_1.find(path, hof_1.propEq('state', state));\n\t            return common_1.extend({}, node && node.paramValues);\n\t        }\n\t        /**\n\t         * Given an Node \"toNode\", return a new Node with param values inherited from the\n\t         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n\t         */\n\t        var makeInheritedParamsNode = hof_1.curry(function (_fromPath, _toKeys, toNode) {\n\t            // All param values for the node (may include default key/vals, when key was not found in toParams)\n\t            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n\t            // limited to only those keys found in toParams\n\t            var incomingParamVals = common_1.pick(toParamVals, _toKeys);\n\t            toParamVals = common_1.omit(toParamVals, _toKeys);\n\t            var fromParamVals = nodeParamVals(_fromPath, toNode.state) || {};\n\t            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n\t            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n\t            return new node_1.Node(toNode.state).applyRawParams(ownParamVals);\n\t        });\n\t        // The param keys specified by the incoming toParams\n\t        return toPath.map(makeInheritedParamsNode(fromPath, toKeys));\n\t    };\n\t    /**\n\t     * Given a path, upgrades the path to a Node[].  Each node is assigned a ResolveContext\n\t     * and ParamValues object which is bound to the whole path, but closes over the subpath from root to the node.\n\t     * The views are also added to the node.\n\t     */\n\t    PathFactory.bindTransNodesToPath = function (resolvePath) {\n\t        var resolveContext = new module_2.ResolveContext(resolvePath);\n\t        // let paramValues = new ParamValues(resolvePath);\n\t        // Attach bound resolveContext and paramValues to each node\n\t        // Attach views to each node\n\t        resolvePath.forEach(function (node) {\n\t            node.resolveContext = resolveContext.isolateRootTo(node.state);\n\t            node.resolveInjector = new module_2.ResolveInjector(node.resolveContext, node.state);\n\t            node.resolves['$stateParams'] = new module_2.Resolvable(\"$stateParams\", function () { return node.paramValues; }, node.paramValues);\n\t        });\n\t        return resolvePath;\n\t    };\n\t    /**\n\t     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n\t     */\n\t    PathFactory.treeChanges = function (fromPath, toPath, reloadState) {\n\t        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n\t        var staticParams = function (state) { return state.parameters({ inherit: false }).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id')); };\n\t        var nodesMatch = function (node1, node2) { return node1.equals(node2, staticParams(node1.state)); };\n\t        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n\t            keep++;\n\t        }\n\t        /** Given a retained node, return a new node which uses the to node's param values */\n\t        function applyToParams(retainedNode, idx) {\n\t            var cloned = node_1.Node.clone(retainedNode);\n\t            cloned.paramValues = toPath[idx].paramValues;\n\t            return cloned;\n\t        }\n\t        var from, retained, exiting, entering, to;\n\t        // intermediate vars\n\t        var retainedWithToParams, enteringResolvePath, toResolvePath;\n\t        from = fromPath;\n\t        retained = from.slice(0, keep);\n\t        exiting = from.slice(keep);\n\t        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n\t        retainedWithToParams = retained.map(applyToParams);\n\t        enteringResolvePath = toPath.slice(keep);\n\t        // \"toResolvePath\" is \"retainedWithToParams\" concat \"enteringResolvePath\".\n\t        toResolvePath = (retainedWithToParams).concat(enteringResolvePath);\n\t        // \"to: is \"toResolvePath\" with ParamValues/ResolveContext added to each node and bound to the path context\n\t        to = PathFactory.bindTransNodesToPath(toResolvePath);\n\t        // \"entering\" is the tail of \"to\"\n\t        entering = to.slice(keep);\n\t        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n\t    };\n\t    PathFactory.bindTransitionResolve = function (treeChanges, transition) {\n\t        var rootNode = treeChanges.to[0];\n\t        rootNode.resolves['$transition$'] = new module_2.Resolvable('$transition$', function () { return transition; }, transition);\n\t    };\n\t    /**\n\t     * Find a subpath of a path that stops at the node for a given state\n\t     *\n\t     * Given an array of nodes, returns a subset of the array starting from the first node, up to the\n\t     * node whose state matches `stateName`\n\t     *\n\t     * @param path a path of [[Node]]s\n\t     * @param state the [[State]] to stop at\n\t     */\n\t    PathFactory.subPath = function (path, state) {\n\t        var node = common_1.find(path, function (_node) { return _node.state === state; });\n\t        var elementIdx = path.indexOf(node);\n\t        if (elementIdx === -1)\n\t            throw new Error(\"The path does not contain the state: \" + state);\n\t        return path.slice(0, elementIdx + 1);\n\t    };\n\t    /** Gets the raw parameter values from a path */\n\t    PathFactory.paramValues = function (path) { return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {}); };\n\t    return PathFactory;\n\t}());\n\texports.PathFactory = PathFactory;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module path */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar module_1 = __webpack_require__(40);\n\tvar Node = (function () {\n\t    function Node(state) {\n\t        if (state instanceof Node) {\n\t            var node = state;\n\t            this.state = node.state;\n\t            this.paramSchema = node.paramSchema.slice();\n\t            this.paramValues = common_1.extend({}, node.paramValues);\n\t            this.resolves = common_1.extend({}, node.resolves);\n\t            this.views = node.views && node.views.slice();\n\t            this.resolveContext = node.resolveContext;\n\t            this.resolveInjector = node.resolveInjector;\n\t        }\n\t        else {\n\t            this.state = state;\n\t            this.paramSchema = state.parameters({ inherit: false });\n\t            this.paramValues = {};\n\t            this.resolves = common_1.mapObj(state.resolve, function (fn, name) { return new module_1.Resolvable(name, fn); });\n\t        }\n\t    }\n\t    Node.prototype.applyRawParams = function (params) {\n\t        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n\t        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n\t        return this;\n\t    };\n\t    Node.prototype.parameter = function (name) {\n\t        return common_1.find(this.paramSchema, hof_1.propEq(\"id\", name));\n\t    };\n\t    Node.prototype.equals = function (node, keys) {\n\t        var _this = this;\n\t        if (keys === void 0) { keys = this.paramSchema.map(hof_1.prop('id')); }\n\t        var paramValsEq = function (key) { return _this.parameter(key).type.equals(_this.paramValues[key], node.paramValues[key]); };\n\t        return this.state === node.state && keys.map(paramValsEq).reduce(common_1.allTrueR, true);\n\t    };\n\t    Node.clone = function (node) {\n\t        return new Node(node);\n\t    };\n\t    /**\n\t     * Returns a new path which is a subpath of the first path. The new path starts from root and contains any nodes\n\t     * that match the nodes in the second path. Nodes are compared using their state property.\n\t     * @param first {Node[]}\n\t     * @param second {Node[]}\n\t     * @returns {Node[]}\n\t     */\n\t    Node.matching = function (first, second) {\n\t        var matchedCount = first.reduce(function (prev, node, i) {\n\t            return prev === i && i < second.length && node.state === second[i].state ? i + 1 : prev;\n\t        }, 0);\n\t        return first.slice(0, matchedCount);\n\t    };\n\t    return Node;\n\t}());\n\texports.Node = Node;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module resolve */ /** for typedoc */\n\t__export(__webpack_require__(31));\n\t__export(__webpack_require__(32));\n\t__export(__webpack_require__(41));\n\t__export(__webpack_require__(42));\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar trace_1 = __webpack_require__(12);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar interface_1 = __webpack_require__(31);\n\tvar common_2 = __webpack_require__(3);\n\tvar pathFactory_1 = __webpack_require__(38);\n\t// TODO: make this configurable\n\tvar defaultResolvePolicy = interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];\n\tvar ResolveContext = (function () {\n\t    function ResolveContext(_path) {\n\t        this._path = _path;\n\t        common_1.extend(this, {\n\t            _nodeFor: function (state) {\n\t                return common_1.find(this._path, hof_1.propEq('state', state));\n\t            },\n\t            _pathTo: function (state) {\n\t                return pathFactory_1.PathFactory.subPath(this._path, state);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Gets the available Resolvables for the last element of this path.\n\t     *\n\t     * @param state the State (within the ResolveContext's Path) for which to get resolvables\n\t     * @param options\n\t     *\n\t     * options.omitOwnLocals: array of property names\n\t     *   Omits those Resolvables which are found on the last element of the path.\n\t     *\n\t     *   This will hide a deepest-level resolvable (by name), potentially exposing a parent resolvable of\n\t     *   the same name further up the state tree.\n\t     *\n\t     *   This is used by Resolvable.resolve() in order to provide the Resolvable access to all the other\n\t     *   Resolvables at its own PathElement level, yet disallow that Resolvable access to its own injectable Resolvable.\n\t     *\n\t     *   This is also used to allow a state to override a parent state's resolve while also injecting\n\t     *   that parent state's resolve:\n\t     *\n\t     *   state({ name: 'G', resolve: { _G: function() { return \"G\"; } } });\n\t     *   state({ name: 'G.G2', resolve: { _G: function(_G) { return _G + \"G2\"; } } });\n\t     *   where injecting _G into a controller will yield \"GG2\"\n\t     */\n\t    ResolveContext.prototype.getResolvables = function (state, options) {\n\t        options = common_1.defaults(options, { omitOwnLocals: [] });\n\t        var path = (state ? this._pathTo(state) : this._path);\n\t        var last = common_1.tail(path);\n\t        return path.reduce(function (memo, node) {\n\t            var omitProps = (node === last) ? options.omitOwnLocals : [];\n\t            var filteredResolvables = common_1.omit(node.resolves, omitProps);\n\t            return common_1.extend(memo, filteredResolvables);\n\t        }, {});\n\t    };\n\t    /** Inspects a function `fn` for its dependencies.  Returns an object containing any matching Resolvables */\n\t    ResolveContext.prototype.getResolvablesForFn = function (fn) {\n\t        var deps = coreservices_1.services.$injector.annotate(fn, coreservices_1.services.$injector.strictDi);\n\t        return common_1.pick(this.getResolvables(), deps);\n\t    };\n\t    ResolveContext.prototype.isolateRootTo = function (state) {\n\t        return new ResolveContext(this._pathTo(state));\n\t    };\n\t    ResolveContext.prototype.addResolvables = function (resolvables, state) {\n\t        common_1.extend(this._nodeFor(state).resolves, resolvables);\n\t    };\n\t    /** Gets the resolvables declared on a particular state */\n\t    ResolveContext.prototype.getOwnResolvables = function (state) {\n\t        return common_1.extend({}, this._nodeFor(state).resolves);\n\t    };\n\t    // Returns a promise for an array of resolved path Element promises\n\t    ResolveContext.prototype.resolvePath = function (options) {\n\t        var _this = this;\n\t        if (options === void 0) { options = {}; }\n\t        trace_1.trace.traceResolvePath(this._path, options);\n\t        var promiseForNode = function (node) { return _this.resolvePathElement(node.state, options); };\n\t        return coreservices_1.services.$q.all(common_1.map(this._path, promiseForNode)).then(function (all) { return all.reduce(common_2.mergeR, {}); });\n\t    };\n\t    // returns a promise for all the resolvables on this PathElement\n\t    // options.resolvePolicy: only return promises for those Resolvables which are at \n\t    // the specified policy, or above.  i.e., options.resolvePolicy === 'lazy' will\n\t    // resolve both 'lazy' and 'eager' resolves.\n\t    ResolveContext.prototype.resolvePathElement = function (state, options) {\n\t        var _this = this;\n\t        if (options === void 0) { options = {}; }\n\t        // The caller can request the path be resolved for a given policy and \"below\" \n\t        var policy = options && options.resolvePolicy;\n\t        var policyOrdinal = interface_1.ResolvePolicy[policy || defaultResolvePolicy];\n\t        // Get path Resolvables available to this element\n\t        var resolvables = this.getOwnResolvables(state);\n\t        var matchesRequestedPolicy = function (resolvable) { return getPolicy(state.resolvePolicy, resolvable) >= policyOrdinal; };\n\t        var matchingResolves = common_1.filter(resolvables, matchesRequestedPolicy);\n\t        var getResolvePromise = function (resolvable) { return resolvable.get(_this.isolateRootTo(state), options); };\n\t        var resolvablePromises = common_1.map(matchingResolves, getResolvePromise);\n\t        trace_1.trace.traceResolvePathElement(this, matchingResolves, options);\n\t        return coreservices_1.services.$q.all(resolvablePromises);\n\t    };\n\t    /**\n\t     * Injects a function given the Resolvables available in the path, from the first node\n\t     * up to the node for the given state.\n\t     *\n\t     * First it resolves all the resolvable depencies.  When they are done resolving, it invokes\n\t     * the function.\n\t     *\n\t     * @return a promise for the return value of the function.\n\t     *\n\t     * @param fn: the function to inject (i.e., onEnter, onExit, controller)\n\t     * @param locals: are the angular $injector-style locals to inject\n\t     * @param options: options (TODO: document)\n\t     */\n\t    ResolveContext.prototype.invokeLater = function (fn, locals, options) {\n\t        var _this = this;\n\t        if (locals === void 0) { locals = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var resolvables = this.getResolvablesForFn(fn);\n\t        trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({ when: \"Later\" }, options));\n\t        var getPromise = function (resolvable) { return resolvable.get(_this, options); };\n\t        var promises = common_1.map(resolvables, getPromise);\n\t        return coreservices_1.services.$q.all(promises).then(function () {\n\t            try {\n\t                return _this.invokeNow(fn, locals, options);\n\t            }\n\t            catch (error) {\n\t                return coreservices_1.services.$q.reject(error);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Immediately injects a function with the dependent Resolvables available in the path, from\n\t     * the first node up to the node for the given state.\n\t     *\n\t     * If a Resolvable is not yet resolved, then null is injected in place of the resolvable.\n\t     *\n\t     * @return the return value of the function.\n\t     *\n\t     * @param fn: the function to inject (i.e., onEnter, onExit, controller)\n\t     * @param locals: are the angular $injector-style locals to inject\n\t     * @param options: options (TODO: document)\n\t     */\n\t    // Injects a function at this PathElement level with available Resolvables\n\t    // Does not wait until all Resolvables have been resolved; you must call PathElement.resolve() (or manually resolve each dep) first\n\t    ResolveContext.prototype.invokeNow = function (fn, locals, options) {\n\t        if (options === void 0) { options = {}; }\n\t        var resolvables = this.getResolvablesForFn(fn);\n\t        trace_1.trace.tracePathElementInvoke(common_1.tail(this._path), fn, Object.keys(resolvables), common_1.extend({ when: \"Now  \" }, options));\n\t        var resolvedLocals = common_1.map(resolvables, hof_1.prop(\"data\"));\n\t        return coreservices_1.services.$injector.invoke(fn, options.bind || null, common_1.extend({}, locals, resolvedLocals));\n\t    };\n\t    return ResolveContext;\n\t}());\n\texports.ResolveContext = ResolveContext;\n\t/**\n\t * Given a state's resolvePolicy attribute and a resolvable from that state, returns the policy ordinal for the Resolvable\n\t * Use the policy declared for the Resolve. If undefined, use the policy declared for the State.  If\n\t * undefined, use the system defaultResolvePolicy.\n\t *\n\t * @param stateResolvePolicyConf The raw resolvePolicy declaration on the state object; may be a String or Object\n\t * @param resolvable The resolvable to compute the policy for\n\t */\n\tfunction getPolicy(stateResolvePolicyConf, resolvable) {\n\t    // Normalize the configuration on the state to either state-level (a string) or resolve-level (a Map of string:string)\n\t    var stateLevelPolicy = (predicates_1.isString(stateResolvePolicyConf) ? stateResolvePolicyConf : null);\n\t    var resolveLevelPolicies = (predicates_1.isObject(stateResolvePolicyConf) ? stateResolvePolicyConf : {});\n\t    var policyName = resolveLevelPolicies[resolvable.name] || stateLevelPolicy || defaultResolvePolicy;\n\t    return interface_1.ResolvePolicy[policyName];\n\t}\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module resolve */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar ResolveInjector = (function () {\n\t    function ResolveInjector(_resolveContext, _state) {\n\t        this._resolveContext = _resolveContext;\n\t        this._state = _state;\n\t    }\n\t    /** Returns a promise to invoke an annotated function in the resolve context */\n\t    ResolveInjector.prototype.invokeLater = function (injectedFn, locals) {\n\t        return this._resolveContext.invokeLater(injectedFn, locals);\n\t    };\n\t    /** Invokes an annotated function in the resolve context */\n\t    ResolveInjector.prototype.invokeNow = function (injectedFn, locals) {\n\t        return this._resolveContext.invokeNow(null, injectedFn, locals);\n\t    };\n\t    /** Returns the a promise for locals (realized Resolvables) that a function wants */\n\t    ResolveInjector.prototype.getLocals = function (injectedFn) {\n\t        var _this = this;\n\t        var resolve = function (r) { return r.get(_this._resolveContext); };\n\t        return common_1.map(this._resolveContext.getResolvablesForFn(injectedFn), resolve);\n\t    };\n\t    return ResolveInjector;\n\t}());\n\texports.ResolveInjector = ResolveInjector;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar transition_1 = __webpack_require__(11);\n\tvar hookRegistry_1 = __webpack_require__(15);\n\t/**\n\t * The default transition options.\n\t * Include this object when applying custom defaults:\n\t * let reloadOpts = { reload: true, notify: true }\n\t * let options = defaults(theirOpts, customDefaults, defaultOptions);\n\t */\n\texports.defaultTransOpts = {\n\t    location: true,\n\t    relative: null,\n\t    inherit: false,\n\t    notify: true,\n\t    reload: false,\n\t    custom: {},\n\t    current: function () { return null; }\n\t};\n\t/**\n\t * This class provides services related to Transitions.\n\t *\n\t * Most importantly, it allows global Transition Hooks to be registered, and has a factory function\n\t * for creating new Transitions.\n\t */\n\tvar TransitionService = (function () {\n\t    function TransitionService($view) {\n\t        this.$view = $view;\n\t        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n\t            if ($error$ instanceof Error) {\n\t                console.error($error$);\n\t            }\n\t        };\n\t        hookRegistry_1.HookRegistry.mixin(new hookRegistry_1.HookRegistry(), this);\n\t    }\n\t    TransitionService.prototype.defaultErrorHandler = function (handler) {\n\t        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n\t    };\n\t    /**\n\t     * Creates a new [[Transition]] object\n\t     *\n\t     * This is a factory function for creating new Transition objects.\n\t     *\n\t     * @param fromPath\n\t     * @param targetState\n\t     * @returns {Transition}\n\t     */\n\t    TransitionService.prototype.create = function (fromPath, targetState) {\n\t        return new transition_1.Transition(fromPath, targetState, this);\n\t    };\n\t    return TransitionService;\n\t}());\n\texports.TransitionService = TransitionService;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module path */ /** for typedoc */\n\t__export(__webpack_require__(39));\n\t__export(__webpack_require__(38));\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module url */ /** for typedoc */\n\t__export(__webpack_require__(46));\n\t__export(__webpack_require__(22));\n\t__export(__webpack_require__(47));\n\t__export(__webpack_require__(48));\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module url */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(20);\n\tvar predicates_2 = __webpack_require__(4);\n\tvar param_1 = __webpack_require__(21);\n\tvar common_2 = __webpack_require__(3);\n\tvar common_3 = __webpack_require__(3);\n\tfunction quoteRegExp(string, param) {\n\t    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!param)\n\t        return result;\n\t    switch (param.squash) {\n\t        case false:\n\t            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n\t            break;\n\t        case true:\n\t            result = result.replace(/\\/$/, '');\n\t            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t            break;\n\t        default:\n\t            surroundPattern = [(\"(\" + param.squash + \"|\"), ')?'];\n\t            break;\n\t    }\n\t    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n\t}\n\tvar memoizeTo = function (obj, prop, fn) { return obj[prop] = obj[prop] || fn(); };\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} pattern  The pattern that was passed into the constructor\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tvar UrlMatcher = (function () {\n\t    function UrlMatcher(pattern, config) {\n\t        var _this = this;\n\t        this.pattern = pattern;\n\t        this.config = config;\n\t        this._cache = { path: [], pattern: null };\n\t        this._children = [];\n\t        this._params = [];\n\t        this._segments = [];\n\t        this._compiled = [];\n\t        this.config = common_1.defaults(this.config, {\n\t            params: {},\n\t            strict: true,\n\t            caseInsensitive: false,\n\t            paramMap: common_1.identity\n\t        });\n\t        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t        //   '*' name\n\t        //   ':' name\n\t        //   '{' name '}'\n\t        //   '{' name ':' regexp '}'\n\t        // The regular expression is somewhat complicated due to the need to allow curly braces\n\t        // inside the regular expression. The placeholder regexp breaks down as follows:\n\t        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t        //    \\\\.                            - a backslash escape\n\t        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n\t        var checkParamErrors = function (id) {\n\t            if (!UrlMatcher.nameValidator.test(id))\n\t                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n\t                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t        };\n\t        // Split into static segments separated by path parameter placeholders.\n\t        // The number of segments is always 1 more than the number of parameters.\n\t        var matchDetails = function (m, isSearch) {\n\t            // IE[78] returns '' for unmatched groups instead of null\n\t            var id = m[2] || m[3], regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);\n\t            return {\n\t                id: id,\n\t                regexp: regexp,\n\t                cfg: _this.config.params[id],\n\t                segment: pattern.substring(last, m.index),\n\t                type: !regexp ? null : module_1.paramTypes.type(regexp || \"string\") || common_1.inherit(module_1.paramTypes.type(\"string\"), {\n\t                    pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n\t                })\n\t            };\n\t        };\n\t        var p, segment;\n\t        while ((m = placeholder.exec(pattern))) {\n\t            p = matchDetails(m, false);\n\t            if (p.segment.indexOf('?') >= 0)\n\t                break; // we're into the search part\n\t            checkParamErrors(p.id);\n\t            this._params.push(module_1.Param.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n\t            this._segments.push(p.segment);\n\t            patterns.push([p.segment, common_1.tail(this._params)]);\n\t            last = placeholder.lastIndex;\n\t        }\n\t        segment = pattern.substring(last);\n\t        // Find any search parameter names and remove them from the last segment\n\t        var i = segment.indexOf('?');\n\t        if (i >= 0) {\n\t            var search = segment.substring(i);\n\t            segment = segment.substring(0, i);\n\t            if (search.length > 0) {\n\t                last = 0;\n\t                while ((m = searchPlaceholder.exec(search))) {\n\t                    p = matchDetails(m, true);\n\t                    checkParamErrors(p.id);\n\t                    this._params.push(module_1.Param.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n\t                    last = placeholder.lastIndex;\n\t                }\n\t            }\n\t        }\n\t        this._segments.push(segment);\n\t        common_1.extend(this, {\n\t            _compiled: patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment)),\n\t            prefix: this._segments[0]\n\t        });\n\t        Object.freeze(this);\n\t    }\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.util.type:UrlMatcher#append\n\t     * @methodOf ui.router.util.type:UrlMatcher\n\t     *\n\t     * @description\n\t     * @TODO\n\t     *\n\t     * @example\n\t     * @TODO\n\t     *\n\t     * @param {UrlMatcher} url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n\t     */\n\t    UrlMatcher.prototype.append = function (url) {\n\t        this._children.push(url);\n\t        common_1.forEach(url._cache, function (val, key) { return url._cache[key] = predicates_1.isArray(val) ? [] : null; });\n\t        url._cache.path = this._cache.path.concat(this);\n\t        return url;\n\t    };\n\t    UrlMatcher.prototype.isRoot = function () {\n\t        return this._cache.path.length === 0;\n\t    };\n\t    UrlMatcher.prototype.toString = function () {\n\t        return this.pattern;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.util.type:UrlMatcher#exec\n\t     * @methodOf ui.router.util.type:UrlMatcher\n\t     *\n\t     * @description\n\t     * Tests the specified path against this matcher, and returns an object containing the captured\n\t     * parameter values, or null if the path does not match. The returned object contains the values\n\t     * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t     * they are not present in `search`. This means that search parameters are always treated\n\t     * as optional.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t     *   x: '1', q: 'hello'\n\t     * });\n\t     * // returns { id: 'bob', q: 'hello', r: null }\n\t     * </pre>\n\t     *\n\t     * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t     * @param {Object} search  URL search parameters, e.g. `$location.search()`.\n\t     * @param {string} hash  URL hash e.g. `$location.hash()`.\n\t     * @param {Object} options\n\t     * @returns {Object}  The captured parameter values.\n\t     */\n\t    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n\t        var _this = this;\n\t        if (search === void 0) { search = {}; }\n\t        if (options === void 0) { options = {}; }\n\t        var match = memoizeTo(this._cache, 'pattern', function () {\n\t            return new RegExp([\n\t                '^',\n\t                common_1.unnest(_this._cache.path.concat(_this).map(hof_1.prop('_compiled'))).join(''),\n\t                _this.config.strict === false ? '\\/?' : '',\n\t                '$'\n\t            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n\t        }).exec(path);\n\t        if (!match)\n\t            return null;\n\t        //options = defaults(options, { isolate: false });\n\t        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.concat(this).map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n\t        if (nPathSegments !== match.length - 1)\n\t            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n\t        function decodePathArray(string) {\n\t            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n\t            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n\t            var split = reverseString(string).split(/-(?!\\\\)/);\n\t            var allReversed = common_1.map(split, reverseString);\n\t            return common_1.map(allReversed, unquoteDashes).reverse();\n\t        }\n\t        for (var i = 0; i < nPathSegments; i++) {\n\t            var param = pathParams[i];\n\t            var value = match[i + 1];\n\t            // if the param value matches a pre-replace pair, replace the value before decoding.\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (value && param.array === true)\n\t                value = decodePathArray(value);\n\t            if (predicates_2.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        }\n\t        common_1.forEach(searchParams, function (param) {\n\t            var value = search[param.id];\n\t            for (var j = 0; j < param.replace.length; j++) {\n\t                if (param.replace[j].from === value)\n\t                    value = param.replace[j].to;\n\t            }\n\t            if (predicates_2.isDefined(value))\n\t                value = param.type.decode(value);\n\t            values[param.id] = param.value(value);\n\t        });\n\t        if (hash)\n\t            values[\"#\"] = hash;\n\t        return values;\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.util.type:UrlMatcher#parameters\n\t     * @methodOf ui.router.util.type:UrlMatcher\n\t     *\n\t     * @description\n\t     * Returns the names of all path and search parameters of this pattern in order of appearance.\n\t     *\n\t     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n\t     *    pattern has no parameters, an empty array is returned.\n\t     */\n\t    UrlMatcher.prototype.parameters = function (opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        if (opts.inherit === false)\n\t            return this._params;\n\t        return common_1.unnest(this._cache.path.concat(this).map(hof_1.prop('_params')));\n\t    };\n\t    UrlMatcher.prototype.parameter = function (id, opts) {\n\t        if (opts === void 0) { opts = {}; }\n\t        var parent = common_1.tail(this._cache.path);\n\t        return (common_1.find(this._params, hof_1.propEq('id', id)) ||\n\t            (opts.inherit !== false && parent && parent.parameter(id)) ||\n\t            null);\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.util.type:UrlMatcher#validates\n\t     * @methodOf ui.router.util.type:UrlMatcher\n\t     *\n\t     * @description\n\t     * Checks an object hash of parameters to validate their correctness according to the parameter\n\t     * types of this `UrlMatcher`.\n\t     *\n\t     * @param {Object} params The object hash of parameters to validate.\n\t     * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t     */\n\t    UrlMatcher.prototype.validates = function (params) {\n\t        var _this = this;\n\t        var validParamVal = function (param, val) { return !param || param.validates(val); };\n\t        return common_1.pairs(params || {}).map(function (_a) {\n\t            var key = _a[0], val = _a[1];\n\t            return validParamVal(_this.parameter(key), val);\n\t        }).reduce(common_1.allTrueR, true);\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.util.type:UrlMatcher#format\n\t     * @methodOf ui.router.util.type:UrlMatcher\n\t     *\n\t     * @description\n\t     * Creates a URL that matches this pattern by substituting the specified values\n\t     * for the path and search parameters. Null values for path parameters are\n\t     * treated as empty strings.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t     * // returns '/user/bob?q=yes'\n\t     * </pre>\n\t     *\n\t     * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t     * @returns {string}  the formatted URL (path and optionally search part).\n\t     */\n\t    UrlMatcher.prototype.format = function (values) {\n\t        if (values === void 0) { values = {}; }\n\t        if (!this.validates(values))\n\t            return null;\n\t        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n\t        var urlMatchers = this._cache.path.slice().concat(this);\n\t        // Extract all the static segments and Params into an ordered array\n\t        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_2.unnestR, []);\n\t        // Extract the query params into a separate array\n\t        var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_2.unnestR, []);\n\t        /**\n\t         * Given a Param,\n\t         * Applies the parameter value, then returns details about it\n\t         */\n\t        function getDetails(param) {\n\t            // Normalize to typed value\n\t            var value = param.value(values[param.id]);\n\t            var isDefaultValue = param.isDefaultValue(value);\n\t            // Check if we're in squash mode for the parameter\n\t            var squash = isDefaultValue ? param.squash : false;\n\t            // Allow the Parameter's Type to encode the value\n\t            var encoded = param.type.encode(value);\n\t            return { param: param, value: value, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n\t        }\n\t        // Build up the path-portion from the list of static segments and parameters\n\t        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n\t            // The element is a static segment (a raw string); just append it\n\t            if (predicates_1.isString(x))\n\t                return acc + x;\n\t            // Otherwise, it's a Param.  Fetch details about the parameter value\n\t            var _a = getDetails(x), squash = _a.squash, encoded = _a.encoded, param = _a.param;\n\t            // If squash is === true, try to remove a slash from the path\n\t            if (squash === true)\n\t                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n\t            // If squash is a string, use the string for the param value\n\t            if (predicates_1.isString(squash))\n\t                return acc + squash;\n\t            if (squash !== false)\n\t                return acc; // ?\n\t            if (encoded == null)\n\t                return acc;\n\t            // If this parameter value is an array, encode the value using encodeDashes\n\t            if (predicates_1.isArray(encoded))\n\t                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n\t            // If the parameter type is \"raw\", then do not encodeURIComponent\n\t            if (param.type.raw)\n\t                return acc + encoded;\n\t            // Encode the value\n\t            return acc + encodeURIComponent(encoded);\n\t        }, \"\");\n\t        // Build the query string by applying parameter values (array or regular)\n\t        // then mapping to key=value, then flattening and joining using \"&\"\n\t        var queryString = queryParams.map(function (param) {\n\t            var _a = getDetails(param), squash = _a.squash, encoded = _a.encoded, isDefaultValue = _a.isDefaultValue;\n\t            if (encoded == null || (isDefaultValue && squash !== false))\n\t                return;\n\t            if (!predicates_1.isArray(encoded))\n\t                encoded = [encoded];\n\t            if (encoded.length === 0)\n\t                return;\n\t            if (!param.type.raw)\n\t                encoded = common_1.map(encoded, encodeURIComponent);\n\t            return encoded.map(function (val) { return (param.id + \"=\" + val); });\n\t        }).filter(common_1.identity).reduce(common_2.unnestR, []).join(\"&\");\n\t        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n\t        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n\t    };\n\t    UrlMatcher.encodeDashes = function (str) {\n\t        return encodeURIComponent(str).replace(/-/g, function (c) { return (\"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase()); });\n\t    };\n\t    /** Given a matcher, return an array with the matcher's path segments and path params, in order */\n\t    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n\t        var staticSegments = matcher._segments;\n\t        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n\t        return common_3.arrayTuples(staticSegments, pathParams.concat(undefined)).reduce(common_2.unnestR, []).filter(function (x) { return x !== \"\" && predicates_2.isDefined(x); });\n\t    };\n\t    /** Given a matcher, return an array with the matcher's query params */\n\t    UrlMatcher.queryParams = function (matcher) {\n\t        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n\t    };\n\t    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\t    return UrlMatcher;\n\t}());\n\texports.UrlMatcher = UrlMatcher;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module url */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(45);\n\tvar module_2 = __webpack_require__(20);\n\tfunction getDefaultConfig() {\n\t    return {\n\t        strict: module_1.matcherConfig.strictMode(),\n\t        caseInsensitive: module_1.matcherConfig.caseInsensitive()\n\t    };\n\t}\n\t/**\n\t * Factory for [[UrlMatcher]] instances.\n\t *\n\t * The factory is available to ng1 services as\n\t * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.\n\t */\n\tvar UrlMatcherFactory = (function () {\n\t    function UrlMatcherFactory() {\n\t        common_1.extend(this, { UrlMatcher: module_1.UrlMatcher, Param: module_2.Param });\n\t    }\n\t    /**\n\t     * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t     *\n\t     * @param value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t     * @returns the current value of caseInsensitive\n\t     */\n\t    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n\t        return module_1.matcherConfig.caseInsensitive(value);\n\t    };\n\t    /**\n\t     * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t     *\n\t     * @param value `false` to match trailing slashes in URLs, otherwise `true`.\n\t     * @returns the current value of strictMode\n\t     */\n\t    UrlMatcherFactory.prototype.strictMode = function (value) {\n\t        return module_1.matcherConfig.strictMode(value);\n\t    };\n\t    /**\n\t     * Sets the default behavior when generating or matching URLs with default parameter values.\n\t     *\n\t     * @param value A string that defines the default parameter URL squashing behavior.\n\t     *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t     *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t     *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t     *    - any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t     *             the parameter value from the URL and replace it with this string.\n\t     * @returns the current value of defaultSquashPolicy\n\t     */\n\t    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n\t        return module_1.matcherConfig.defaultSquashPolicy(value);\n\t    };\n\t    /**\n\t     * Creates a [[UrlMatcher]] for the specified pattern.\n\t     *\n\t     * @param pattern  The URL pattern.\n\t     * @param config  The config object hash.\n\t     * @returns The UrlMatcher.\n\t     */\n\t    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n\t        return new module_1.UrlMatcher(pattern, common_1.extend(getDefaultConfig(), config));\n\t    };\n\t    /**\n\t     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n\t     *\n\t     * @param object  The object to perform the type check against.\n\t     * @returns `true` if the object matches the `UrlMatcher` interface, by\n\t     *          implementing all the same methods.\n\t     */\n\t    UrlMatcherFactory.prototype.isMatcher = function (object) {\n\t        // TODO: typeof?\n\t        if (!predicates_1.isObject(object))\n\t            return false;\n\t        var result = true;\n\t        common_1.forEach(module_1.UrlMatcher.prototype, function (val, name) {\n\t            if (predicates_1.isFunction(val))\n\t                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n\t        });\n\t        return result;\n\t    };\n\t    ;\n\t    /**\n\t     * Registers a custom [[Type]] object that can be used to generate URLs with typed parameters.\n\t     *\n\t     * @param name  The type name.\n\t     * @param definition The type definition. See [[Type]] for information on the values accepted.\n\t     * @param definitionFn A function that is injected before the app\n\t     *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t     *        See [[Type]] for information on the values accepted.\n\t     *\n\t     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n\t     *   - if only the `name` parameter was specified: the currently registered [[Type]] object, or undefined\n\t     *\n\t     * ---\n\t     *\n\t     * This is a simple example of a custom type that encodes and decodes items from an\n\t     * array, using the array index as the URL-encoded value:\n\t     *\n\t     * @example\n\t     * ```\n\t     *\n\t     * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t     *\n\t     * $urlMatcherFactoryProvider.type('listItem', {\n\t     *   encode: function(item) {\n\t     *     // Represent the list item in the URL using its corresponding index\n\t     *     return list.indexOf(item);\n\t     *   },\n\t     *   decode: function(item) {\n\t     *     // Look up the list item by index\n\t     *     return list[parseInt(item, 10)];\n\t     *   },\n\t     *   is: function(item) {\n\t     *     // Ensure the item is valid by checking to see that it appears\n\t     *     // in the list\n\t     *     return list.indexOf(item) > -1;\n\t     *   }\n\t     * });\n\t     *\n\t     * $stateProvider.state('list', {\n\t     *   url: \"/list/{item:listItem}\",\n\t     *   controller: function($scope, $stateParams) {\n\t     *     console.log($stateParams.item);\n\t     *   }\n\t     * });\n\t     *\n\t     * // ...\n\t     *\n\t     * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t     * $state.go('list', { item: \"Ringo\" });\n\t     * ```\n\t     */\n\t    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n\t        var type = module_2.paramTypes.type(name, definition, definitionFn);\n\t        return !predicates_1.isDefined(definition) ? type : this;\n\t    };\n\t    ;\n\t    /** @hidden */\n\t    UrlMatcherFactory.prototype.$get = function () {\n\t        module_2.paramTypes.enqueue = false;\n\t        module_2.paramTypes._flushTypeQueue();\n\t        return this;\n\t    };\n\t    ;\n\t    return UrlMatcherFactory;\n\t}());\n\texports.UrlMatcherFactory = UrlMatcherFactory;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module url */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar $location = coreservices_1.services.location;\n\t// Returns a string that is a prefix of all strings matching the RegExp\n\tfunction regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t}\n\t// Interpolates matched values into a String.replace()-style pattern\n\tfunction interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t        return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t}\n\tfunction handleIfMatch($injector, $stateParams, handler, match) {\n\t    if (!match)\n\t        return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match, $stateParams: $stateParams });\n\t    return predicates_1.isDefined(result) ? result : true;\n\t}\n\tfunction appendBasePath(url, isHtml5, absolute) {\n\t    var baseHref = coreservices_1.services.locationConfig.baseHref();\n\t    if (baseHref === '/')\n\t        return url;\n\t    if (isHtml5)\n\t        return baseHref.slice(0, -1) + url;\n\t    if (absolute)\n\t        return baseHref.slice(1) + url;\n\t    return url;\n\t}\n\t// TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\tfunction update(rules, otherwiseFn, evt) {\n\t    if (evt && evt.defaultPrevented)\n\t        return;\n\t    function check(rule) {\n\t        var handled = rule(coreservices_1.services.$injector, $location);\n\t        if (!handled)\n\t            return false;\n\t        if (predicates_1.isString(handled)) {\n\t            $location.replace();\n\t            $location.url(handled);\n\t        }\n\t        return true;\n\t    }\n\t    var n = rules.length, i;\n\t    for (i = 0; i < n; i++) {\n\t        if (check(rules[i]))\n\t            return;\n\t    }\n\t    // always check otherwise last to allow dynamic updates to the set of rules\n\t    if (otherwiseFn)\n\t        check(otherwiseFn);\n\t}\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`.\n\t * When `$location` changes it runs through a list of rules one by one until a\n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify\n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\tvar UrlRouterProvider = (function () {\n\t    function UrlRouterProvider($urlMatcherFactory, $stateParams) {\n\t        this.$urlMatcherFactory = $urlMatcherFactory;\n\t        this.$stateParams = $stateParams;\n\t        /** @hidden */\n\t        this.rules = [];\n\t        /** @hidden */\n\t        this.otherwiseFn = null;\n\t        /** @hidden */\n\t        this.interceptDeferred = false;\n\t    }\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.router.$urlRouterProvider#rule\n\t     * @methodOf ui.router.router.$urlRouterProvider\n\t     *\n\t     * @description\n\t     * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t     * specific URLs.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   // Here's an example of how you might allow case insensitive urls\n\t     *   $urlRouterProvider.rule(function ($injector, $location) {\n\t     *     var path = $location.path(),\n\t     *         normalized = path.toLowerCase();\n\t     *\n\t     *     if (path !== normalized) {\n\t     *       return normalized;\n\t     *     }\n\t     *   });\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {function} rule Handler function that takes `$injector` and `$location`\n\t     * services as arguments. You can use them to return a valid path as a string.\n\t     *\n\t     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t     */\n\t    UrlRouterProvider.prototype.rule = function (rule) {\n\t        if (!predicates_1.isFunction(rule))\n\t            throw new Error(\"'rule' must be a function\");\n\t        this.rules.push(rule);\n\t        return this;\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc object\n\t     * @name ui.router.router.$urlRouterProvider#otherwise\n\t     * @methodOf ui.router.router.$urlRouterProvider\n\t     *\n\t     * @description\n\t     * Defines a path that is used when an invalid route is requested.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   // if the path doesn't match any of the urls you configured\n\t     *   // otherwise will take care of routing the user to the\n\t     *   // specified url\n\t     *   $urlRouterProvider.otherwise('/index');\n\t     *\n\t     *   // Example of using function rule as param\n\t     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t     *     return '/a/valid/url';\n\t     *   });\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string|function} rule The url path you want to redirect to or a function\n\t     * rule that returns the url path. The function version is passed two params:\n\t     * `$injector` and `$location` services, and must return a url string.\n\t     *\n\t     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t     */\n\t    UrlRouterProvider.prototype.otherwise = function (rule) {\n\t        if (!predicates_1.isFunction(rule) && !predicates_1.isString(rule))\n\t            throw new Error(\"'rule' must be a string or function\");\n\t        this.otherwiseFn = predicates_1.isString(rule) ? function () { return rule; } : rule;\n\t        return this;\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.router.$urlRouterProvider#when\n\t     * @methodOf ui.router.router.$urlRouterProvider\n\t     *\n\t     * @description\n\t     * Registers a handler for a given url matching.\n\t     *\n\t     * If the handler is a string, it is\n\t     * treated as a redirect, and is interpolated according to the syntax of match\n\t     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t     *\n\t     * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t     * matches. You have the option of inject the match object as `$match`.\n\t     *\n\t     * The handler can return\n\t     *\n\t     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t     *   will continue trying to find another one that matches.\n\t     * - **string** which is treated as a redirect and passed to `$location.url()`\n\t     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t     *     if ($state.$current.navigable !== state ||\n\t     *         !equalForKeys($match, $stateParams) {\n\t     *      $state.transitionTo(state, $match, false);\n\t     *     }\n\t     *   });\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string|object} what The incoming path that you want to redirect.\n\t     * @param {string|function} handler The path you want to redirect your user to.\n\t     */\n\t    UrlRouterProvider.prototype.when = function (what, handler) {\n\t        var _a = this, $urlMatcherFactory = _a.$urlMatcherFactory, $stateParams = _a.$stateParams;\n\t        var redirect, handlerIsString = predicates_1.isString(handler);\n\t        // @todo Queue this\n\t        if (predicates_1.isString(what))\n\t            what = $urlMatcherFactory.compile(what);\n\t        if (!handlerIsString && !predicates_1.isFunction(handler) && !predicates_1.isArray(handler))\n\t            throw new Error(\"invalid 'handler' in when()\");\n\t        var strategies = {\n\t            matcher: function (_what, _handler) {\n\t                if (handlerIsString) {\n\t                    redirect = $urlMatcherFactory.compile(_handler);\n\t                    _handler = ['$match', redirect.format.bind(redirect)];\n\t                }\n\t                return common_1.extend(function () {\n\t                    return handleIfMatch(coreservices_1.services.$injector, $stateParams, _handler, _what.exec($location.path(), $location.search(), $location.hash()));\n\t                }, {\n\t                    prefix: predicates_1.isString(_what.prefix) ? _what.prefix : ''\n\t                });\n\t            },\n\t            regex: function (_what, _handler) {\n\t                if (_what.global || _what.sticky)\n\t                    throw new Error(\"when() RegExp must not be global or sticky\");\n\t                if (handlerIsString) {\n\t                    redirect = _handler;\n\t                    _handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t                }\n\t                return common_1.extend(function () {\n\t                    return handleIfMatch(coreservices_1.services.$injector, $stateParams, _handler, _what.exec($location.path()));\n\t                }, {\n\t                    prefix: regExpPrefix(_what)\n\t                });\n\t            }\n\t        };\n\t        var check = {\n\t            matcher: $urlMatcherFactory.isMatcher(what),\n\t            regex: what instanceof RegExp\n\t        };\n\t        for (var n in check) {\n\t            if (check[n])\n\t                return this.rule(strategies[n](what, handler));\n\t        }\n\t        throw new Error(\"invalid 'what' in when()\");\n\t    };\n\t    ;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t     * @methodOf ui.router.router.$urlRouterProvider\n\t     *\n\t     * @description\n\t     * Disables (or enables) deferring location change interception.\n\t     *\n\t     * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t     * defer a transition but maintain the current URL), call this method at configuration time.\n\t     * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t     * `$locationChangeSuccess` event handler.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router.router']);\n\t     *\n\t     * app.config(function ($urlRouterProvider) {\n\t     *\n\t     *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t     *   // this allows you to configure custom behavior in between\n\t     *   // location changes and route synchronization:\n\t     *   $urlRouterProvider.deferIntercept();\n\t     *\n\t     * }).run(function ($rootScope, $urlRouter, UserService) {\n\t     *\n\t     *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t     *     // UserService is an example service for managing user state\n\t     *     if (UserService.isLoggedIn()) return;\n\t     *\n\t     *     // Prevent $urlRouter's default handler from firing\n\t     *     e.preventDefault();\n\t     *\n\t     *     UserService.handleLogin().then(function() {\n\t     *       // Once the user has logged in, sync the current URL\n\t     *       // to the router:\n\t     *       $urlRouter.sync();\n\t     *     });\n\t     *   });\n\t     *\n\t     *   // Configures $urlRouter's listener *after* your custom listener\n\t     *   $urlRouter.listen();\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t     *        no parameter is equivalent to `true`.\n\t     */\n\t    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n\t        if (defer === undefined)\n\t            defer = true;\n\t        this.interceptDeferred = defer;\n\t    };\n\t    ;\n\t    return UrlRouterProvider;\n\t}());\n\texports.UrlRouterProvider = UrlRouterProvider;\n\tvar UrlRouter = (function () {\n\t    function UrlRouter(urlRouterProvider) {\n\t        this.urlRouterProvider = urlRouterProvider;\n\t        common_1.bindFunctions(UrlRouter.prototype, this, this);\n\t    }\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.router.$urlRouter#sync\n\t     * @methodOf ui.router.router.$urlRouter\n\t     *\n\t     * @description\n\t     * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t     * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t     * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t     * with the transition by calling `$urlRouter.sync()`.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * angular.module('app', ['ui.router'])\n\t     *   .run(function($rootScope, $urlRouter) {\n\t     *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t     *       // Halt state change from even starting\n\t     *       evt.preventDefault();\n\t     *       // Perform custom logic\n\t     *       var meetsRequirement = ...\n\t     *       // Continue with the update and state transition if logic allows\n\t     *       if (meetsRequirement) $urlRouter.sync();\n\t     *     });\n\t     * });\n\t     * </pre>\n\t     */\n\t    UrlRouter.prototype.sync = function () {\n\t        update(this.urlRouterProvider.rules, this.urlRouterProvider.otherwiseFn);\n\t    };\n\t    UrlRouter.prototype.listen = function () {\n\t        var _this = this;\n\t        return this.listener = this.listener || $location.onChange(function (evt) { return update(_this.urlRouterProvider.rules, _this.urlRouterProvider.otherwiseFn, evt); });\n\t    };\n\t    UrlRouter.prototype.update = function (read) {\n\t        if (read) {\n\t            this.location = $location.url();\n\t            return;\n\t        }\n\t        if ($location.url() === this.location)\n\t            return;\n\t        $location.url(this.location);\n\t        $location.replace();\n\t    };\n\t    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n\t        $location.url(urlMatcher.format(params || {}));\n\t        if (options && options.replace)\n\t            $location.replace();\n\t    };\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.router.$urlRouter#href\n\t     * @methodOf ui.router.router.$urlRouter\n\t     *\n\t     * @description\n\t     * A URL generation method that returns the compiled URL for a given\n\t     * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t     *   person: \"bob\"\n\t     * });\n\t     * // $bob == \"/about/bob\";\n\t     * </pre>\n\t     *\n\t     * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t     * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     *\n\t     * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t     */\n\t    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params))\n\t            return null;\n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t        var cfg = coreservices_1.services.locationConfig;\n\t        var isHtml5 = cfg.html5Mode();\n\t        if (!isHtml5 && url !== null) {\n\t            url = \"#\" + cfg.hashPrefix() + url;\n\t        }\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t        if (!options.absolute || !url) {\n\t            return url;\n\t        }\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n\t    };\n\t    return UrlRouter;\n\t}());\n\texports.UrlRouter = UrlRouter;\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t/** @module view */ /** for typedoc */\n\t__export(__webpack_require__(50));\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module view */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(2);\n\tvar match = function (obj1) {\n\t    var keys = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        keys[_i - 1] = arguments[_i];\n\t    }\n\t    return function (obj2) { return keys.reduce(function (memo, key) { return memo && obj1[key] === obj2[key]; }, true); };\n\t};\n\t/**\n\t * The View service\n\t */\n\tvar ViewService = (function () {\n\t    function ViewService() {\n\t        var _this = this;\n\t        this.uiViews = [];\n\t        this.viewConfigs = [];\n\t        this._viewConfigFactories = {};\n\t        this.sync = function () {\n\t            var uiViewsByFqn = _this.uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n\t            /**\n\t             * Given a ui-view and a ViewConfig, determines if they \"match\".\n\t             *\n\t             * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n\t             * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n\t             *\n\t             * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n\t             * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n\t             *\n\t             * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type\n\t             *\n\t             * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:\n\t             * - the ui-view's name matches the ViewConfig's target name\n\t             * - the ui-view's context matches the ViewConfig's anchor\n\t             *\n\t             * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:\n\t             * - There exists a parent ui-view where:\n\t             *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name\n\t             *    - the parent ui-view's context matches the ViewConfig's anchor\n\t             * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn\n\t             *\n\t             * Example:\n\t             *\n\t             * DOM:\n\t             * <div ui-view>                        <!-- created in the root context (name: \"\") -->\n\t             *   <div ui-view=\"foo\">                <!-- created in the context named: \"A\"      -->\n\t             *     <div ui-view>                    <!-- created in the context named: \"A.B\"    -->\n\t             *       <div ui-view=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n\t             *       </div>\n\t             *     </div>\n\t             *   </div>\n\t             * </div>\n\t             *\n\t             * uiViews: [\n\t             *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n\t             *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n\t             *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n\t             *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n\t             * ]\n\t             *\n\t             * These four view configs all match the ui-view with the fqn: \"$default.foo.$default.bar\":\n\t             *\n\t             * - ViewConfig1: { uiViewName: \"bar\",                       uiViewContextAnchor: \"A.B.C\" }\n\t             * - ViewConfig2: { uiViewName: \"$default.bar\",              uiViewContextAnchor: \"A.B\" }\n\t             * - ViewConfig3: { uiViewName: \"foo.$default.bar\",          uiViewContextAnchor: \"A\" }\n\t             * - ViewConfig4: { uiViewName: \"$default.foo.$default.bar\", uiViewContextAnchor: \"\" }\n\t             *\n\t             * Using ViewConfig3 as an example, it matches the ui-view with fqn \"$default.foo.$default.bar\" because:\n\t             * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n\t             * - There exists a parent ui-view (which has fqn: \"$default.foo\") where:\n\t             *    - the parent ui-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n\t             *    - the parent ui-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n\t             * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n\t             *   the tail of the ui-view's fqn \"default.bar\"\n\t             */\n\t            var matches = function (uiView) { return function (viewConfig) {\n\t                // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc\n\t                if (uiView.$type !== viewConfig.viewDecl.$type)\n\t                    return false;\n\t                // Split names apart from both viewConfig and uiView into segments\n\t                var vc = viewConfig.viewDecl;\n\t                var vcSegments = vc.$uiViewName.split(\".\");\n\t                var uivSegments = uiView.fqn.split(\".\");\n\t                // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n\t                // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n\t                if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n\t                    return false;\n\t                // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n\t                // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ui-view $default.foo context match?\n\t                var negOffset = (1 - vcSegments.length) || undefined;\n\t                var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\t                var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n\t                return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n\t            }; };\n\t            // Return the number of dots in the fully qualified name\n\t            function uiViewDepth(uiView) {\n\t                return uiView.fqn.split(\".\").length;\n\t            }\n\t            // Return the ViewConfig's context's depth in the context tree.\n\t            function viewConfigDepth(config) {\n\t                var context = config.viewDecl.$context, count = 0;\n\t                while (++count && context.parent)\n\t                    context = context.parent;\n\t                return count;\n\t            }\n\t            // Given a depth function, returns a compare function which can return either ascending or descending order\n\t            var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n\t            var matchingConfigPair = function (uiView) {\n\t                var matchingConfigs = _this.viewConfigs.filter(matches(uiView));\n\t                if (matchingConfigs.length > 1)\n\t                    matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n\t                return [uiView, matchingConfigs[0]];\n\t            };\n\t            var configureUiView = function (_a) {\n\t                var uiView = _a[0], viewConfig = _a[1];\n\t                // If a parent ui-view is reconfigured, it could destroy child ui-views.\n\t                // Before configuring a child ui-view, make sure it's still in the active uiViews array.\n\t                if (_this.uiViews.indexOf(uiView) !== -1)\n\t                    uiView.configUpdated(viewConfig);\n\t            };\n\t            _this.uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUiView);\n\t        };\n\t    }\n\t    ViewService.prototype.rootContext = function (context) {\n\t        return this._rootContext = context || this._rootContext;\n\t    };\n\t    ;\n\t    ViewService.prototype.viewConfigFactory = function (viewType, factory) {\n\t        this._viewConfigFactories[viewType] = factory;\n\t    };\n\t    ViewService.prototype.createViewConfig = function (node, decl) {\n\t        var cfgFactory = this._viewConfigFactories[decl.$type];\n\t        if (!cfgFactory)\n\t            throw new Error(\"ViewService: No view config factory registered for type \" + decl.$type);\n\t        var cfgs = cfgFactory(node, decl);\n\t        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n\t    };\n\t    /**\n\t     * De-registers a ViewConfig.\n\t     *\n\t     * @param viewConfig The ViewConfig view to deregister.\n\t     */\n\t    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n\t        module_1.trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n\t        common_1.removeFrom(this.viewConfigs, viewConfig);\n\t    };\n\t    ;\n\t    ViewService.prototype.activateViewConfig = function (viewConfig) {\n\t        module_1.trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n\t        this.viewConfigs.push(viewConfig);\n\t    };\n\t    ;\n\t    /**\n\t     * Allows a `ui-view` element to register its canonical name with a callback that allows it to\n\t     * be updated with a template, controller, and local variables.\n\t     *\n\t     * @param {String} name The fully-qualified name of the `ui-view` object being registered.\n\t     * @param {Function} configUpdatedCallback A callback that receives updates to the content & configuration\n\t     *                   of the view.\n\t     * @return {Function} Returns a de-registration function used when the view is destroyed.\n\t     */\n\t    ViewService.prototype.registerUiView = function (uiView) {\n\t        module_1.trace.traceViewServiceUiViewEvent(\"-> Registering\", uiView);\n\t        var uiViews = this.uiViews;\n\t        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };\n\t        if (uiViews.filter(fqnMatches).length)\n\t            module_1.trace.traceViewServiceUiViewEvent(\"!!!! duplicate uiView named:\", uiView);\n\t        uiViews.push(uiView);\n\t        this.sync();\n\t        return function () {\n\t            var idx = uiViews.indexOf(uiView);\n\t            if (idx <= 0) {\n\t                module_1.trace.traceViewServiceUiViewEvent(\"Tried removing non-registered uiView\", uiView);\n\t                return;\n\t            }\n\t            module_1.trace.traceViewServiceUiViewEvent(\"<- Deregistering\", uiView);\n\t            common_1.removeFrom(uiViews)(uiView);\n\t        };\n\t    };\n\t    ;\n\t    /**\n\t     * Returns the list of views currently available on the page, by fully-qualified name.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.available = function () {\n\t        return this.uiViews.map(hof_1.prop(\"fqn\"));\n\t    };\n\t    /**\n\t     * Returns the list of views on the page containing loaded content.\n\t     *\n\t     * @return {Array} Returns an array of fully-qualified view names.\n\t     */\n\t    ViewService.prototype.active = function () {\n\t        return this.uiViews.filter(hof_1.prop(\"$config\")).map(hof_1.prop(\"name\"));\n\t    };\n\t    /**\n\t     * Normalizes a view's name from a state.views configuration block.\n\t     *\n\t     * @param context the context object (state declaration) that the view belongs to\n\t     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n\t     *\n\t     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n\t     */\n\t    ViewService.normalizeUiViewTarget = function (context, rawViewName) {\n\t        if (rawViewName === void 0) { rawViewName = \"\"; }\n\t        // TODO: Validate incoming view name with a regexp to allow:\n\t        // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n\t        // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n\t        var viewAtContext = rawViewName.split(\"@\");\n\t        var uiViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\t        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \"^\"; // default to parent context\n\t        // Handle relative view-name sugar syntax.\n\t        // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n\t        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n\t        if (relativeViewNameSugar) {\n\t            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n\t            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n\t            uiViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n\t        }\n\t        if (uiViewName.charAt(0) === '!') {\n\t            uiViewName = uiViewName.substr(1);\n\t            uiViewContextAnchor = \"\"; // target absolutely from root\n\t        }\n\t        // handle parent relative targeting \"^.^.^\"\n\t        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\t        if (relativeMatch.exec(uiViewContextAnchor)) {\n\t            var anchor = uiViewContextAnchor.split(\".\").reduce((function (anchor, x) { return anchor.parent; }), context);\n\t            uiViewContextAnchor = anchor.name;\n\t        }\n\t        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n\t    };\n\t    return ViewService;\n\t}());\n\texports.ViewService = ViewService;\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module core */ /** */\n\tvar stateParams_1 = __webpack_require__(25);\n\tvar queue_1 = __webpack_require__(8);\n\tvar common_1 = __webpack_require__(3);\n\t/**\n\t * Global mutable state\n\t *\n\t * This is where we hold the global mutable state such as current state, current\n\t * params, current transition, last successful transition, last attempted transition, etc.\n\t */\n\tvar UIRouterGlobals = (function () {\n\t    function UIRouterGlobals(transitionService) {\n\t        var _this = this;\n\t        /**\n\t         * Current parameter values\n\t         *\n\t         * The parameter values from the latest successful transition\n\t         */\n\t        this.params = new stateParams_1.StateParams();\n\t        /**\n\t         * The transition history\n\t         *\n\t         * This queue's size is limited to a maximum number (default: 1)\n\t         */\n\t        this.transitionHistory = new queue_1.Queue([], 1);\n\t        /**\n\t         * The history of successful transitions\n\t         *\n\t         * This queue's size is limited to a maximum number (default: 1)\n\t         */\n\t        this.successfulTransitions = new queue_1.Queue([], 1);\n\t        var beforeNewTransition = function ($transition$) {\n\t            _this.transition = $transition$;\n\t            _this.transitionHistory.enqueue($transition$);\n\t            var updateGlobalState = function () {\n\t                _this.successfulTransitions.enqueue($transition$);\n\t                _this.$current = $transition$.$to();\n\t                _this.current = _this.$current.self;\n\t                common_1.copy($transition$.params(), _this.params);\n\t            };\n\t            $transition$.onSuccess({}, updateGlobalState, { priority: 10000 });\n\t            var clearCurrentTransition = function () { if (_this.transition === $transition$)\n\t                _this.transition = null; };\n\t            $transition$.promise.then(clearCurrentTransition, clearCurrentTransition);\n\t        };\n\t        transitionService.onBefore({}, ['$transition$', beforeNewTransition]);\n\t    }\n\t    return UIRouterGlobals;\n\t}());\n\texports.UIRouterGlobals = UIRouterGlobals;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module core */ /** */\n\tvar urlMatcherFactory_1 = __webpack_require__(47);\n\tvar urlRouter_1 = __webpack_require__(48);\n\tvar state_1 = __webpack_require__(18);\n\tvar urlRouter_2 = __webpack_require__(48);\n\tvar transitionService_1 = __webpack_require__(43);\n\tvar view_1 = __webpack_require__(50);\n\tvar stateRegistry_1 = __webpack_require__(36);\n\tvar stateService_1 = __webpack_require__(37);\n\tvar globals_1 = __webpack_require__(51);\n\t/**\n\t * The master class used to instantiate an instance of UI-Router.\n\t *\n\t * This class instantiates and wires the global UI-Router services.\n\t *\n\t * After instantiating a new instance of the Router class, configure it for your app.  For instance, register\n\t * your app states with the [[stateRegistry]] (and set url options using ...).  Then, tell UI-Router to monitor\n\t * the URL by calling `urlRouter.listen()` ([[URLRouter.listen]])\n\t */\n\tvar UIRouter = (function () {\n\t    function UIRouter() {\n\t        this.viewService = new view_1.ViewService();\n\t        this.transitionService = new transitionService_1.TransitionService(this.viewService);\n\t        this.globals = new globals_1.UIRouterGlobals(this.transitionService);\n\t        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n\t        this.urlRouterProvider = new urlRouter_1.UrlRouterProvider(this.urlMatcherFactory, this.globals.params);\n\t        this.urlRouter = new urlRouter_2.UrlRouter(this.urlRouterProvider);\n\t        this.stateRegistry = new stateRegistry_1.StateRegistry(this.urlMatcherFactory, this.urlRouterProvider);\n\t        /** @hidden TODO: move this to ng1.ts */\n\t        this.stateProvider = new state_1.StateProvider(this.stateRegistry);\n\t        this.stateService = new stateService_1.StateService(this.viewService, this.urlRouter, this.transitionService, this.stateRegistry, this.stateProvider, this.globals);\n\t        this.viewService.rootContext(this.stateRegistry.root());\n\t        this.globals.$current = this.stateRegistry.root();\n\t        this.globals.current = this.globals.$current.self;\n\t    }\n\t    return UIRouter;\n\t}());\n\texports.UIRouter = UIRouter;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * # UI-Router for Angular 1\n\t *\n\t * - Provides an implementation for the [[CoreServices]] API, based on angular 1 services.\n\t * - Also registers some services with the angular 1 injector.\n\t * - Creates and bootstraps a new [[UIRouter]] object.  Ties it to the the angular 1 lifecycle.\n\t *\n\t * @module ng1\n\t * @preferred\n\t */\n\t\"use strict\";\n\t/** for typedoc */\n\tvar router_1 = __webpack_require__(52);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar common_1 = __webpack_require__(3);\n\tvar hof_1 = __webpack_require__(5);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar module_1 = __webpack_require__(44);\n\tvar module_2 = __webpack_require__(40);\n\tvar module_3 = __webpack_require__(17);\n\tvar trace_1 = __webpack_require__(12);\n\tvar viewsBuilder_1 = __webpack_require__(54);\n\tvar templateFactory_1 = __webpack_require__(55);\n\tvar resolvesBuilder_1 = __webpack_require__(56);\n\t/** @hidden */\n\tvar app = angular.module(\"ui.router.angular1\", []);\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng', 'ui.router.init']);\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t *\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t *\n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t *\n\t * ## The main module for ui.router\n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes.\n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router -\n\t *\n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t *\n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\n\tangular.module('ui.router.compat', ['ui.router']);\n\t/**\n\t * Annotates a controller expression (may be a controller function(), a \"controllername\",\n\t * or \"controllername as name\")\n\t *\n\t * - Temporarily decorates $injector.instantiate.\n\t * - Invokes $controller() service\n\t *   - Calls $injector.instantiate with controller constructor\n\t * - Annotate constructor\n\t * - Undecorate $injector\n\t *\n\t * returns an array of strings, which are the arguments of the controller expression\n\t */\n\tfunction annotateController(controllerExpression) {\n\t    var $injector = coreservices_1.services.$injector;\n\t    var $controller = $injector.get(\"$controller\");\n\t    var oldInstantiate = $injector.instantiate;\n\t    try {\n\t        var deps_1;\n\t        $injector.instantiate = function fakeInstantiate(constructorFunction) {\n\t            $injector.instantiate = oldInstantiate; // Un-decorate ASAP\n\t            deps_1 = $injector.annotate(constructorFunction);\n\t        };\n\t        $controller(controllerExpression, { $scope: {} });\n\t        return deps_1;\n\t    }\n\t    finally {\n\t        $injector.instantiate = oldInstantiate;\n\t    }\n\t}\n\texports.annotateController = annotateController;\n\trunBlock.$inject = ['$injector', '$q'];\n\tfunction runBlock($injector, $q) {\n\t    coreservices_1.services.$injector = $injector;\n\t    coreservices_1.services.$q = $q;\n\t}\n\tapp.run(runBlock);\n\tvar router = null;\n\tng1UIRouter.$inject = ['$locationProvider'];\n\t/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\n\tfunction ng1UIRouter($locationProvider) {\n\t    // Create a new instance of the Router when the ng1UIRouterProvider is initialized\n\t    router = new router_1.UIRouter();\n\t    // Apply ng1 `views` builder to the StateBuilder\n\t    router.stateRegistry.decorator(\"views\", viewsBuilder_1.ng1ViewsBuilder);\n\t    router.stateRegistry.decorator(\"resolve\", resolvesBuilder_1.ng1ResolveBuilder);\n\t    router.viewService.viewConfigFactory('ng1', viewsBuilder_1.ng1ViewConfigFactory);\n\t    // Bind LocationConfig.hashPrefix to $locationProvider.hashPrefix\n\t    common_1.bindFunctions($locationProvider, coreservices_1.services.locationConfig, $locationProvider, ['hashPrefix']);\n\t    // Create a LocationService.onChange registry\n\t    var urlListeners = [];\n\t    coreservices_1.services.location.onChange = function (callback) {\n\t        urlListeners.push(callback);\n\t        return function () { return common_1.removeFrom(urlListeners)(callback); };\n\t    };\n\t    this.$get = $get;\n\t    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n\t    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n\t        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n\t        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return urlListeners.forEach(function (fn) { return fn(evt); }); });\n\t        // Bind LocationConfig.html5Mode to $locationProvider.html5Mode and $sniffer.history\n\t        coreservices_1.services.locationConfig.html5Mode = function () {\n\t            var html5Mode = $locationProvider.html5Mode();\n\t            html5Mode = predicates_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n\t            return html5Mode && $sniffer.history;\n\t        };\n\t        coreservices_1.services.template.get = function (url) {\n\t            return $http.get(url, { cache: $templateCache, headers: { Accept: 'text/html' } }).then(hof_1.prop(\"data\"));\n\t        };\n\t        // Bind these LocationService functions to $location\n\t        common_1.bindFunctions($location, coreservices_1.services.location, $location, [\"replace\", \"url\", \"path\", \"search\", \"hash\"]);\n\t        // Bind these LocationConfig functions to $location\n\t        common_1.bindFunctions($location, coreservices_1.services.locationConfig, $location, ['port', 'protocol', 'host']);\n\t        // Bind these LocationConfig functions to $browser\n\t        common_1.bindFunctions($browser, coreservices_1.services.locationConfig, $browser, ['baseHref']);\n\t        return router;\n\t    }\n\t}\n\tvar resolveFactory = function () { return ({\n\t    /**\n\t     * This emulates most of the behavior of the ui-router 0.2.x $resolve.resolve() service API.\n\t     * @param invocables an object, with keys as resolve names and values as injectable functions\n\t     * @param locals key/value pre-resolved data (locals)\n\t     * @param parent a promise for a \"parent resolve\"\n\t     */\n\t    resolve: function (invocables, locals, parent) {\n\t        if (locals === void 0) { locals = {}; }\n\t        var parentNode = new module_1.Node(new module_3.State({ params: {} }));\n\t        var node = new module_1.Node(new module_3.State({ params: {} }));\n\t        var context = new module_2.ResolveContext([parentNode, node]);\n\t        context.addResolvables(module_2.Resolvable.makeResolvables(invocables), node.state);\n\t        var resolveData = function (parentLocals) {\n\t            var rewrap = function (_locals) { return module_2.Resolvable.makeResolvables(common_1.map(_locals, function (local) { return function () { return local; }; })); };\n\t            context.addResolvables(rewrap(parentLocals), parentNode.state);\n\t            context.addResolvables(rewrap(locals), node.state);\n\t            return context.resolvePath();\n\t        };\n\t        return parent ? parent.then(resolveData) : resolveData({});\n\t    }\n\t}); };\n\tfunction $stateParamsFactory(ng1UIRouter) {\n\t    return ng1UIRouter.globals.params;\n\t}\n\t// The 'ui.router' ng1 module depends on 'ui.router.init' module.\n\tangular.module('ui.router.init', []).provider(\"ng1UIRouter\", ng1UIRouter);\n\t// This effectively calls $get() to init when we enter runtime\n\tangular.module('ui.router.init').run(['ng1UIRouter', function (ng1UIRouter) { }]);\n\t// $urlMatcherFactory service and $urlMatcherFactoryProvider\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', ['ng1UIRouterProvider', function () { return router.urlMatcherFactory; }]);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\n\t// $urlRouter service and $urlRouterProvider\n\tfunction getUrlRouterProvider() {\n\t    router.urlRouterProvider[\"$get\"] = function () {\n\t        router.urlRouter.update(true);\n\t        if (!this.interceptDeferred)\n\t            router.urlRouter.listen();\n\t        return router.urlRouter;\n\t    };\n\t    return router.urlRouterProvider;\n\t}\n\tangular.module('ui.router.router').provider('$urlRouter', ['ng1UIRouterProvider', getUrlRouterProvider]);\n\tangular.module('ui.router.router').run(['$urlRouter', function ($urlRouter) { }]);\n\t// $state service and $stateProvider\n\t// $urlRouter service and $urlRouterProvider\n\tfunction getStateProvider() {\n\t    router.stateProvider[\"$get\"] = function () {\n\t        // Autoflush once we are in runtime\n\t        router.stateRegistry.stateQueue.autoFlush(router.stateService);\n\t        return router.stateService;\n\t    };\n\t    return router.stateProvider;\n\t}\n\tangular.module('ui.router.state').provider('$state', ['ng1UIRouterProvider', getStateProvider]);\n\tangular.module('ui.router.state').run(['$state', function ($state) { }]);\n\t// $stateParams service\n\tangular.module('ui.router.state').factory('$stateParams', ['ng1UIRouter', function (ng1UIRouter) {\n\t        return ng1UIRouter.globals.params;\n\t    }]);\n\t// $transitions service and $transitionsProvider\n\tfunction getTransitionsProvider() {\n\t    loadAllControllerLocals.$inject = ['$transition$'];\n\t    function loadAllControllerLocals($transition$) {\n\t        var loadLocals = function (vc) {\n\t            var node = common_1.find($transition$.treeChanges().to, hof_1.propEq('state', vc.viewDecl.$context));\n\t            // Temporary fix; This whole callback should be nuked when fixing #2662\n\t            if (!node)\n\t                return coreservices_1.services.$q.when();\n\t            var resolveCtx = node.resolveContext;\n\t            var controllerDeps = annotateController(vc.controller);\n\t            var resolvables = resolveCtx.getResolvables();\n\t            function $loadControllerLocals() { }\n\t            $loadControllerLocals.$inject = controllerDeps.filter(function (dep) { return resolvables.hasOwnProperty(dep); });\n\t            // Load any controller resolves that aren't already loaded\n\t            return resolveCtx.invokeLater($loadControllerLocals)\n\t                .then(function () { return vc.locals = common_1.map(resolvables, function (res) { return res.data; }); });\n\t        };\n\t        var loadAllLocals = $transition$.views(\"entering\").filter(function (vc) { return !!vc.controller; }).map(loadLocals);\n\t        return coreservices_1.services.$q.all(loadAllLocals).then(common_1.noop);\n\t    }\n\t    router.transitionService.onFinish({}, loadAllControllerLocals);\n\t    router.transitionService[\"$get\"] = function () { return router.transitionService; };\n\t    return router.transitionService;\n\t}\n\tangular.module('ui.router.state').provider('$transitions', ['ng1UIRouterProvider', getTransitionsProvider]);\n\t// $templateFactory service\n\tangular.module('ui.router.util').factory('$templateFactory', ['ng1UIRouter', function () { return new templateFactory_1.TemplateFactory(); }]);\n\t// The $view service\n\tangular.module('ui.router').factory('$view', function () { return router.viewService; });\n\t// The old $resolve service\n\tangular.module('ui.router').factory('$resolve', resolveFactory);\n\t// $trace service\n\tangular.module(\"ui.router\").service(\"$trace\", function () { return trace_1.trace; });\n\twatchDigests.$inject = ['$rootScope'];\n\tfunction watchDigests($rootScope) {\n\t    $rootScope.$watch(function () { trace_1.trace.approximateDigests++; });\n\t}\n\texports.watchDigests = watchDigests;\n\tangular.module(\"ui.router\").run(watchDigests);\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar strings_1 = __webpack_require__(9);\n\tvar view_1 = __webpack_require__(50);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar coreservices_1 = __webpack_require__(6);\n\tvar trace_1 = __webpack_require__(12);\n\tvar templateFactory_1 = __webpack_require__(55);\n\texports.ng1ViewConfigFactory = function (node, view) { return new Ng1ViewConfig(node, view); };\n\t/**\n\t * This is a [[StateBuilder.builder]] function for angular1 `views`.\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * handles the `views` property with logic specific to angular-ui-router (ng1).\n\t *\n\t * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n\t * and applies the state-level configuration to a view named `$default`.\n\t */\n\tfunction ng1ViewsBuilder(state) {\n\t    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings'], nonCompKeys = tplKeys.concat(ctrlKeys), allKeys = compKeys.concat(nonCompKeys);\n\t    var views = {}, viewsObject = state.views || { \"$default\": common_1.pick(state, allKeys) };\n\t    common_1.forEach(viewsObject, function (config, name) {\n\t        // Account for views: { \"\": { template... } }\n\t        name = name || \"$default\";\n\t        // Account for views: { header: \"headerComponent\" }\n\t        if (predicates_1.isString(config))\n\t            config = { component: config };\n\t        if (!Object.keys(config).length)\n\t            return;\n\t        // Configure this view for routing to an angular 1.5+ style .component (or any directive, really)\n\t        if (config.component) {\n\t            if (nonCompKeys.map(function (key) { return predicates_1.isDefined(config[key]); }).reduce(common_1.anyTrueR, false)) {\n\t                throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: 'name@\" + state.name + \"'\");\n\t            }\n\t            // Dynamically build a template like \"<component-name input1='::$resolve.foo'></component-name>\"\n\t            config.templateProvider = ['$injector', function ($injector) {\n\t                    var resolveFor = function (key) { return config.bindings && config.bindings[key] || key; };\n\t                    var prefix = angular.version.minor >= 3 ? \"::\" : \"\";\n\t                    var attributeTpl = function (input) {\n\t                        var attrName = strings_1.kebobString(input.name);\n\t                        var resolveName = resolveFor(input.name);\n\t                        if (input.type === '@')\n\t                            return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n\t                        return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n\t                    };\n\t                    var attrs = getComponentInputs($injector, config.component).map(attributeTpl).join(\" \");\n\t                    var kebobName = strings_1.kebobString(config.component);\n\t                    return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n\t                }];\n\t        }\n\t        config.resolveAs = config.resolveAs || '$resolve';\n\t        config.$type = \"ng1\";\n\t        config.$context = state;\n\t        config.$name = name;\n\t        var normalized = view_1.ViewService.normalizeUiViewTarget(config.$context, config.$name);\n\t        config.$uiViewName = normalized.uiViewName;\n\t        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n\t        views[name] = config;\n\t    });\n\t    return views;\n\t}\n\texports.ng1ViewsBuilder = ng1ViewsBuilder;\n\t// for ng 1.2 style, process the scope: { input: \"=foo\" }\n\t// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\n\tvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n\t    .map(function (key) { return [key, /^([=<@])[?]?(.*)/.exec(bindingsObj[key])]; }) // [ 'input', [ '=foo', '=', 'foo' ] ]\n\t    .filter(function (tuple) { return predicates_1.isDefined(tuple) && predicates_1.isDefined(tuple[1]); }) // skip malformed values\n\t    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); }; // { name: ('foo' || 'input'), type: '=' }\n\t// Given a directive definition, find its object input attributes\n\t// Use different properties, depending on the type of directive (component, bindToController, normal)\n\tvar getBindings = function (def) {\n\t    if (predicates_1.isObject(def.bindToController))\n\t        return scopeBindings(def.bindToController);\n\t    return scopeBindings(def.scope);\n\t};\n\t// Gets all the directive(s)' inputs ('@', '=', and '<')\n\tfunction getComponentInputs($injector, name) {\n\t    var cmpDefs = $injector.get(name + \"Directive\"); // could be multiple\n\t    if (!cmpDefs || !cmpDefs.length)\n\t        throw new Error(\"Unable to find component named '\" + name + \"'\");\n\t    return cmpDefs.map(getBindings).reduce(common_1.unnestR, []);\n\t}\n\tvar Ng1ViewConfig = (function () {\n\t    function Ng1ViewConfig(node, viewDecl) {\n\t        this.node = node;\n\t        this.viewDecl = viewDecl;\n\t        this.loaded = false;\n\t    }\n\t    Ng1ViewConfig.prototype.load = function () {\n\t        var _this = this;\n\t        var $q = coreservices_1.services.$q;\n\t        if (!this.hasTemplate())\n\t            throw new Error(\"No template configuration specified for '\" + this.viewDecl.$uiViewName + \"@\" + this.viewDecl.$uiViewContextAnchor + \"'\");\n\t        var injector = this.node.resolveContext;\n\t        var params = this.node.paramValues;\n\t        var promises = {\n\t            template: $q.when(this.getTemplate(params, new templateFactory_1.TemplateFactory(), injector)),\n\t            controller: $q.when(this.getController(injector))\n\t        };\n\t        return $q.all(promises).then(function (results) {\n\t            trace_1.trace.traceViewServiceEvent(\"Loaded\", _this);\n\t            _this.controller = results.controller;\n\t            _this.template = results.template;\n\t        });\n\t    };\n\t    /**\n\t     * Checks a view configuration to ensure that it specifies a template.\n\t     *\n\t     * @return {boolean} Returns `true` if the configuration contains a valid template, otherwise `false`.\n\t     */\n\t    Ng1ViewConfig.prototype.hasTemplate = function () {\n\t        return !!(this.viewDecl.template || this.viewDecl.templateUrl || this.viewDecl.templateProvider);\n\t    };\n\t    Ng1ViewConfig.prototype.getTemplate = function (params, $factory, injector) {\n\t        return $factory.fromConfig(this.viewDecl, params, injector.invokeLater.bind(injector));\n\t    };\n\t    /**\n\t     * Gets the controller for a view configuration.\n\t     *\n\t     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n\t     */\n\t    Ng1ViewConfig.prototype.getController = function (injector) {\n\t        //* @param {Object} locals A context object from transition.context() to invoke a function in the correct context\n\t        var provider = this.viewDecl.controllerProvider;\n\t        return predicates_1.isInjectable(provider) ? injector.invokeLater(provider, {}) : this.viewDecl.controller;\n\t    };\n\t    return Ng1ViewConfig;\n\t}());\n\texports.Ng1ViewConfig = Ng1ViewConfig;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/** @module view */ /** for typedoc */\n\tvar predicates_1 = __webpack_require__(4);\n\tvar coreservices_1 = __webpack_require__(6);\n\t/**\n\t * Service which manages loading of templates from a ViewConfig.\n\t */\n\tvar TemplateFactory = (function () {\n\t    function TemplateFactory() {\n\t    }\n\t    /**\n\t     * Creates a template from a configuration object.\n\t     *\n\t     * @param config Configuration object for which to load a template.\n\t     * The following properties are search in the specified order, and the first one\n\t     * that is defined is used to create the template:\n\t     *\n\t     * @param params  Parameters to pass to the template function.\n\t     * @param injectFn Function to which an injectable function may be passed.\n\t     *        If templateProvider is defined, this injectFn will be used to invoke it.\n\t     *\n\t     * @return {string|object}  The template html as a string, or a promise for\n\t     * that string,or `null` if no template is configured.\n\t     */\n\t    TemplateFactory.prototype.fromConfig = function (config, params, injectFn) {\n\t        return (predicates_1.isDefined(config.template) ? this.fromString(config.template, params) :\n\t            predicates_1.isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t                predicates_1.isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, injectFn) :\n\t                    null);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a template from a string or a function returning a string.\n\t     *\n\t     * @param template html template as a string or function that returns an html template as a string.\n\t     * @param params Parameters to pass to the template function.\n\t     *\n\t     * @return {string|object} The template html as a string, or a promise for that\n\t     * string.\n\t     */\n\t    TemplateFactory.prototype.fromString = function (template, params) {\n\t        return predicates_1.isFunction(template) ? template(params) : template;\n\t    };\n\t    ;\n\t    /**\n\t     * Loads a template from the a URL via `$http` and `$templateCache`.\n\t     *\n\t     * @param {string|Function} url url of the template to load, or a function\n\t     * that returns a url.\n\t     * @param {Object} params Parameters to pass to the url function.\n\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t     * for that string.\n\t     */\n\t    TemplateFactory.prototype.fromUrl = function (url, params) {\n\t        if (predicates_1.isFunction(url))\n\t            url = url(params);\n\t        if (url == null)\n\t            return null;\n\t        return coreservices_1.services.template.get(url);\n\t    };\n\t    ;\n\t    /**\n\t     * Creates a template by invoking an injectable provider function.\n\t     *\n\t     * @param provider Function to invoke via `locals`\n\t     * @param {Function} injectFn a function used to invoke the template provider\n\t     * @return {string|Promise.<string>} The template html as a string, or a promise\n\t     * for that string.\n\t     */\n\t    TemplateFactory.prototype.fromProvider = function (provider, params, injectFn) {\n\t        return injectFn(provider);\n\t    };\n\t    ;\n\t    return TemplateFactory;\n\t}());\n\texports.TemplateFactory = TemplateFactory;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\t/**\n\t * This is a [[StateBuilder.builder]] function for angular1 `resolve:` block on a [[Ng1StateDeclaration]].\n\t *\n\t * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder\n\t * handles the `resolve` property with logic specific to angular-ui-router (ng1).\n\t */\n\tfunction ng1ResolveBuilder(state) {\n\t    var resolve = {};\n\t    common_1.forEach(state.resolve || {}, function (resolveFn, name) {\n\t        resolve[name] = predicates_1.isString(resolveFn) ? [resolveFn, function (x) { return x; }] : resolveFn;\n\t    });\n\t    return resolve;\n\t}\n\texports.ng1ResolveBuilder = ng1ResolveBuilder;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/**\n\t * These are the UI-Router angular 1 directives.\n\t *\n\t * These directives are used in templates to create viewports and navigate to states\n\t *\n\t * @preferred @module ng1_directives\n\t */ /** for typedoc */\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar hof_1 = __webpack_require__(5);\n\t/** @hidden */\n\tfunction parseStateRef(ref, current) {\n\t    var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t    if (preparsed)\n\t        ref = current + '(' + preparsed[1] + ')';\n\t    parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t    if (!parsed || parsed.length !== 4)\n\t        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t    return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t/** @hidden */\n\tfunction stateContext(el) {\n\t    var $uiView = el.parent().inheritedData('$uiView');\n\t    var context = hof_1.parse('$cfg.node.state')($uiView);\n\t    return context && context.name ? context : undefined;\n\t}\n\t/** @hidden */\n\tfunction getTypeInfo(el) {\n\t    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t    var isForm = el[0].nodeName === \"FORM\";\n\t    return {\n\t        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t        clickable: !isForm\n\t    };\n\t}\n\t/** @hidden */\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t    return function (e) {\n\t        var button = e.which || e.button, target = current();\n\t        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t            var transition = $timeout(function () {\n\t                $state.go(target.state, target.params, target.options);\n\t            });\n\t            e.preventDefault();\n\t            // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n\t            e.preventDefault = function () {\n\t                if (ignorePreventDefaultCount-- <= 0)\n\t                    $timeout.cancel(transition);\n\t            };\n\t        }\n\t    };\n\t}\n\t/** @hidden */\n\tfunction defaultOpts(el, $state) {\n\t    return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t/**\n\t * `ui-sref`: A directive for linking to a state\n\t *\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t *\n\t * @example\n\t * ```html\n\t *\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t * ```\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t *\n\t * ```html\n\t *\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t * ```\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to [[StateService.go]]\n\t */\n\tvar uiSrefNg1 = ['$state', '$timeout',\n\t    function $StateRefDirective($state, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t            link: function (scope, element, attrs, uiSrefActive) {\n\t                var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t                var def = { state: ref.state, href: null, params: null, options: null };\n\t                var type = getTypeInfo(element);\n\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t                var unlinkInfoFn = null;\n\t                def.options = common_1.extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t                var update = function (val) {\n\t                    if (val)\n\t                        def.params = angular.copy(val);\n\t                    def.href = $state.href(ref.state, def.params, def.options);\n\t                    if (unlinkInfoFn)\n\t                        unlinkInfoFn();\n\t                    if (active)\n\t                        unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);\n\t                    if (def.href !== null)\n\t                        attrs.$set(type.attr, def.href);\n\t                };\n\t                if (ref.paramExpr) {\n\t                    scope.$watch(ref.paramExpr, function (val) { if (val !== def.params)\n\t                        update(val); }, true);\n\t                    def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t                }\n\t                update();\n\t                if (!type.clickable)\n\t                    return;\n\t                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\n\t            }\n\t        };\n\t    }];\n\t/**\n\t * `ui-state`: A dynamic version of `ui-sref`\n\t *\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @example\n\t * ```html\n\t *\n\t * <li ng-repeat=\"nav in navlinks\">\n\t *   <a ui-state=\"nav.statename\">{{nav.description}}</a>\n\t * </li>\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to [[StateService.href]]\n\t * @param {Object} ui-state-opts options to pass to [[StateService.go]]\n\t */\n\tvar uiStateNg1 = ['$state', '$timeout',\n\t    function $StateRefDynamicDirective($state, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t            link: function (scope, element, attrs, uiSrefActive) {\n\t                var type = getTypeInfo(element);\n\t                var active = uiSrefActive[1] || uiSrefActive[0];\n\t                var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t                var watch = '[' + group.map(function (val) { return val || 'null'; }).join(', ') + ']';\n\t                var def = { state: null, params: null, options: null, href: null };\n\t                var unlinkInfoFn = null;\n\t                function runStateRefLink(group) {\n\t                    def.state = group[0];\n\t                    def.params = group[1];\n\t                    def.options = group[2];\n\t                    def.href = $state.href(def.state, def.params, def.options);\n\t                    if (unlinkInfoFn)\n\t                        unlinkInfoFn();\n\t                    if (active)\n\t                        unlinkInfoFn = active.$$addStateInfo(def.state, def.params);\n\t                    if (def.href)\n\t                        attrs.$set(type.attr, def.href);\n\t                }\n\t                scope.$watch(watch, runStateRefLink, true);\n\t                runStateRefLink(scope.$eval(watch));\n\t                if (!type.clickable)\n\t                    return;\n\t                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\n\t            }\n\t        };\n\t    }];\n\t/**\n\t * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n\t *\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use ui-sref-active-eq\n\t *\n\t * Given the following template:\n\t * @example\n\t * ```html\n\t *\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t * ```\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t *\n\t * ```html\n\t *\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t * ```\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t *\n\t * ```html\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t * ```\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * @example\n\t * ```html\n\t *\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t * ```\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\tvar uiSrefActiveNg1 = ['$state', '$stateParams', '$interpolate', '$transitions',\n\t    function $StateRefActiveDirective($state, $stateParams, $interpolate, $transitions) {\n\t        return {\n\t            restrict: \"A\",\n\t            controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t                    var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t                    // There probably isn't much point in $observing this\n\t                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t                    // slight difference in logic routing\n\t                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t                    try {\n\t                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t                    }\n\t                    catch (e) {\n\t                    }\n\t                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t                    if (predicates_1.isObject(uiSrefActive)) {\n\t                        common_1.forEach(uiSrefActive, function (stateOrName, activeClass) {\n\t                            if (predicates_1.isString(stateOrName)) {\n\t                                var ref = parseStateRef(stateOrName, $state.current.name);\n\t                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t                            }\n\t                        });\n\t                    }\n\t                    // Allow uiSref to communicate with uiSrefActive[Equals]\n\t                    this.$$addStateInfo = function (newState, newParams) {\n\t                        // we already got an explicit state provided by ui-sref-active, so we\n\t                        // shadow the one that comes from ui-sref\n\t                        if (predicates_1.isObject(uiSrefActive) && states.length > 0) {\n\t                            return;\n\t                        }\n\t                        var deregister = addState(newState, newParams, uiSrefActive);\n\t                        update();\n\t                        return deregister;\n\t                    };\n\t                    $scope.$on('$stateChangeSuccess', update);\n\t                    var updateAfterTransition = ['$transition$', function ($transition$) { $transition$.promise.then(update); }];\n\t                    var deregisterFn = $transitions.onStart({}, updateAfterTransition);\n\t                    $scope.$on('$destroy', deregisterFn);\n\t                    function addState(stateName, stateParams, activeClass) {\n\t                        var state = $state.get(stateName, stateContext($element));\n\t                        var stateHash = createStateHash(stateName, stateParams);\n\t                        var stateInfo = {\n\t                            state: state || { name: stateName },\n\t                            params: stateParams,\n\t                            hash: stateHash\n\t                        };\n\t                        states.push(stateInfo);\n\t                        activeClasses[stateHash] = activeClass;\n\t                        return function removeState() {\n\t                            var idx = states.indexOf(stateInfo);\n\t                            if (idx !== -1)\n\t                                states.splice(idx, 1);\n\t                        };\n\t                    }\n\t                    /**\n\t                     * @param {string} state\n\t                     * @param {Object|string} [params]\n\t                     * @return {string}\n\t                     */\n\t                    function createStateHash(state, params) {\n\t                        if (!predicates_1.isString(state)) {\n\t                            throw new Error('state should be a string');\n\t                        }\n\t                        if (predicates_1.isObject(params)) {\n\t                            return state + common_1.toJson(params);\n\t                        }\n\t                        params = $scope.$eval(params);\n\t                        if (predicates_1.isObject(params)) {\n\t                            return state + common_1.toJson(params);\n\t                        }\n\t                        return state;\n\t                    }\n\t                    // Update route state\n\t                    function update() {\n\t                        for (var i = 0; i < states.length; i++) {\n\t                            if (anyMatch(states[i].state, states[i].params)) {\n\t                                addClass($element, activeClasses[states[i].hash]);\n\t                            }\n\t                            else {\n\t                                removeClass($element, activeClasses[states[i].hash]);\n\t                            }\n\t                            if (exactMatch(states[i].state, states[i].params)) {\n\t                                addClass($element, activeEqClass);\n\t                            }\n\t                            else {\n\t                                removeClass($element, activeEqClass);\n\t                            }\n\t                        }\n\t                    }\n\t                    function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t                    function removeClass(el, className) { el.removeClass(className); }\n\t                    function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t                    function exactMatch(state, params) { return $state.is(state.name, params); }\n\t                    update();\n\t                }]\n\t        };\n\t    }];\n\tangular.module('ui.router.state')\n\t    .directive('uiSref', uiSrefNg1)\n\t    .directive('uiSrefActive', uiSrefActiveNg1)\n\t    .directive('uiSrefActiveEq', uiSrefActiveNg1)\n\t    .directive('uiState', uiStateNg1);\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t/** @module state */ /** for typedoc */\n\t\"use strict\";\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t    var isFilter = function (state, params, options) {\n\t        return $state.is(state, params, options);\n\t    };\n\t    isFilter.$stateful = true;\n\t    return isFilter;\n\t}\n\texports.$IsStateFilter = $IsStateFilter;\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t    var includesFilter = function (state, params, options) {\n\t        return $state.includes(state, params, options);\n\t    };\n\t    includesFilter.$stateful = true;\n\t    return includesFilter;\n\t}\n\texports.$IncludedByStateFilter = $IncludedByStateFilter;\n\tangular.module('ui.router.state')\n\t    .filter('isState', $IsStateFilter)\n\t    .filter('includedByState', $IncludedByStateFilter);\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/** @module ng1_directives */ /** for typedoc */\n\t\"use strict\";\n\tvar common_1 = __webpack_require__(3);\n\tvar predicates_1 = __webpack_require__(4);\n\tvar trace_1 = __webpack_require__(12);\n\tvar viewsBuilder_1 = __webpack_require__(54);\n\tvar rejectFactory_1 = __webpack_require__(10);\n\tvar hof_1 = __webpack_require__(5);\n\tvar strings_1 = __webpack_require__(9);\n\t/**\n\t * `ui-view`: A viewport directive which is filled in by a view from the active state.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t *\n\t * A view can be unnamed or named.\n\t * @example\n\t * ```html\n\t *\n\t * <!-- Unnamed -->\n\t * <div ui-view></div>\n\t *\n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * ```\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a\n\t * single view and it is unnamed then you can populate it like so:\n\t * ```\n\t *\n\t * <div ui-view></div>\n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * ```\n\t *\n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * ```js\n\t *\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * But typically you'll only use the views property if you name your view or have more than one view\n\t * in the same template. There's not really a compelling reason to name a view if its the only one,\n\t * but you could if you wanted, like so:\n\t *\n\t * ```html\n\t *\n\t * <div ui-view=\"main\"></div>\n\t * ```\n\t *\n\t * ```js\n\t *\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * Really though, you'll use views to set up multiple views:\n\t * ```html\n\t *\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div>\n\t * <div ui-view=\"data\"></div>\n\t * ```\n\t *\n\t * ```js\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * ```html\n\t *\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * ```\n\t *\n\t * Resolve data:\n\t *\n\t * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n\t * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n\t *\n\t * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n\t * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n\t * depends on `$resolve` data.\n\t *\n\t * @example\n\t * ```js\n\t *\n\t * $stateProvider.state('home', {\n\t *   template: '<my-component user=\"$resolve.user\"></my-component>',\n\t *   resolve: {\n\t *     user: function(UserService) { return UserService.fetchUser(); }\n\t *   }\n\t * });\n\t * ```\n\t */\n\tvar uiViewNg1 = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n\t    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n\t        function getRenderer(attrs, scope) {\n\t            return {\n\t                enter: function (element, target, cb) {\n\t                    if (angular.version.minor > 2) {\n\t                        $animate.enter(element, null, target).then(cb);\n\t                    }\n\t                    else {\n\t                        $animate.enter(element, null, target, cb);\n\t                    }\n\t                },\n\t                leave: function (element, cb) {\n\t                    if (angular.version.minor > 2) {\n\t                        $animate.leave(element).then(cb);\n\t                    }\n\t                    else {\n\t                        $animate.leave(element, cb);\n\t                    }\n\t                }\n\t            };\n\t        }\n\t        function configsEqual(config1, config2) {\n\t            return config1 === config2;\n\t        }\n\t        var rootData = {\n\t            $cfg: { viewDecl: { $context: $view.rootContext() } },\n\t            $uiView: {}\n\t        };\n\t        var directive = {\n\t            count: 0,\n\t            restrict: 'ECA',\n\t            terminal: true,\n\t            priority: 400,\n\t            transclude: 'element',\n\t            compile: function (tElement, tAttrs, $transclude) {\n\t                return function (scope, $element, attrs) {\n\t                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs.onload || '', autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs.uiView || attrs.name || '')(scope) || '$default';\n\t                    var activeUIView = {\n\t                        $type: 'ng1',\n\t                        id: directive.count++,\n\t                        name: name,\n\t                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n\t                        config: null,\n\t                        configUpdated: configUpdatedCallback,\n\t                        get creationContext() {\n\t                            return hof_1.parse('$cfg.viewDecl.$context')(inherited);\n\t                        }\n\t                    };\n\t                    trace_1.trace.traceUiViewEvent(\"Linking\", activeUIView);\n\t                    function configUpdatedCallback(config) {\n\t                        if (config && !(config instanceof viewsBuilder_1.Ng1ViewConfig))\n\t                            return;\n\t                        if (configsEqual(viewConfig, config))\n\t                            return;\n\t                        trace_1.trace.traceUiViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n\t                        viewConfig = config;\n\t                        updateView(config);\n\t                    }\n\t                    $element.data('$uiView', { $uiView: activeUIView });\n\t                    updateView();\n\t                    unregister = $view.registerUiView(activeUIView);\n\t                    scope.$on(\"$destroy\", function () {\n\t                        trace_1.trace.traceUiViewEvent(\"Destroying/Unregistering\", activeUIView);\n\t                        unregister();\n\t                    });\n\t                    function cleanupLastView() {\n\t                        if (previousEl) {\n\t                            trace_1.trace.traceUiViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n\t                            previousEl.remove();\n\t                            previousEl = null;\n\t                        }\n\t                        if (currentScope) {\n\t                            trace_1.trace.traceUiViewEvent(\"Destroying scope\", activeUIView);\n\t                            currentScope.$destroy();\n\t                            currentScope = null;\n\t                        }\n\t                        if (currentEl) {\n\t                            var _viewData_1 = currentEl.data('$uiView');\n\t                            trace_1.trace.traceUiViewEvent(\"Animate out\", _viewData_1);\n\t                            renderer.leave(currentEl, function () {\n\t                                _viewData_1.$$animLeave.resolve();\n\t                                previousEl = null;\n\t                            });\n\t                            previousEl = currentEl;\n\t                            currentEl = null;\n\t                        }\n\t                    }\n\t                    function updateView(config) {\n\t                        var newScope = scope.$new();\n\t                        trace_1.trace.traceUiViewScopeCreated(activeUIView, newScope);\n\t                        var animEnter = $q.defer(), animLeave = $q.defer();\n\t                        var $uiViewData = {\n\t                            $cfg: config,\n\t                            $uiView: activeUIView,\n\t                            $animEnter: animEnter.promise,\n\t                            $animLeave: animLeave.promise,\n\t                            $$animLeave: animLeave\n\t                        };\n\t                        var cloned = $transclude(newScope, function (clone) {\n\t                            renderer.enter(clone.data('$uiView', $uiViewData), $element, function onUiViewEnter() {\n\t                                animEnter.resolve();\n\t                                if (currentScope)\n\t                                    currentScope.$emit('$viewContentAnimationEnded');\n\t                                if (predicates_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                                    $uiViewScroll(clone);\n\t                                }\n\t                            });\n\t                            cleanupLastView();\n\t                        });\n\t                        currentEl = cloned;\n\t                        currentScope = newScope;\n\t                        /**\n\t                         * @ngdoc event\n\t                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t                         * @eventOf ui.router.state.directive:ui-view\n\t                         * @eventType emits on ui-view directive scope\n\t                         * @description           *\n\t                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t                         *\n\t                         * @param {Object} event Event object.\n\t                         */\n\t                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n\t                        currentScope.$eval(onloadExp);\n\t                    }\n\t                };\n\t            }\n\t        };\n\t        return directive;\n\t    }];\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$timeout'];\n\t/** @hidden */\n\tfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $timeout) {\n\t    var getControllerAs = hof_1.parse('viewDecl.controllerAs');\n\t    var getResolveAs = hof_1.parse('viewDecl.resolveAs');\n\t    var getResolveContext = hof_1.parse('node.resolveContext');\n\t    return {\n\t        restrict: 'ECA',\n\t        priority: -400,\n\t        compile: function (tElement) {\n\t            var initial = tElement.html();\n\t            return function (scope, $element) {\n\t                var data = $element.data('$uiView');\n\t                if (!data)\n\t                    return;\n\t                var cfg = data.$cfg || { viewDecl: {} };\n\t                $element.html(cfg.template || initial);\n\t                trace_1.trace.traceUiViewFill(data.$uiView, $element.html());\n\t                var link = $compile($element.contents());\n\t                var controller = cfg.controller;\n\t                var controllerAs = getControllerAs(cfg);\n\t                var resolveAs = getResolveAs(cfg);\n\t                var resolveCtx = getResolveContext(cfg);\n\t                var locals = resolveCtx && common_1.map(resolveCtx.getResolvables(), function (r) { return r.data; });\n\t                scope[resolveAs] = locals;\n\t                if (controller) {\n\t                    var controllerInstance = $controller(controller, common_1.extend({}, locals, { $scope: scope, $element: $element }));\n\t                    if (controllerAs) {\n\t                        scope[controllerAs] = controllerInstance;\n\t                        scope[controllerAs][resolveAs] = locals;\n\t                    }\n\t                    // TODO: Use $view service as a central point for registering component-level hooks\n\t                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n\t                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n\t                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n\t                    $element.data('$ngControllerController', controllerInstance);\n\t                    $element.children().data('$ngControllerController', controllerInstance);\n\t                    registerControllerCallbacks($transitions, controllerInstance, scope, cfg);\n\t                }\n\t                // Wait for the component to appear in the DOM\n\t                if (predicates_1.isString(cfg.viewDecl.component)) {\n\t                    var cmp_1 = cfg.viewDecl.component;\n\t                    var kebobName_1 = strings_1.kebobString(cmp_1);\n\t                    var getComponentController = function () {\n\t                        var directiveEl = [].slice.call($element[0].children)\n\t                            .filter(function (el) { return el && el.tagName && el.tagName.toLowerCase() === kebobName_1; });\n\t                        return directiveEl && angular.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n\t                    };\n\t                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n\t                        if (!ctrlInstance)\n\t                            return;\n\t                        registerControllerCallbacks($transitions, ctrlInstance, scope, cfg);\n\t                        deregisterWatch_1();\n\t                    });\n\t                }\n\t                link(scope);\n\t            };\n\t        }\n\t    };\n\t}\n\t/** @hidden */\n\tvar hasComponentImpl = typeof angular.module('ui.router')['component'] === 'function';\n\t/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\n\tfunction registerControllerCallbacks($transitions, controllerInstance, $scope, cfg) {\n\t    // Call $onInit() ASAP\n\t    if (predicates_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl))\n\t        controllerInstance.$onInit();\n\t    var hookOptions = { bind: controllerInstance };\n\t    // Add component-level hook for onParamsChange\n\t    if (predicates_1.isFunction(controllerInstance.uiOnParamsChanged)) {\n\t        // Fire callback on any successful transition\n\t        var paramsUpdated_1 = function ($transition$) {\n\t            var ctx = cfg.node.resolveContext;\n\t            var viewCreationTrans = ctx.getResolvables()['$transition$'].data;\n\t            // Exit early if the $transition$ is the same as the view was created within.\n\t            // Exit early if the $transition$ will exit the state the view is for.\n\t            if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(cfg.node.state.self) !== -1)\n\t                return;\n\t            var toParams = $transition$.params(\"to\");\n\t            var fromParams = $transition$.params(\"from\");\n\t            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(common_1.unnestR, []);\n\t            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(common_1.unnestR, []);\n\t            // Find the to params that have different values than the from params\n\t            var changedToParams = toSchema.filter(function (param) {\n\t                var idx = fromSchema.indexOf(param);\n\t                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n\t            });\n\t            // Only trigger callback if a to param has changed or is new\n\t            if (changedToParams.length) {\n\t                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n\t                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n\t                controllerInstance.uiOnParamsChanged(common_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; }), $transition$);\n\t            }\n\t        };\n\t        $scope.$on('$destroy', $transitions.onSuccess({}, ['$transition$', paramsUpdated_1]), hookOptions);\n\t        // Fire callback on any IGNORED transition\n\t        var onDynamic = function ($error$, $transition$) {\n\t            if ($error$.type === rejectFactory_1.RejectType.IGNORED)\n\t                paramsUpdated_1($transition$);\n\t        };\n\t        $scope.$on('$destroy', $transitions.onError({}, ['$error$', '$transition$', onDynamic]), hookOptions);\n\t    }\n\t    // Add component-level hook for uiCanExit\n\t    if (predicates_1.isFunction(controllerInstance.uiCanExit)) {\n\t        var criteria = { exiting: cfg.node.state.name };\n\t        $scope.$on('$destroy', $transitions.onBefore(criteria, controllerInstance.uiCanExit, hookOptions));\n\t    }\n\t}\n\tangular.module('ui.router.state').directive('uiView', uiViewNg1);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t    var useAnchorScroll = false;\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t     * @methodOf ui.router.state.$uiViewScrollProvider\n\t     *\n\t     * @description\n\t     * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t     * scrolling based on the url anchor.\n\t     */\n\t    this.useAnchorScroll = function () {\n\t        useAnchorScroll = true;\n\t    };\n\t    /**\n\t     * @ngdoc object\n\t     * @name ui.router.state.$uiViewScroll\n\t     *\n\t     * @requires $anchorScroll\n\t     * @requires $timeout\n\t     *\n\t     * @description\n\t     * When called with a jqLite element, it scrolls the element into view (after a\n\t     * `$timeout` so the DOM has time to refresh).\n\t     *\n\t     * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t     * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t     */\n\t    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t            if (useAnchorScroll) {\n\t                return $anchorScroll;\n\t            }\n\t            return function ($element) {\n\t                return $timeout(function () {\n\t                    $element[0].scrollIntoView();\n\t                }, 0, false);\n\t            };\n\t        }];\n\t}\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=angular-ui-router.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 5\n ** module chunks = 0\n **/","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-animate/index.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * @license AngularJS v1.5.7\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar copy        = angular.copy;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"mainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('mainController', function() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (angular.isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== \"boolean\") {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || function(arg) {\n      // jshint bitwise: false\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n      // jshint bitwise: true\n    };\n\n    function findCallbacks(parent, element, event) {\n      var targetNode = getDomNode(element);\n      var targetParentNode = getDomNode(parent);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, element) {\n      if (phase === 'close' && !element[0].parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(element);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !angular.isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.put(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(element, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $document[0].hidden;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parent, element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, element);\n            });\n          } else {\n            cleanupEventListeners(phase, element);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.remove(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n      var elementDisabled = disabledElementsLookup.get(getDomNode(element));\n\n      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      parentElement = getDomNode(parentElement);\n\n      while (parentElement) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        if (parentElement.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentElement) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentElementDisabled = disabledElementsLookup.get(parentElement);\n\n          if (parentElementDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentElementDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        if (bodyElementDetected && rootElementDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootElementDetected) {\n          // If no rootElement is detected, check if the parentElement is pinned to another element\n          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentElement = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentElement = parentElement.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/* global angularAnimateModule: true,\n\n   ngAnimateSwapDirective,\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-animate/angular-animate.js\n ** module id = 7\n ** module chunks = 0\n **/","import angular from 'angular';\n\nimport services from '../services';\nimport BookmarksController from './BookmarksController.js';\n\nimport editBookmarks from './edit';\nimport createBookmarks from './create';\n\nimport routing from './routing.js';\n\nangular.module('eggly.bookmarks', [ services, editBookmarks, createBookmarks ])\n\t.controller('bookmarksController', BookmarksController )\n\t.config(routing);\n\nexport default 'eggly.bookmarks';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/index.js\n **/","import angular from 'angular';\n\nimport CategoriesService from './CategoriesService.js';\nimport BookmarksService from './BookmarksService.js';\n\nangular.module('eggly.services', [])\n\t.service('bookmarksService', BookmarksService )\n\t.service('categoriesService', CategoriesService );\n\nexport default 'eggly.services';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/services/index.js\n **/","//import categories from 'json!categories.json';\n//console.log (categories);\n\nclass CategoriesSrv {\n\n  constructor ($http, $q) {\n  \tthis.urlFetch = 'data/categories.json';\n  \tthis.$http = $http;\n  \tthis.$q = $q;\n  \tthis.categories = [];\n\t\tthis.currentCategory;\n\t}\n\n\tgetCategories() {\n\n\t\tfunction cacheCategories(result) {\n\t\t\tconsole.log(\"cacheCategories...\");\n\t\t\tconsole.log(result);\n\t\t\tconst extract = (result) => result.data;\n\t\t\tthis.categories = extract(result);\n\t\t\treturn this.categories;\n\t\t}\n\n\t\tif (this.categories.length) {\n\t\t\tconsole.log (this.categories);\n\t\t\treturn this.$q.when( this.categories )\n\t\t}\n\t\telse {\n\t\t\tconsole.log (\"this.$http...\");\n\t\t\treturn this.$http.get( this.urlFetch ).then( cacheCategories );\n\t\t}\n\t};\n\n\tgetCurrentCategory() {\n\t\treturn this.currentCategory;\n\t};\n\n\tgetCurrentCategoryName() {\n\t\treturn this.currentCategory ? this.currentCategory.name : '';\n\t};\n\n\tsetCurrentCategory(category) {\n    this.currentCategory = category;\n    return this.currentCategory;\n  };\n\n\tcreateCategory (category) {\n    category.id = this.categories.length;\n    this.categories.push(category);\n  };\n\n\tdeleteCategory(category) {\n    _.remove(this.categories, function (c) {\n      return c.id == category.id;\n    });\n  };\n\n\tgetBookmarkById(bookmarkId) {\n\t\tvar deferred = $q.defer();\n\t\tconst hasId = (bookmark) => bookmark.id === parseInt(bookmarkId, 10);\n\t\tconst findBookmark = (bookmarkId) => _.find(bookmarks, hasId)\n\t\tvar bookmarkFound = findBookmark(bookmarkId);\n\n    if (this.bookmarks) {\n      deferred.resolve( bookmarkFound )\n    } else {\n      this.getBookmarks()\n      \t.then( () => deferred.resolve( bookmarkFound ) )\n    }\n    return deferred.promise;\n  };\n\n  getCategoryByName(categoryName) {\n\t\tvar deferred = $q.defer();\n\t\tconst hasName = (category) => category.name == categoryName;\n\t\tconst findCategory = () => _.find(categories, hasName)\n\t\tvar categoryFound = findCategory();\n\n\t\tif (categories) {\n\t\t  deferred.resolve( categoryFound );\n\t\t} else {\n\t\t  this.getCategories()\n\t\t\t\t.then( () => deferred.resolve( categoryFound ) )\n\t\t}\n\n\t\treturn deferred.promise;\n\n\t};\n\n}\n\nCategoriesSrv.$inject = ['$http', '$q'];\n\nexport default CategoriesSrv;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/services/CategoriesService.js\n **/","class BookmarksSrv {\n\n  constructor ($http, $q) {\n  \tthis.urlFetch ='data/bookmarks.json';\n  \tthis.$http = $http;\n  \tthis.$q = $q;\n  \tthis.bookmarks = [];\n\t}\n\n\tgetBookmarks() {\n\n\t\tconst extract = (result) => result.data;\n\t\tconst cacheBookmarks = (result) => {\n\t\t\tlet bookmarks = extract(result);\n      return bookmarks;\n    }\n\n    // return always a promise\n\t\tif (this.bookmarks) {\n\t\t\treturn this.$q.when(this.bookmarks);\n\t\t}\n\t\telse {\n \t\t\treturn this.$http.get( this.urlFetch )\n \t\t\t\t.then(cacheBookmarks);\n\t\t}\n\t};\n\n\tgetBookmarkById(bookmarkId) {\n\t\tvar deferred = $q.defer();\n\t\tconst hasId = (bookmark) => bookmark.id === parseInt(bookmarkId, 10);\n\t\tconst findBookmark = () => _.find(bookmarks, hasId)\n\t\tvar bookmarkFound = findBookmark();\n\n    if (this.bookmarks) {\n      deferred.resolve( bookmarkFound )\n    } else {\n      this.getBookmarks()\n      \t.then( () => deferred.resolve( bookmarkFound ) )\n    }\n    return deferred.promise;\n  };\n\n  createBookmark(bookmark) {\n  \tconst id = this.bookmarks.length;\n    this.bookmarks.push( {id} );\n  };\n\n  updateBookmark(bookmark) {\n    let index = _.findIndex(this.bookmarks, function (b) {\n      return b.id == bookmark.id\n    });\n    this.bookmarks[index] = bookmark;\n  };\n\n  deleteBookmark(bookmark) {\n    _.remove(this.bookmarks, function (b) {\n      return b.id == bookmark.id;\n    });\n  };\n\n\tgetBookmarksForCategory(category) {\n\t  _.filter(bookmarks, function (b) {\n\t    return b.category == category;\n\t  });\n\t};\n\n}\n\nBookmarksSrv.$inject = ['$http', '$q'];\n\nexport default BookmarksSrv;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/services/BookmarksService.js\n **/","class BookmarksCtrl {\n\tconstructor( $stateParams, bookmarksSrv, categoriesSrv )\t{\n\n\t\tcategoriesSrv.setCurrentCategory();\n\n    if ($stateParams.category) {\n      categoriesSrv.getCategoryByName($stateParams.category)\n      \t.then( (category) => categoriesSrv.setCurrentCategory(category) )\n    }\n\n    bookmarksSrv.getBookmarks()\n      .then( (result) => this.bookmarks = result );\n\n    this.getCurrentCategory = categoriesSrv.getCurrentCategory;\n    this.getCurrentCategoryName = categoriesSrv.getCurrentCategoryName;\n    this.isSelectedBookmark = (bookmarkId) => $stateParams.bookmarkId == bookmarkId;\n    this.deleteBookmark = bookmarksSrv.deleteBookmark;\n\t}\n}\n\nBookmarksCtrl.$inject = [ '$stateParams', 'bookmarksService', 'categoriesService'];\n\nexport default BookmarksCtrl;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/BookmarksController.js\n **/","import angular from 'angular';\nimport ngUiRoute from 'angular-ui-router';\n\nimport services  from '../../services';\nimport EditController from './EditController.js';\nimport routing from './routing.js';\n\n\nangular.module('eggly.bookmarks.edit', [ ngUiRoute, services ])\n\t.controller( 'editController', EditController)\n  .config( routing )\n\nexport default 'eggly.bookmarks.edit';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/edit/index.js\n **/","class EditCtrl {\n\n\tconstructor( bookmarksSrv, $stateParams, $state ) {\n\n\t\tthis.isEditing = false;\n\n    function returnToBookmarks() {\n      $state.go('eggly.categories.bookmarks', {\n        category: $stateParams.category\n      })\n    }\n\n    function setEditState(bookmark) {\n      if (bookmark) {\n        this.isEditing = true;\n        this.bookmark = bookmark;\n        this.editedBookmark = angular.copy(this.bookmark);\n      }\n      else {\n        returnToBookmarks();\n      }\n    }\n\n    function updateBookmark() {\n      this.bookmark = angular.copy(this.editedBookmark);\n      bookmarks.updateBookmark(this.editedBookmark);\n      returnToBookmarks();\n    }\n\n    function cancelEditing() {\n      this.isEditing = false;\n      returnToBookmarks();\n    }\n\n    bookmarksSrv.getBookmarkById($stateParams.bookmarkId)\n    \t.then( setEditState );\n\n    this.toggleEditing = () => this.isEditing = !this.isEditing;\n    this.cancelEditing = cancelEditing;\n    this.updateBookmark = updateBookmark;\n\n\t}\n\n}\n\nEditCtrl.$inject = ['bookmarksService', '$stateParams', '$state'];\n\nexport default EditCtrl;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/edit/EditController.js\n **/","import template from './edit.tpl.html';\nconst controller = 'editController';\nconst controllerAs = '$ctrl';\n\nfunction routing ($stateProvider) {\n  $stateProvider.state('eggly.categories.bookmarks.edit', {\n    url: 'categories/:category',\n    views: { '@eggly.categories.bookmarks': { controller, template, controllerAs } }\n  });\n}\n\nrouting.$inject = ['$stateProvider'];\n\nexport default routing;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/edit/routing.js\n **/","module.exports = \"<h4>Editing {{bookmark.title}}</h4>\\n\\n<form class=\\\"edit-form\\\" ng-show=\\\"isEditing\\\" role=\\\"form\\\" ng-submit=\\\"updateBookmark()\\\" novalidate>\\n    <div class=\\\"form-group\\\">\\n        <label>Bookmark Title</label>\\n        <input type=\\\"text\\\" class=\\\"form-control\\\" ng-model=\\\"editedBookmark.title\\\" placeholder=\\\"Enter title\\\">\\n    </div>\\n    <div class=\\\"form-group\\\">\\n        <label>Bookmark URL</label>\\n        <input type=\\\"text\\\" class=\\\"form-control\\\" ng-model=\\\"editedBookmark.url\\\" placeholder=\\\"Enter URL\\\">\\n    </div>\\n    <button type=\\\"submit\\\" class=\\\"btn btn-info btn-lg\\\">Save</button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-default btn-lg pull-right\\\" ng-click=\\\"cancelEditing()\\\">Cancel</button>\\n</form>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/bookmarks/edit/edit.tpl.html\n ** module id = 16\n ** module chunks = 0\n **/","import angular from 'angular';\nimport ngUiRoute from 'angular-ui-router';\n\nimport services  from '../../services';\nimport CreateController from './CreateController.js';\nimport routing from './routing.js';\n\n\nangular.module('eggly.bookmarks.edit', [ ngUiRoute, services ])\n\t.controller( 'createController', CreateController)\n  .config( routing )\n\nexport default 'eggly.bookmarks.edit';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/create/index.js\n **/","class CreateCtrl {\n\n\tconstructor ($stateParams, $state, bookmarksSrv) {\n\n    this.isCreating = false;\n\n    function returnToBookmarks() {\n      $state.go('eggly.categories.bookmarks', {\n        category: $stateParams.category\n      })\n    }\n\n    function cancelCreating() {\n      this.isCreating = false;\n      returnToBookmarks();\n    }\n\n    function createBookmark() {\n      bookmarksSrv.createBookmark(this.newBookmark);\n      returnToBookmarks();\n    }\n\n    function resetForm() {\n      this.newBookmark = {\n        title: '',\n        url: '',\n        category: $stateParams.category\n      };\n    }\n\n    this.toggleCreating = () => this.isCreating = !this.isCreating;\n    this.cancelCreating = cancelCreating;\n    this.createBookmark = createBookmark;\n\n    resetForm();\n    toggleCreating();\n\n  }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/create/CreateController.js\n **/","import template from './create.tpl.html';\nconst controller = 'createController';\nconst controllerAs = '$ctrl';\n\nfunction routing ($stateProvider) {\n  $stateProvider.state('eggly.categories.bookmarks.create', {\n    url: '/bookmarks/create',\n    views: { '@eggly.categories.bookmarks': { controller, template, controllerAs } }\n  });\n}\n\nrouting.$inject = ['$stateProvider'];\n\nexport default routing;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/create/routing.js\n **/","module.exports = \"<div class=\\\"createBookmark\\\">\\n    <form class=\\\"create-form\\\" ng-show=\\\"isCreating\\\" role=\\\"form\\\" ng-submit=\\\"createBookmark()\\\" novalidate>\\n        <div class=\\\"form-group\\\">\\n            <label for=\\\"newBookmarkTitle\\\">Bookmark Title</label>\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"newBookmarkTitle\\\" ng-model=\\\"newBookmark.title\\\" placeholder=\\\"Enter title\\\">\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <label for=\\\"newBookmarkURL\\\">Bookmark URL</label>\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"newBookmarkURL\\\" ng-model=\\\"newBookmark.url\\\" placeholder=\\\"Enter URL\\\">\\n        </div>\\n        <button type=\\\"submit\\\" class=\\\"btn btn-info btn-lg\\\">Create</button>\\n        <button type=\\\"button\\\" class=\\\"btn btn-default btn-lg pull-right\\\" ng-click=\\\"cancelCreating()\\\">Cancel</button>\\n    </form>\\n</div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/bookmarks/create/create.tpl.html\n ** module id = 20\n ** module chunks = 0\n **/","import template from './bookmarks.tpl.html';\nconst controller =  'bookmarksController';\nconst controllerAs = '$ctrl';\n\nfunction routing ($stateProvider) {\n  $stateProvider.state('eggly.categories.bookmarks', {\n    url: 'categories/:category',\n    views: { 'bookmarks@': { controller, template, controllerAs } }\n  });\n}\n\n\nrouting.$inject = ['$stateProvider'];\n\nexport default routing;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/bookmarks/routing.js\n **/","module.exports = \"<div ui-sref-active=\\\"editing\\\" bookmark=\\\"bookmark\\\" ng-class=\\\"{active: isSelectedBookmark(bookmark.id)}\\\"  ng-repeat=\\\"bookmark in bookmarks | filter:{category:getCurrentCategoryName()}\\\">\\n\\n  <button type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"deleteBookmark(bookmark)\\\">&times;</button>\\n  <button type=\\\"button\\\" class=\\\"btn btn-link\\\" ui-sref=\\\"eggly.categories.bookmarks.edit({category:bookmark.category, bookmarkId:bookmark.id})\\\"><span class=\\\"glyphicon glyphicon-pencil\\\"></span>\\n  </button>\\n  <a href=\\\"{{bookmark.url}}\\\" target=\\\"_blank\\\">{{bookmark.title}}</a>\\n</div>\\n<hr/>\\n\\n<ui-view>\\n  <div ng-if=\\\"getCurrentCategory()\\\">\\n    <button type=\\\"button\\\" class=\\\"btn btn-link\\\"\\n            ui-sref=\\\"eggly.categories.bookmarks.create({category:getCurrentCategoryName()})\\\"><span\\n        class=\\\"glyphicon glyphicon-plus\\\"></span>\\n      Create Bookmark\\n    </button>\\n  </div>\\n</ui-view>\\n\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/bookmarks/bookmarks.tpl.html\n ** module id = 22\n ** module chunks = 0\n **/","import angular from 'angular';\n\nimport services from '../services';\nimport CategoriesController from './CategoriesController.js';\n\nimport routing from './routing.js';\n\nangular.module('eggly.categories', [ services ])\n\t.controller('categoriesController', CategoriesController )\n\t.config(routing);\n\nexport default 'eggly.categories';\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/categories/index.js\n **/","class CategoriesCtrl {\n\n\tconstructor ( categoriesSrv ) {\n\n\t\tthis.getCurrentCategoryName = categoriesSrv.getCurrentCategoryName;\n\n\t\tcategoriesSrv.getCategories()\n\t\t\t.then( (result) => this.categories = result );\n\n\t\tthis.isCurrentCategory = (category) => category.name === this.getCurrentCategoryName();\n\n  }\n\n}\n\n\nCategoriesCtrl.$inject = [ 'categoriesService' ];\n\nexport default CategoriesCtrl;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/categories/CategoriesController.js\n **/","import categoriesTpl from './categories.tpl.html';\nconst categoriesCtrl = 'categoriesController';\n\nimport bookmarksTpl from '../bookmarks/bookmarks.tpl.html';\nconst bookmarksCtrl =  'bookmarksController';\n\n\nfunction routing ($stateProvider) {\n  $stateProvider\n    .state('eggly.categories', {\n      url: '/',\n      views: {\n        'categories@': {\n          controller: categoriesCtrl,\n          template: categoriesTpl,\n          controllerAs: '$ctrl'\n        },\n        'bookmarks@': {\n          controller: bookmarksCtrl,\n          template: bookmarksTpl,\n          controllerAs: '$ctrl'\n        }\n      }\n    });\n}\n\nrouting.$inject = ['$stateProvider'];\n\nexport default routing;\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/categories/routing.js\n **/","module.exports = \"<p>hello!!!  {{ $ctrl.categories.length }}</p>\\n<a href=\\\"#/\\\"><img class=\\\"logo\\\" src=\\\"assets/img/eggly-logo.png\\\"></a>\\n<ul class=\\\"nav nav-sidebar\\\">\\n    <li ng-repeat=\\\"category in $ctrl.categories\\\" ng-class=\\\"{'active':$ctrl.isCurrentCategory(category)}\\\">\\n      <a ui-sref=\\\"eggly.categories.bookmarks({category: category.name})\\\">\\n        category: {{category.name}}\\n      </a></li>\\n</ul>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app/categories/categories.tpl.html\n ** module id = 26\n ** module chunks = 0\n **/","const url = '';\nconst abstract = true;\n\nfunction routing ( $stateProvider, $urlRouterProvider ) {\n  $stateProvider.state('eggly', { url, abstract });\n\t$urlRouterProvider.otherwise('/');\n};\n\nrouting.$inject = ['$stateProvider', '$urlRouterProvider'];\n\nexport default routing;\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/routing.js\n **/"],"sourceRoot":""}